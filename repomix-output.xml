This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
agents/
  __init__.py
  agent.py
  manager.py
core/
  __init__.py
  config.py
  game_loop.py
input/
  __init__.py
  handlers.py
rendering/
  __init__.py
  debug_display.py
  grid.py
resources/
  __init__.py
  berry_bush.py
  manager.py
  mill.py
  node.py
  processing.py
  resource_types.py
  storage_point.py
  wheat_field.py
tasks/
  task_manager.py
  task_types.py
  task.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="agents/__init__.py">
# This file makes Python treat the directory 'agents' as a package.
</file>

<file path="agents/agent.py">
import pygame
import uuid # For agent ID
from enum import Enum, auto
import random
from typing import List, Dict, Optional, TYPE_CHECKING
import math # For math.inf

from ..resources.resource_types import ResourceType
from ..core import config # Agent still uses config for timers, capacity if not overridden by task

# Forward references for type hinting
if TYPE_CHECKING:
    from ..tasks.task import Task
    from ..tasks.task_manager import TaskManager
    from ..resources.manager import ResourceManager # For passing to tasks
    # from ..core.grid import Grid # Assuming Grid class type hint


class AgentState(Enum):
    """Defines the possible states an agent can be in. Tasks will set these."""
    IDLE = auto()
    MOVING_RANDOMLY = auto()
    MOVING_TO_RESOURCE = auto()
    GATHERING_RESOURCE = auto()
    MOVING_TO_STORAGE = auto()
    DELIVERING_RESOURCE = auto()
    MOVING_TO_PROCESSOR = auto()
    DELIVERING_TO_PROCESSOR = auto()
    COLLECTING_FROM_PROCESSOR = auto()

class Agent:
    """Represents an autonomous agent in the simulation, executing tasks."""

    def __init__(self,
                 agent_id: uuid.UUID, 
                 position: pygame.math.Vector2,
                 speed: float,
                 grid, # 'Grid' type hint
                 task_manager: 'TaskManager', 
                 inventory_capacity: int,
                 resource_priorities: Optional[List[ResourceType]] = None):
        """
        Initializes an Agent.
        Args:
            agent_id (uuid.UUID): Unique identifier for this agent.
            position (pygame.math.Vector2): The starting grid coordinates of the agent.
            speed (float): The movement speed of the agent (grid units per second).
            grid (Grid): The simulation grid object.
            task_manager (TaskManager): Reference to the global task manager.
            inventory_capacity (int): Maximum number of resource units the agent can carry.
            resource_priorities (Optional[List[ResourceType]]): Ordered list of resource types the agent prefers.
                                                               Might be used by TaskManager.
        """
        self.id: uuid.UUID = agent_id
        self.position = position
        self.speed = speed
        self.grid = grid # type: ignore
        self.task_manager_ref: 'TaskManager' = task_manager
        self.config = config 

        self.state = AgentState.IDLE
        self.target_position: Optional[pygame.math.Vector2] = None # Set by tasks
        self.color = (255, 255, 0)

        self.state_colors = {
            AgentState.IDLE: (255, 255, 0),
            AgentState.MOVING_RANDOMLY: (255, 165, 0),
            AgentState.MOVING_TO_RESOURCE: (0, 200, 50),
            AgentState.GATHERING_RESOURCE: (50, 150, 255),
            AgentState.MOVING_TO_STORAGE: (0, 200, 200),
            AgentState.DELIVERING_RESOURCE: (100, 100, 255),
            AgentState.MOVING_TO_PROCESSOR: (255, 140, 0),
            AgentState.DELIVERING_TO_PROCESSOR: (138, 43, 226),
            AgentState.COLLECTING_FROM_PROCESSOR: (0, 128, 128),
        }
        self.target_tolerance = 0.1

        self.inventory_capacity: int = inventory_capacity
        self.current_inventory: Dict[str, Optional[ResourceType] | int] = {
            'resource_type': None,
            'quantity': 0
        }
        
        self.current_task: Optional['Task'] = None
        self.resource_priorities: Optional[List[ResourceType]] = resource_priorities

        self.gathering_timer: float = 0.0
        self.delivery_timer: float = 0.0

    def set_target(self, target_position: pygame.math.Vector2):
        """Sets the agent's target position. Primarily called by tasks."""
        self.target_position = target_position
        # The agent's state (e.g., MOVING_TO_RESOURCE) should be set by the task itself.
        # print(f"DEBUG: Agent {self.id} set_target: NewTargetGridPos={self.target_position}")

    def _move_towards_target(self, dt: float) -> bool:
        """
        Moves the agent towards its target position.
        Args: dt (float): Delta time.
        Returns: bool: True if the target was reached this frame, False otherwise.
        """
        if self.target_position is None:
            return False

        direction = self.target_position - self.position
        distance = direction.length()

        if distance < self.target_tolerance:
            self.position = pygame.math.Vector2(self.target_position) 
            self.target_position = None 
            return True
        elif distance > 0:
            normalized_direction = direction.normalize()
            movement = normalized_direction * self.speed * dt
            if movement.length() >= distance:
                self.position = pygame.math.Vector2(self.target_position)
                self.target_position = None
                return True
            else:
                self.position += movement
        return False

    def _move_randomly(self, dt: float):
        """Moves the agent randomly within the grid bounds."""
        if self.target_position is None: 
            if self.grid.width_in_cells > 0 and self.grid.height_in_cells > 0: # type: ignore
                self.target_position = pygame.math.Vector2(
                    random.uniform(0, self.grid.width_in_cells - 1), # type: ignore
                    random.uniform(0, self.grid.height_in_cells - 1) # type: ignore
                )
                self.target_position.x = max(0, min(self.target_position.x, self.grid.width_in_cells - 1)) # type: ignore
                self.target_position.y = max(0, min(self.target_position.y, self.grid.height_in_cells - 1)) # type: ignore
            else: 
                self.state = AgentState.IDLE 
                return

        if self._move_towards_target(dt): 
            self.state = AgentState.IDLE

    def update(self, dt: float, resource_manager: 'ResourceManager'):
        """Updates the agent's state and behavior based on its current task or idleness."""
        from ..tasks.task_types import TaskStatus 

        if self.current_task:
            new_task_status = self.current_task.execute_step(self, dt, resource_manager)
            
            if new_task_status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]:
                self.current_task.cleanup(self, resource_manager, success=(new_task_status == TaskStatus.COMPLETED))
                self.task_manager_ref.report_task_outcome(self.current_task, new_task_status, self)
                
                self.current_task = None
                self.state = AgentState.IDLE 
                self.target_position = None   

                if new_task_status == TaskStatus.COMPLETED and self.current_inventory['quantity'] == 0:
                    self.current_inventory['resource_type'] = None
        
        elif self.state == AgentState.IDLE: 
            assigned_task = self.task_manager_ref.request_task_for_agent(self)
            if assigned_task:
                self.current_task = assigned_task
                if self.current_task: # mypy check
                    self.current_task.agent_id = self.id 
                
                    if self.current_task.prepare(self, resource_manager):
                        pass 
                    else:
                        self.current_task.cleanup(self, resource_manager, success=False) 
                        self.task_manager_ref.report_task_outcome(self.current_task, TaskStatus.FAILED, self)
                        self.current_task = None
                        self.state = AgentState.IDLE 
            else:
                self.state = AgentState.MOVING_RANDOMLY 
        
        if self.current_task is None: 
            if self.state == AgentState.MOVING_RANDOMLY:
                self._move_randomly(dt)
            elif self.state != AgentState.IDLE: 
                self.state = AgentState.IDLE
                self.target_position = None

    def draw(self, screen: pygame.Surface, grid): 
        """Draws the agent on the screen."""
        screen_pos = self.grid.grid_to_screen(self.position) # type: ignore
        agent_radius = self.grid.cell_width // 2 # type: ignore

        current_agent_color = self.state_colors.get(self.state, self.color)
        pygame.draw.circle(screen, current_agent_color, screen_pos, agent_radius)

        if self.current_inventory['quantity'] > 0 and self.current_inventory['resource_type'] is not None:
            carried_resource_type = self.current_inventory['resource_type']
            resource_color = self.config.RESOURCE_VISUAL_COLORS.get(carried_resource_type, (128, 128, 128)) 

            icon_radius = agent_radius // 2
            icon_offset_y = -agent_radius - icon_radius // 2 
            icon_center_x = screen_pos[0]
            icon_center_y = screen_pos[1] + icon_offset_y
            
            pygame.draw.circle(screen, resource_color, (icon_center_x, icon_center_y), icon_radius)
</file>

<file path="agents/manager.py">
import pygame
import uuid # For generating agent IDs
from typing import List, TYPE_CHECKING
from .agent import Agent # Relative import from the same package
from ..resources.resource_types import ResourceType

if TYPE_CHECKING:
    from ..tasks.task_manager import TaskManager
    # from ..core.grid import Grid # Assuming Grid class type hint

class AgentManager:
    """Manages all agents in the simulation."""

    def __init__(self, grid, task_manager: 'TaskManager'): # Added task_manager
        """
        Initializes the AgentManager.

        Args:
            grid (Grid): The simulation grid object.
            task_manager (TaskManager): Reference to the task manager.
        """
        self.agents: List[Agent] = []
        self.grid = grid # Store the grid object
        self.task_manager_ref: 'TaskManager' = task_manager # Store task_manager reference

    def add_agent(self, agent: Agent):
        """Adds an existing Agent instance to the manager."""
        self.agents.append(agent)

    def create_agent(self,
                     position: pygame.math.Vector2,
                     speed: float,
                     inventory_capacity: int = 5, # Default value from plan/previous code
                     resource_priorities: List[ResourceType] = None # Default to None or sensible default
                     ) -> Agent:
        """
        Creates a new Agent, adds it to the manager, and returns it.

        Args:
            position (pygame.math.Vector2): The starting position of the agent.
            speed (float): The movement speed of the agent.
            inventory_capacity (int): Agent's inventory capacity.
            resource_priorities (List[ResourceType]): Agent's resource priorities.

        Returns:
            Agent: The newly created agent instance.
        """
        agent_id = uuid.uuid4()
        if resource_priorities is None:
            # Provide a default if not specified, e.g. based on global config or common resources
            resource_priorities = [ResourceType.BERRY, ResourceType.WHEAT]

        new_agent = Agent(
            agent_id=agent_id,
            position=position,
            speed=speed,
            grid=self.grid,
            task_manager=self.task_manager_ref, # Pass the TaskManager reference
            inventory_capacity=inventory_capacity,
            resource_priorities=resource_priorities
        )
        self.add_agent(new_agent)
        print(f"Created agent {agent_id} at {position}") # Debug
        return new_agent

    def update_agents(self, dt: float, resource_manager): # resource_manager type hint can be added
        """Updates all managed agents."""
        for agent in self.agents:
            agent.update(dt, resource_manager)

    def render_agents(self, screen: pygame.Surface, grid):
        """Renders all managed agents."""
        # Render agents after other elements like the grid, but potentially before UI
        for agent in self.agents:
            agent.draw(screen, grid)
</file>

<file path="core/__init__.py">
# Core module initialization
</file>

<file path="core/config.py">
# Game and Simulation Configuration

from ..resources.resource_types import ResourceType # Import for RESOURCE_VISUAL_COLORS

# Screen dimensions
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
SCREEN_SPAWN_MARGIN = 50  # Margin around the screen for spawning

# Frame rate and timing
TARGET_FPS = 60

# Grid settings
GRID_CELL_SIZE = 32
GRID_COLOR = (50, 50, 50)  # Dark grey

# Colors
COLOR_BLACK = (0, 0, 0)
COLOR_WHITE = (255, 255, 255)
DEBUG_TEXT_COLOR = COLOR_WHITE

# Resource Node Settings
BERRY_BUSH_COLOR = (0, 128, 0)  # Green
BERRY_BUSH_CAPACITY = 23
BERRY_BUSH_GENERATION_INTERVAL = 6 # Resources per second
INITIAL_BERRY_BUSHES = 15
INITIAL_WHEAT_FIELD = 15

WHEAT_GENERATION_INTERVAL = 12 # How many simulation ticks to generate 1 unit of wheat
WHEAT_FIELD_CAPACITY = 11 # Max wheat in a field

# Resource Display Settings
RESOURCE_TEXT_COLOR = COLOR_WHITE
RESOURCE_FONT_SIZE = 16
# NODE_SIZE = GRID_CELL_SIZE # Optional: Use if node size differs from grid cell
# Agent Settings
INITIAL_AGENTS = 10
AGENT_SPEED = 5.0 # Grid units per second
DEFAULT_AGENT_INVENTORY_CAPACITY = 5 # Max items an agent can carry

# Agent Action Timings
DEFAULT_GATHERING_TIME = 2.0 # Seconds to gather a resource
DEFAULT_DELIVERY_TIME = 1.0  # Seconds to deliver a resource

# Resource Visuals (used by agent draw for carried items)
RESOURCE_VISUAL_COLORS = {
    ResourceType.BERRY: (220, 20, 60),   # Crimson for BERRY
    ResourceType.WHEAT: (218, 165, 32),  # Goldenrod for WHEAT
    ResourceType.FLOUR_POWDER: (211, 211, 211), # LightGrey for FLOUR_POWDER
    # Add other resource type colors here as they are defined
    # Example: ResourceType.WATER: (0, 191, 255) # Deep Sky Blue
}
# Task Generation Settings
MIN_BERRY_STOCK_LEVEL = 50
BERRY_GATHER_TASK_QUANTITY = 20
BERRY_GATHER_TASK_PRIORITY = 5
MAX_ACTIVE_BERRY_GATHER_TASKS = 3
# Wheat Task Generation Settings
MIN_WHEAT_STOCK_LEVEL = 40
WHEAT_GATHER_TASK_QUANTITY = 15
WHEAT_GATHER_TASK_PRIORITY = 4
MAX_ACTIVE_WHEAT_GATHER_TASKS = 2
</file>

<file path="core/game_loop.py">
import pygame
import time
import random
from pygame.math import Vector2 # Added for agent positions
from src.core import config
from src.input import handlers as input_handlers
from src.rendering.grid import Grid # Changed from grid_renderer function to Grid class
from src.rendering import debug_display as debug_renderer
from src.resources.manager import ResourceManager
from src.resources.berry_bush import BerryBush
from src.resources.wheat_field import WheatField # Added WheatField
from src.resources.mill import Mill # Added Mill
from src.agents.manager import AgentManager # Added AgentManager
from src.tasks.task_manager import TaskManager # Added TaskManager
from src.resources.storage_point import StoragePoint
from src.resources.resource_types import ResourceType

class GameLoop:
    """
    Manages the main game loop with a fixed timestep for updates
    and variable rendering based on available time.
    """
    def __init__(self, screen):
        self.screen = screen
        self.clock = pygame.time.Clock()
        self.is_running = False
        self.last_time = time.perf_counter()
        self.accumulator = 0.0
        self.dt = 1.0 / config.TARGET_FPS # Timestep duration

        # Initialize Grid
        try:
            self.grid = Grid()
        except ValueError as e:
            print(f"FATAL: Grid initialization failed: {e}")
            # Consider how to handle this - maybe raise exception or exit?
            # For now, let's assume config is valid.
            raise # Re-raise the exception to stop execution if grid fails

        # Initialize font for resource display (ensure pygame.font.init() was called in main)
        try:
            self.resource_font = pygame.font.Font(None, config.RESOURCE_FONT_SIZE)
        except Exception as e:
            print(f"Warning: Could not load default font. Resource text might not display. Error: {e}")
            # Create a fallback font object that might work or fail gracefully in draw
            self.resource_font = pygame.font.Font(pygame.font.get_default_font(), config.RESOURCE_FONT_SIZE)


        # Initialize Resource Manager and spawn initial resources
        self.resource_manager = ResourceManager()
        self._spawn_initial_resources() # Will also spawn Mills here
        self._spawn_initial_storage_points()

        # Initialize Task Manager
        # AgentManager needs a TaskManager, and TaskManager needs an AgentManager.
        # Initialize TaskManager first, potentially with a placeholder for agent_manager_ref if needed,
        # or ensure TaskManager can function/be updated before agent_manager_ref is fully set.
        # Based on current TaskManager constructor, it needs resource_manager and agent_manager.
        # Let's initialize AgentManager first, then TaskManager, then link them.

        # Initialize Agent Manager (will need TaskManager soon)
        # For now, AgentManager's __init__ takes task_manager. So TaskManager must be first.
        self.task_manager = TaskManager(resource_manager=self.resource_manager, agent_manager=None) # type: ignore
        
        # Initialize Agent Manager and pass the TaskManager
        self.agent_manager = AgentManager(grid=self.grid, task_manager=self.task_manager)
        
        # Now, set the agent_manager_ref in TaskManager
        self.task_manager.agent_manager_ref = self.agent_manager

        self._spawn_initial_agents() # Uses grid coords

    def _spawn_initial_agents(self):
        """Creates and places the initial agents."""
        # Example: Spawn agents at specific grid coordinates
        # Ensure these coordinates are valid for the grid size
        for _ in range(config.INITIAL_AGENTS):
            screen_pos_x = random.uniform(config.SCREEN_SPAWN_MARGIN, config.SCREEN_WIDTH - config.SCREEN_SPAWN_MARGIN)
            screen_pos_y = random.uniform(config.SCREEN_SPAWN_MARGIN, config.SCREEN_HEIGHT - config.SCREEN_SPAWN_MARGIN)
            screen_position = pygame.Vector2(screen_pos_x, screen_pos_y)
            grid_position = self.grid.screen_to_grid(screen_position) # Convert to grid coordinates
            agent = self.agent_manager.create_agent(position=grid_position, speed=config.AGENT_SPEED) # Pass grid position
            print(f"  Spawned Agent at grid position {grid_position}") # DEBUG

    def handle_input(self):
        """Handles user input using the input handler module."""
        if input_handlers.process_events():
            self.is_running = False

    def _spawn_initial_resources(self):
        """Creates and places the initial resource nodes."""
        print(f"Spawning {config.INITIAL_BERRY_BUSHES} berry bushes...") # DEBUG
        spawn_margin = config.SCREEN_SPAWN_MARGIN # Avoid spawning too close to screen edges
        for _ in range(config.INITIAL_BERRY_BUSHES):
            # Ensure bushes are placed within screen bounds, respecting margin
            screen_pos_x = random.uniform(spawn_margin, config.SCREEN_WIDTH - spawn_margin)
            screen_pos_y = random.uniform(spawn_margin, config.SCREEN_HEIGHT - spawn_margin)
            screen_position = pygame.Vector2(screen_pos_x, screen_pos_y)
            grid_position = self.grid.screen_to_grid(screen_position) # Convert to grid coordinates
            
            bush = BerryBush(grid_position) # Pass grid coordinates
            self.resource_manager.add_node(bush)
            print(f"DEBUG: Spawned BerryBush at screen_pos: {screen_position}, which is grid_pos: {grid_position}. Bush stores: {bush.position}")

        # Spawn WheatFields
        num_wheat_fields = config.INITIAL_WHEAT_FIELD # Example number
        print(f"Spawning {num_wheat_fields} wheat fields...")
        for _ in range(num_wheat_fields):
            screen_pos_x = random.uniform(spawn_margin, config.SCREEN_WIDTH - spawn_margin)
            screen_pos_y = random.uniform(spawn_margin, config.SCREEN_HEIGHT - spawn_margin)
            grid_position = self.grid.screen_to_grid(pygame.Vector2(screen_pos_x, screen_pos_y))
            
            wheat_field = WheatField(grid_position)
            self.resource_manager.add_node(wheat_field)
            print(f"DEBUG: Spawned WheatField at grid_pos: {grid_position}")

        # Spawn Mills
        mill_positions_grid = [Vector2(3, 3), Vector2(self.grid.width_in_cells - 4, self.grid.height_in_cells - 4)]
        print(f"Spawning {len(mill_positions_grid)} mills...")
        for pos in mill_positions_grid:
            if self.grid.is_within_bounds(pos):
                mill = Mill(pos)
                self.resource_manager.add_processing_station(mill) # Use the correct method
                print(f"DEBUG: Spawned Mill at grid_pos: {pos}")
            else:
                print(f"Warning: Initial mill position {pos} is outside grid bounds. Skipping.")


    def _spawn_initial_storage_points(self):
        """Creates and places the initial storage points."""
        # Calculate middle of the screen in grid coordinates
        middle_screen_x_pixels = config.SCREEN_WIDTH / 2
        middle_screen_y_pixels = config.SCREEN_HEIGHT / 2
        middle_screen_pixel_pos = pygame.math.Vector2(middle_screen_x_pixels, middle_screen_y_pixels)
        storage_position_grid = self.grid.screen_to_grid(middle_screen_pixel_pos)

        # Define storage point properties
        capacity = 25  # Updated capacity for shared storage
        accepted_types = [ResourceType.BERRY, ResourceType.WHEAT]

        # Create and add the storage point
        berry_storage_point = StoragePoint(
            position=storage_position_grid,
            overall_capacity=capacity,
            accepted_resource_types=accepted_types
        )
        # Assumes add_storage_point method exists in ResourceManager as per SLICE_2.2_PLAN.md
        self.resource_manager.add_storage_point(berry_storage_point)
        print(f"DEBUG: Spawned StoragePoint at grid_pos: {storage_position_grid} for BERRY and WHEAT with capacity {capacity}")

        # Spawn StoragePoint for Flour Powder
        flour_storage_position_grid = Vector2(self.grid.width_in_cells / 2 + 5, self.grid.height_in_cells / 2) # Example position
        if not self.grid.is_within_bounds(flour_storage_position_grid): # Ensure it's on grid
            flour_storage_position_grid = Vector2(max(0, min(flour_storage_position_grid.x, self.grid.width_in_cells -1)),
                                                  max(0, min(flour_storage_position_grid.y, self.grid.height_in_cells -1)))


        flour_storage_capacity = 30
        flour_accepted_types = [ResourceType.FLOUR_POWDER]
        flour_storage_point = StoragePoint(
            position=flour_storage_position_grid,
            overall_capacity=flour_storage_capacity,
            accepted_resource_types=flour_accepted_types
        )
        self.resource_manager.add_storage_point(flour_storage_point)
        print(f"DEBUG: Spawned StoragePoint at grid_pos: {flour_storage_position_grid} for FLOUR_POWDER with capacity {flour_storage_capacity}")


    def update(self, dt):
        """Updates game state, including resource nodes."""
        # Update resource nodes
        self.resource_manager.update_nodes(dt)

        # Update Task Manager (e.g., for task generation, timeouts)
        self.task_manager.update(dt)

        # Update agents (agents will interact with TaskManager)
        self.agent_manager.update_agents(dt, self.resource_manager)

        # Placeholder for other game entity updates

    def render(self):
        """Renders the current game state."""
        self.screen.fill(config.COLOR_BLACK) # Clear screen

        # Draw the grid using the Grid object
        self.grid.draw(self.screen)

        # Draw resource nodes
        self.resource_manager.draw_nodes(self.screen, self.resource_font, self.grid) # Pass grid object

        # Draw agents
        self.agent_manager.render_agents(self.screen, self.grid)

        # Draw debug info (FPS)
        # Use clock attribute directly for FPS calculation
        debug_renderer.display_fps(self.screen, self.clock)

        pygame.display.flip() # Update the full display Surface to the screen

    def run(self):
        """Executes the main game loop."""
        self.is_running = True
        self.last_time = time.perf_counter() # Reset timer before loop starts

        while self.is_running:
            current_time = time.perf_counter()
            frame_time = current_time - self.last_time
            self.last_time = current_time

            # Cap frame time to avoid spiral of death
            if frame_time > 0.25:
                frame_time = 0.25

            self.accumulator += frame_time

            # Input handling happens once per frame
            self.handle_input()

            # Fixed timestep updates
            while self.accumulator >= self.dt:
                self.update(self.dt)
                self.accumulator -= self.dt

            # Rendering happens based on available time
            # Optional: Could add interpolation factor here: alpha = self.accumulator / self.dt
            self.render()

            # Yield control, helps manage CPU usage slightly
            # We can use clock.tick here to limit the *rendering* frame rate
            # if needed, but the update logic is decoupled by the fixed step.
            self.clock.tick() # Tick without arg just measures time for get_fps()

        # Pygame quit is handled in main.py after the loop exits
</file>

<file path="input/__init__.py">
# Input module initialization
</file>

<file path="input/handlers.py">
import pygame

def process_events():
    """
    Processes Pygame events.
    Returns True if the game should quit, False otherwise.
    """
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return True # Signal to quit
    return False # Continue running
</file>

<file path="rendering/__init__.py">
# Rendering module initialization
</file>

<file path="rendering/debug_display.py">
import pygame
from src.core import config

# Initialize font module (ideally done once at startup in main)
# pygame.font.init() # Assuming it's initialized in main.py later
debug_font = None

def init_debug_font():
    """Initializes the font used for debug text."""
    global debug_font
    # Prioritize Pygame's default font due to potential system font issues (fc-list missing)
    try:
        debug_font = pygame.font.Font(None, 20) # Pygame's default font
    except Exception as e:
        debug_font = None # Ensure it's None if default fails

def display_fps(surface, clock):
    """Renders the current FPS onto the surface."""
    # print("DEBUG: display_fps called") # DEBUG - Redundant with GameLoop log
    if not debug_font:
        init_debug_font() # Initialize if not already done

    if debug_font:
        # print("DEBUG: display_fps - debug_font available, rendering FPS") # DEBUG
        fps = clock.get_fps()
        fps_text = f"FPS: {fps:.2f}"
        try:
            text_surface = debug_font.render(fps_text, True, config.DEBUG_TEXT_COLOR)
            surface.blit(text_surface, (10, 10)) # Position at top-left
            # print("DEBUG: display_fps - FPS text blitted") # DEBUG
        except Exception as e: 
            print(f"ERROR: Failed to render FPS text: {e}")
</file>

<file path="rendering/grid.py">
import pygame
from src.core import config
from pygame.math import Vector2

class Grid:
    """
    Represents the simulation grid, handling drawing and coordinate conversions.
    """
    def __init__(self):
        """Initializes the grid based on configuration."""
        self.screen_width = config.SCREEN_WIDTH
        self.screen_height = config.SCREEN_HEIGHT
        self.cell_size = config.GRID_CELL_SIZE # Assuming square cells for now
        self.cell_width = self.cell_size
        self.cell_height = self.cell_size
        self.grid_color = config.GRID_COLOR

        if self.cell_width <= 0 or self.cell_height <= 0:
            raise ValueError("GRID_CELL_SIZE must be positive.")

        self.width_in_cells = self.screen_width // self.cell_width
        self.height_in_cells = self.screen_height // self.cell_height

        print(f"Grid initialized: {self.width_in_cells}x{self.height_in_cells} cells of size {self.cell_size}x{self.cell_size}") # Debug

    def draw(self, surface: pygame.Surface):
        """Draws the grid lines on the given surface."""
        # Draw vertical lines
        for x in range(0, self.screen_width, self.cell_width):
            pygame.draw.line(surface, self.grid_color, (x, 0), (x, self.screen_height))

        # Draw horizontal lines
        for y in range(0, self.screen_height, self.cell_height):
            pygame.draw.line(surface, self.grid_color, (0, y), (self.screen_width, y))

    def grid_to_screen(self, grid_pos: Vector2) -> tuple[int, int]:
        """
        Converts grid coordinates (e.g., Vector2(5, 3)) to screen pixel coordinates
        (center of the cell).
        """
        screen_x = int(grid_pos.x * self.cell_width + self.cell_width / 2)
        screen_y = int(grid_pos.y * self.cell_height + self.cell_height / 2)
        return screen_x, screen_y

    def screen_to_grid(self, screen_pos: tuple[int, int]) -> Vector2:
        """
        Converts screen pixel coordinates to grid coordinates.
        """
        grid_x = screen_pos[0] // self.cell_width
        grid_y = screen_pos[1] // self.cell_height
        return Vector2(grid_x, grid_y)

    def is_within_bounds(self, grid_pos: Vector2) -> bool:
        """Checks if a grid position is within the valid grid cell range."""
        return 0 <= grid_pos.x < self.width_in_cells and 0 <= grid_pos.y < self.height_in_cells
</file>

<file path="resources/__init__.py">
# This file makes Python treat the `resources` directory as a package.
</file>

<file path="resources/berry_bush.py">
import pygame
from .node import ResourceNode
from src.core import config # Assuming config will have the necessary variables
from ..resources.resource_types import ResourceType # Import ResourceType

class BerryBush(ResourceNode):
    """
    Represents a Berry Bush resource node in the simulation.
    """
    def __init__(self, grid_position: pygame.Vector2): # Position is now grid_position
        """
        Initializes a BerryBush node.

        Args:
            grid_position: The grid coordinates of the bush (pygame.Vector2).
        """
        # Use configuration values for capacity and generation rate
        super().__init__(
            position=grid_position, # Store grid_position
            capacity=config.BERRY_BUSH_CAPACITY,
            generation_interval=config.BERRY_BUSH_GENERATION_INTERVAL,
            resource_type=ResourceType.BERRY
        )
        # Size of the bush representation (visual size on screen)
        self.display_size = config.GRID_CELL_SIZE # This is a pixel size for drawing
        # self.rect is now calculated in draw() as it depends on screen coordinates


    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Add grid parameter
        """
        Draws the berry bush (a square) and its current resource count.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering the resource count.
            grid: The game grid object for coordinate conversions.
        """
        # Convert grid position to screen position for drawing
        screen_pos = grid.grid_to_screen(self.position)

        # Calculate the rect for drawing based on screen position
        # self.position is grid coords, screen_pos is pixel coords (center of cell)
        draw_rect = pygame.Rect(
            screen_pos[0] - self.display_size / 2,
            screen_pos[1] - self.display_size / 2,
            self.display_size,
            self.display_size
        )

        # Draw the bush square
        pygame.draw.rect(surface, config.BERRY_BUSH_COLOR, draw_rect)

        # Draw the resource count text
        resource_text = f"{int(self.current_quantity)}"
        text_surface = font.render(resource_text, True, config.RESOURCE_TEXT_COLOR)
        # Center text on the screen position of the bush
        text_rect = text_surface.get_rect(center=screen_pos)
        surface.blit(text_surface, text_rect)

    # update method is inherited from ResourceNode
    # collect method is inherited from ResourceNode
</file>

<file path="resources/manager.py">
import pygame
from typing import List, TYPE_CHECKING, Optional
from .node import ResourceNode # Use relative import within the package
from .resource_types import ResourceType # For get_nodes_by_type
from .processing import ProcessingStation # For managing processing stations

# Forward reference for StoragePoint to avoid circular import if StoragePoint imports ResourceManager
if TYPE_CHECKING:
    from .storage_point import StoragePoint
    # ProcessingStation does not import ResourceManager, so forward ref not strictly needed here
    # but can be kept for consistency if desired.
    # from .processing import ProcessingStation

class ResourceManager:
    """
    Manages all resource nodes, storage points, and processing stations in the simulation.
    """
    def __init__(self):
        """
        Initializes the ResourceManager with empty lists for managed objects.
        """
        self.nodes: List[ResourceNode] = []
        self.storage_points: List['StoragePoint'] = []
        self.processing_stations: List[ProcessingStation] = []

    def add_node(self, node: ResourceNode):
        """
        Adds a resource node to the manager.

        Args:
            node: The ResourceNode instance to add.
        """
        if isinstance(node, ResourceNode):
            self.nodes.append(node)
        else:
            # Simple error handling, could be more robust (e.g., logging)
            print(f"Error: Attempted to add non-ResourceNode object to ResourceManager: {node}")

    def add_storage_point(self, storage_point: 'StoragePoint'):
        """
        Adds a storage point to the manager.

        Args:
            storage_point: The StoragePoint instance to add.
        """
        # Can add type checking if StoragePoint is directly imported
        # from .storage_point import StoragePoint
        # if isinstance(storage_point, StoragePoint):
        self.storage_points.append(storage_point)
        # else:
        #     print(f"Error: Attempted to add non-StoragePoint object to ResourceManager: {storage_point}")

    def add_processing_station(self, station: ProcessingStation):
        """
        Adds a processing station to the manager.

        Args:
            station: The ProcessingStation instance to add.
        """
        if isinstance(station, ProcessingStation):
            self.processing_stations.append(station)
        else:
            print(f"Error: Attempted to add non-ProcessingStation object to ResourceManager: {station}")

    def get_nodes_by_type(self, resource_type: ResourceType) -> List[ResourceNode]:
        """
        Returns a list of resource nodes of a specific type.
        """
        return [node for node in self.nodes if hasattr(node, 'resource_type') and node.resource_type == resource_type]

    def update_nodes(self, dt: float):
        """
        Updates all managed resource nodes and processing stations.

        Args:
            dt: The time elapsed since the last update in seconds (for ResourceNodes).
        """
        for node in self.nodes:
            node.update(dt)
        
        for station in self.processing_stations:
            station.tick() # Processing stations are updated per tick

    def draw_nodes(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Add grid parameter
        """
        Draws all managed resource nodes, storage points, and processing stations.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object for coordinate conversions (used by some draw methods).
        """
        for node in self.nodes:
            if hasattr(node, 'draw'):
                # All ResourceNode subclasses (including WheatField and BerryBush)
                # are now expected to have a draw(self, surface, font, grid) method.
                node.draw(surface, font, grid)

        for sp in self.storage_points:
            if hasattr(sp, 'draw'):
                # StoragePoint.draw is expected to take (surface, grid)
                sp.draw(surface, grid)
        
        for station in self.processing_stations:
            if hasattr(station, 'draw'):
                # ProcessingStation.draw takes (surface, font)
                station.draw(surface, font)

    def get_nearest_station_accepting(self, current_position: pygame.Vector2, resource_type: ResourceType) -> Optional[ProcessingStation]:
        """
        Finds the nearest processing station that accepts a given resource type and has input capacity.
        """
        available_stations = [
            s for s in self.processing_stations
            if s.can_accept_input(resource_type)
        ]

        if not available_stations:
            return None

        nearest_station = min(
            available_stations,
            key=lambda s: current_position.distance_squared_to(s.position)
        )
        return nearest_station

    def get_stations_with_output(self, resource_type: ResourceType) -> List[ProcessingStation]:
        """
        Returns a list of processing stations that have the specified processed resource type available.
        """
        return [
            s for s in self.processing_stations
            if s.produced_output_type == resource_type and s.has_output()
        ]
    def get_global_resource_quantity(self, resource_type: ResourceType) -> int:
        """
        Calculates the total quantity of a specific resource type across all storage points.

        Args:
            resource_type: The ResourceType to query.

        Returns:
            The total integer quantity of the specified resource.
        """
        total_quantity = 0
        for sp in self.storage_points:
            # The 'stored_resources' attribute in StoragePoint is a Dict[ResourceType, int]
            total_quantity += sp.stored_resources.get(resource_type, 0)
        return total_quantity
</file>

<file path="resources/mill.py">
import pygame
from .processing import ProcessingStation
from ..resources.resource_types import ResourceType
from ..core import config # For GRID_CELL_SIZE, colors etc.

class Mill(ProcessingStation):
    """
    A specific processing station that converts Wheat into Flour Powder.
    """
    MILL_COLOR_IDLE = (139, 69, 19)  # SaddleBrown
    MILL_COLOR_PROCESSING = (160, 82, 45) # Sienna

    def __init__(self, position: pygame.Vector2):
        """
        Initializes a Mill.

        Args:
            position: The position of the mill on the grid.
        """
        super().__init__(
            position=position,
            accepted_input_type=ResourceType.WHEAT,
            produced_output_type=ResourceType.FLOUR_POWDER,
            conversion_ratio=1.0,  # 1 Wheat -> 1 Flour Powder
            processing_speed=8,    # 8 simulation ticks per unit
            input_capacity=25,
            output_capacity=25
        )
        self.color = self.MILL_COLOR_IDLE
        self.processing_color = self.MILL_COLOR_PROCESSING

    # The draw method from ProcessingStation can be used directly if the
    # color and processing_color are set appropriately, as done above.
    # If a more distinct visual is needed, this draw method can be overridden.
    # For now, we rely on the base class draw method with custom colors.

    # def draw(self, surface: pygame.Surface, font: pygame.font.Font):
    #     """
    #     Draws the mill on the given surface.
    #     Overrides ProcessingStation.draw() for specific Mill visuals if needed.
    #     """
    #     # Call super().draw() or implement custom drawing
    #     # For now, let's ensure the colors are set correctly in __init__
    #     # and rely on the base class draw method.
    #     current_display_color = self.processing_color if self.is_processing else self.color
    #
    #     rect_x = self.position.x * config.GRID_CELL_SIZE
    #     rect_y = self.position.y * config.GRID_CELL_SIZE
    #     station_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)
    #
    #     pygame.draw.rect(surface, current_display_color, station_rect)
    #     pygame.draw.rect(surface, config.COLOR_BLACK, station_rect, 1) # Border
    #
    #     # You can call the base class's text drawing logic or reimplement
    #     super().draw_text_info(surface, font) # Assuming base class has such a helper or draw has it

    def __str__(self):
        return super().__str__() # Or customize if needed

    def __repr__(self):
        return f"Mill(position={self.position})"
</file>

<file path="resources/node.py">
import pygame
import uuid # For task and agent IDs
from typing import Optional # For Optional type hints
from abc import ABC, abstractmethod
from ..resources.resource_types import ResourceType # Import ResourceType

class ResourceNode(ABC):
    """
    Base class for resource nodes in the simulation.
    """
    def __init__(self, position: pygame.Vector2, capacity: int, generation_interval: float, resource_type: ResourceType):
        """
        Initializes a ResourceNode.

        Args:
            position: The position of the node on the grid (pygame.Vector2).
            capacity: The maximum amount of resources the node can hold (integer units).
            generation_interval: The interval at which resources are generated (in seconds).
            resource_type: The type of resource this node provides.
        """
        if not isinstance(position, pygame.Vector2):
            raise TypeError("Position must be a pygame.Vector2")
        self.position = position
        self.capacity = int(capacity) # Ensure capacity is integer
        self.generation_interval = generation_interval
        self.resource_type = resource_type # Added
        self.current_quantity = 0
        self._generation_timer = 0.0 
        
        # --- Attributes for task-based claiming ---
        self.claimed_by_task_id: Optional[uuid.UUID] = None
        self.claimed_by_agent_id: Optional[uuid.UUID] = None

    def update(self, dt: float):
        """
        Updates the resource node's state, generating resources over time.

        Args:
            dt: The time elapsed since the last update in seconds.
        """
        if self.current_quantity < self.capacity:
            self._generation_timer += dt
            resources_to_add = int(self._generation_timer / self.generation_interval)
            if resources_to_add > 0:
                self._generation_timer -= resources_to_add * self.generation_interval
                # Don't overfill
                resources_needed = self.capacity - self.current_quantity
                actual_to_add = min(resources_to_add, resources_needed)
                self.current_quantity += actual_to_add

    # --- Methods for task-based claiming ---
    def claim(self, agent_id: uuid.UUID, task_id: uuid.UUID) -> bool:
        """
        Attempts to claim this resource node for a specific task and agent.
        Returns True if successful (node was not already claimed), False otherwise.
        """
        if self.claimed_by_task_id is None:
            self.claimed_by_task_id = task_id
            self.claimed_by_agent_id = agent_id
            # print(f"DEBUG: Node {self.position} claimed by task {task_id} for agent {agent_id}.")
            return True
        # print(f"DEBUG: Node {self.position} FAILED to claim by task {task_id} (already claimed by task {self.claimed_by_task_id}).")
        return False

    def release(self, agent_id: uuid.UUID, task_id: uuid.UUID):
        """
        Releases the claim on this resource node if the provided task_id matches the current claim.
        """
        if self.claimed_by_task_id == task_id:
            # Optional: could also check agent_id for stricter release conditions
            # if self.claimed_by_agent_id == agent_id:
            self.claimed_by_task_id = None
            self.claimed_by_agent_id = None
            # print(f"DEBUG: Node {self.position} released by task {task_id} from agent {agent_id}.")
        # else:
            # print(f"DEBUG: Node {self.position} release called by task {task_id} but was claimed by {self.claimed_by_task_id} (or not claimed).")

    @abstractmethod
    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Added grid
        """
        Draws the resource node on the given surface.
        This method must be implemented by subclasses.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object, potentially for coordinate transformations or cell information.
        """
        pass

    def collect_resource(self, amount_to_collect: int) -> int:
        """
        Attempts to collect a specified integer amount of resources from the node.

        Args:
            amount_to_collect: The integer amount of resources to attempt to collect.

        Returns:
            The actual integer amount of resources collected (can be less than requested).
        """
        
        collectable_amount = min(amount_to_collect, self.current_quantity)
        
        if collectable_amount > 0:
            self.current_quantity -= collectable_amount
            # Ensure resources don't go below zero (shouldn't happen with min logic)
            self.current_quantity = max(0.0, self.current_quantity)
            print(f"Node at {self.position} ({self.resource_type.name}) collected {collectable_amount}, remaining: {self.current_quantity:.2f}") # Debug
        return collectable_amount
</file>

<file path="resources/processing.py">
import pygame
from typing import Optional
from ..resources.resource_types import ResourceType
from ..core import config # For potential future use, e.g. visual configuration

class ProcessingStation:
    """
    Base class for resource processing stations (e.g., Mill, Bakery).
    Processes input resources into output resources over time.
    """
    def __init__(self,
                 position: pygame.Vector2,
                 accepted_input_type: ResourceType,
                 produced_output_type: ResourceType,
                 conversion_ratio: float, # e.g., 1.0 means 1 input makes 1 output
                 processing_speed: int,   # Ticks required to process one unit (or one batch based on conversion)
                 input_capacity: int,
                 output_capacity: int):
        """
        Initializes a ProcessingStation.

        Args:
            position: The position of the station on the grid.
            accepted_input_type: The type of resource this station accepts.
            produced_output_type: The type of resource this station produces.
            conversion_ratio: How many input units are needed for one output unit,
                              or how many output units are produced from one input unit.
                              For simplicity, let's assume 1 input unit produces X output units,
                              where X is conversion_ratio. Or 1 input -> 1 output if ratio is 1.0.
                              Let's refine: conversion_ratio = output_units / input_units.
                              If 1 WHEAT makes 1 FLOUR, ratio = 1.0.
                              If 2 WHEAT makes 1 FLOUR, ratio = 0.5 (meaning 1 input makes 0.5 output, effectively needing 2 inputs for 1 output).
                              Let's stick to: 1 input unit produces `conversion_ratio` output units.
                              The plan for Mill implies 1 WHEAT -> 1 FLOUR_POWDER, so ratio = 1.0.
            processing_speed: Number of simulation ticks required to complete one processing cycle.
            input_capacity: Maximum amount of input resources the station can hold.
            output_capacity: Maximum amount of output resources the station can hold.
        """
        if not isinstance(position, pygame.Vector2):
            raise TypeError("Position must be a pygame.Vector2")

        self.position = position
        self.accepted_input_type = accepted_input_type
        self.produced_output_type = produced_output_type
        self.conversion_ratio = float(conversion_ratio) # Ensure float
        self.processing_speed = int(processing_speed) # Ticks per processing cycle
        self.input_capacity = int(input_capacity)
        self.output_capacity = int(output_capacity)

        self.current_input_quantity = 0.0  # Can be float if partial inputs are allowed by agents
        self.current_output_quantity = 0.0 # Can be float
        self.is_processing = False
        self.processing_progress = 0  # Ticks accumulated towards current processing cycle

        # For drawing (subclasses should define specific colors/sprites)
        self.color = (100, 100, 100) # Default grey
        self.processing_color = (150, 150, 50) # Yellowish when processing

    def receive(self, resource_type: ResourceType, quantity: int) -> bool:
        """
        Adds input resources to the station if the type is accepted and there's capacity.
        Agents will typically deliver integer quantities.
        Returns True if resources were successfully added, False otherwise.
        """
        if resource_type == self.accepted_input_type and self.current_input_quantity < self.input_capacity:
            amount_to_add = min(float(quantity), self.input_capacity - self.current_input_quantity)
            if amount_to_add > 0:
                self.current_input_quantity += amount_to_add
                # print(f"{self} received {amount_to_add} of {resource_type.name}. Input: {self.current_input_quantity}") # Debug
                return True
        # print(f"{self} FAILED to receive {quantity} of {resource_type.name}. Input: {self.current_input_quantity}, Capacity: {self.input_capacity}, Accepted: {self.accepted_input_type.name}") # Debug
        return False

    def tick(self):
        """
        Handles the processing logic per simulation tick.
        One processing cycle consumes 1 unit of input and produces `conversion_ratio` units of output.
        """
        if self.current_input_quantity >= 1.0 and self.current_output_quantity < self.output_capacity:
            self.is_processing = True
            self.processing_progress += 1
            if self.processing_progress >= self.processing_speed:
                # One processing cycle complete
                self.current_input_quantity -= 1.0 # Consume one unit of input
                
                produced_amount = 1.0 * self.conversion_ratio
                
                # Ensure we don't overflow output capacity
                actual_produced_amount = min(produced_amount, self.output_capacity - self.current_output_quantity)
                
                self.current_output_quantity += actual_produced_amount
                
                self.processing_progress = 0 # Reset for next cycle
                
                # If we couldn't produce the full amount due to output capacity,
                # the input was still consumed. This implies a need for agents to clear output.
                # print(f"{self} processed. Input: {self.current_input_quantity}, Output: {self.current_output_quantity}") # Debug

                if self.current_input_quantity < 1.0 or self.current_output_quantity >= self.output_capacity:
                    self.is_processing = False # Stop if no more input or output full
        else:
            self.is_processing = False
            self.processing_progress = 0 # Reset if not enough input or output is full

    def dispense(self, requested_quantity: int) -> int:
        """
        Allows an agent to collect processed output resources.
        Returns the actual integer amount of resources dispensed.
        """
        available_integer_output = int(self.current_output_quantity)
        amount_to_dispense = min(requested_quantity, available_integer_output)

        if amount_to_dispense > 0:
            self.current_output_quantity -= float(amount_to_dispense)
            # print(f"{self} dispensed {amount_to_dispense} of {self.produced_output_type.name}. Output: {self.current_output_quantity}") # Debug
            return amount_to_dispense
        return 0

    def can_accept_input(self, resource_type: ResourceType, quantity: int = 1) -> bool:
        """Checks if the station can accept the given resource type and has space for at least the quantity."""
        return resource_type == self.accepted_input_type and (self.current_input_quantity + quantity) <= self.input_capacity

    def has_output(self) -> bool:
        """Checks if there are any processed goods (at least 1 full unit) to collect."""
        return self.current_output_quantity >= 1.0

    def get_visual_state(self) -> str:
        """Returns 'idle' or 'processing' for visualization purposes."""
        return "processing" if self.is_processing else "idle"

    def draw(self, surface: pygame.Surface, font: pygame.font.Font):
        """
        Draws the processing station on the given surface.
        Subclasses should override for specific visuals.
        """
        rect_x = self.position.x * config.GRID_CELL_SIZE
        rect_y = self.position.y * config.GRID_CELL_SIZE
        station_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)

        current_color = self.processing_color if self.is_processing else self.color
        pygame.draw.rect(surface, current_color, station_rect)
        pygame.draw.rect(surface, config.COLOR_BLACK, station_rect, 1) # Border

        # Display input: "I:type qty/cap"
        input_text_str = f"I:{self.accepted_input_type.name[0]}:{int(self.current_input_quantity)}/{self.input_capacity}"
        input_surface = font.render(input_text_str, True, config.DEBUG_TEXT_COLOR)
        input_rect = input_surface.get_rect(midtop=station_rect.midtop)
        input_rect.y += 2 # Small offset
        surface.blit(input_surface, input_rect)
        
        # Display output: "O:type qty/cap"
        output_text_str = f"O:{self.produced_output_type.name[0]}:{int(self.current_output_quantity)}/{self.output_capacity}"
        output_surface = font.render(output_text_str, True, config.DEBUG_TEXT_COLOR)
        output_rect = output_surface.get_rect(midbottom=station_rect.midbottom)
        output_rect.y -= 2 # Small offset
        surface.blit(output_surface, output_rect)

        if self.is_processing:
            progress_text_str = f"{self.processing_progress}/{self.processing_speed}"
            progress_surface = font.render(progress_text_str, True, config.DEBUG_TEXT_COLOR)
            progress_rect = progress_surface.get_rect(center=station_rect.center)
            surface.blit(progress_surface, progress_rect)


    def __str__(self):
        return (f"{self.__class__.__name__} at {self.position} "
                f"[{self.accepted_input_type.name} -> {self.produced_output_type.name}] "
                f"Input: {self.current_input_quantity:.1f}/{self.input_capacity}, "
                f"Output: {self.current_output_quantity:.1f}/{self.output_capacity}, "
                f"State: {self.get_visual_state()} ({self.processing_progress}/{self.processing_speed})")

    def __repr__(self):
        return (f"{self.__class__.__name__}(position={self.position}, "
                f"input_type={self.accepted_input_type.name}, output_type={self.produced_output_type.name})")
</file>

<file path="resources/resource_types.py">
from enum import Enum, auto

class ResourceType(Enum):
    """Defines the types of resources available in the simulation."""
    BERRY = auto()
    WHEAT = auto()
    FLOUR_POWDER = auto()
    # Future resource types can be added here
</file>

<file path="resources/storage_point.py">
import pygame
import uuid # Added for task_id in reservations
from typing import List, Dict, Optional

# Assuming ResourceType is defined in resource_types.py
from .resource_types import ResourceType

class StoragePoint:
    """Represents a location where agents can drop off collected resources, with reservation capabilities."""

    def __init__(self,
                 position: pygame.math.Vector2,
                 overall_capacity: int,
                 accepted_resource_types: Optional[List[ResourceType]] = None):
        """
        Initializes a StoragePoint.

        Args:
            position (pygame.math.Vector2): The grid coordinates of the storage point.
            overall_capacity (int): The maximum total quantity of all resources this point can hold.
            accepted_resource_types (Optional[List[ResourceType]]): A list of resource types
                                     this storage point accepts. If None, accepts all types.
        """
        self.position = position
        self.overall_capacity = overall_capacity
        self.accepted_resource_types = accepted_resource_types
        self.stored_resources: Dict[ResourceType, int] = {}
        self.reservations: Dict[uuid.UUID, int] = {} # task_id -> reserved_quantity

    def get_current_load(self) -> int:
        """Returns the total quantity of all resources currently physically stored."""
        return sum(self.stored_resources.values())

    def get_total_reserved_quantity(self) -> int:
        """Returns the total quantity of all resources currently reserved."""
        return sum(self.reservations.values())

    def get_available_capacity_for_reservation(self) -> int:
        """Calculates space available for new reservations."""
        return self.overall_capacity - self.get_current_load() - self.get_total_reserved_quantity()

    def can_accept(self, resource_type: ResourceType, quantity: int, for_reservation: bool = False) -> bool:
        """
        Checks if the storage point can accept a given quantity of a resource type.
        If for_reservation is True, checks against capacity available for new reservations.
        Otherwise, checks against overall capacity minus existing reservations (for direct non-task additions).
        """
        if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
            return False
        
        if for_reservation:
            if quantity > self.get_available_capacity_for_reservation():
                return False
        else: # Checking for a direct, non-reserved addition
            # A direct addition must fit into space not physically filled and not already reserved by others.
            if self.get_current_load() + quantity > self.overall_capacity - self.get_total_reserved_quantity():
                return False
        return True

    def reserve_space(self, task_id: uuid.UUID, resource_type: ResourceType, quantity: int) -> int:
        """
        Attempts to reserve space for a given task.

        Args:
            task_id (uuid.UUID): The ID of the task making the reservation.
            resource_type (ResourceType): The type of resource to reserve space for.
            quantity (int): The amount of space to reserve.

        Returns:
            int: The actual quantity of space reserved. Can be less than requested if
                 not enough space is available or 0 if type not accepted or no space.
        """
        if task_id in self.reservations: # Task already has a reservation, should modify or release first
            print(f"Warning: Task {task_id} attempting to reserve space again. Current reservation: {self.reservations[task_id]}")
            # Potentially allow modification, but for now, let's assume new reservation means prior one should be handled.
            # Or, this could be an addition to an existing reservation. For simplicity, let's make it overwrite/add.
            # self.reservations[task_id] += quantity_to_reserve ... (this needs careful thought)
            # For now, let's assume a task makes one reservation request that should be sufficient.
            # If a task needs to change its reservation, it should release and re-reserve.
            # This simplifies logic. If this call happens, it's likely an error in task logic or a new reservation.
            # Let's assume it's a new reservation attempt.
            pass # Allow re-evaluation if needed.

        if not self.can_accept(resource_type, quantity, for_reservation=True):
            # Try to reserve as much as possible
            available_for_res = self.get_available_capacity_for_reservation()
            if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
                 return 0 # Cannot accept this type at all
            
            quantity_to_reserve = min(quantity, available_for_res)
            if quantity_to_reserve <= 0:
                return 0
        else:
            quantity_to_reserve = quantity
        
        # Add to existing reservation for the task or create a new one
        self.reservations[task_id] = self.reservations.get(task_id, 0) + quantity_to_reserve
        print(f"Storage at {self.position} reserved {quantity_to_reserve} for task {task_id}. Total reserved: {self.get_total_reserved_quantity()}")
        return quantity_to_reserve

    def release_reservation(self, task_id: uuid.UUID, quantity_to_release: Optional[int] = None) -> bool:
        """
        Releases a reservation made by a task.

        Args:
            task_id (uuid.UUID): The ID of the task whose reservation is to be released.
            quantity_to_release (Optional[int]): The amount of reservation to release.
                                                 If None, releases the entire reservation for the task.

        Returns:
            bool: True if the reservation was found and released/reduced, False otherwise.
        """
        if task_id not in self.reservations:
            return False
        
        if quantity_to_release is None or quantity_to_release >= self.reservations[task_id]:
            released_amount = self.reservations.pop(task_id)
            print(f"Storage at {self.position} fully released reservation of {released_amount} for task {task_id}.")
        else:
            self.reservations[task_id] -= quantity_to_release
            print(f"Storage at {self.position} reduced reservation by {quantity_to_release} for task {task_id}. Remaining: {self.reservations[task_id]}")
        return True

    def commit_reservation_to_storage(self, task_id: uuid.UUID, resource_type: ResourceType, quantity_to_add: int) -> int:
        """
        Commits a previously reserved quantity of a resource to actual storage.
        This will decrease the reservation and increase stored_resources.

        Args:
            task_id (uuid.UUID): The task ID that holds the reservation.
            resource_type (ResourceType): The type of resource being added.
            quantity_to_add (int): The quantity to add from the reservation.

        Returns:
            int: The actual quantity added to storage.
        """
        if task_id not in self.reservations:
            print(f"Error: Task {task_id} has no reservation at {self.position} to commit.")
            return 0 # No reservation for this task

        reserved_for_task = self.reservations[task_id]
        if quantity_to_add > reserved_for_task:
            print(f"Warning: Task {task_id} trying to commit {quantity_to_add} but only {reserved_for_task} reserved. Committing max reserved.")
            quantity_to_add = reserved_for_task # Cannot add more than reserved by this task

        # Actual addition to storage - this uses the existing add_resource logic but bypasses some checks
        # as the space was already accounted for by the reservation.
        # However, add_resource itself checks overall_capacity.
        # We need a way to ensure this addition is "safe" because it was reserved.

        # Simplified: directly add to stored_resources and adjust reservation
        # Check if type is accepted (should have been checked at reservation time too)
        if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
            print(f"Error: Task {task_id} trying to commit unaccepted type {resource_type.name} at {self.position}.")
            return 0 # Should not happen if reservation was done correctly

        # Check if physical space is available (current_load + quantity_to_add <= overall_capacity)
        # This check is vital because reservations are conceptual; physical space is paramount.
        if self.get_current_load() + quantity_to_add > self.overall_capacity:
            # This indicates a problem: reservation allowed more than physical capacity.
            # Or, other non-reserved items filled up space.
            # For now, only add what physically fits.
            can_physically_add = self.overall_capacity - self.get_current_load()
            if quantity_to_add > can_physically_add:
                 print(f"Critical Warning: Task {task_id} at {self.position}: Physical space ({can_physically_add}) less than committed quantity ({quantity_to_add}) from reservation. Data integrity issue or race condition?")
                 quantity_to_add = can_physically_add
            
            if quantity_to_add <= 0:
                return 0


        if quantity_to_add > 0:
            current_amount = self.stored_resources.get(resource_type, 0)
            self.stored_resources[resource_type] = current_amount + quantity_to_add
            
            # Reduce or remove reservation
            if quantity_to_add >= reserved_for_task:
                self.reservations.pop(task_id)
            else:
                self.reservations[task_id] -= quantity_to_add
            
            print(f"Storage at {self.position} committed {quantity_to_add} of {resource_type.name} from task {task_id}. Stored: {self.stored_resources.get(resource_type, 0)}, Remaining Res for task: {self.reservations.get(task_id, 0)}")
            return quantity_to_add
        return 0


    def add_resource(self, resource_type: ResourceType, quantity: int) -> int:
        """
        Adds a quantity of a specific resource type to the storage.
        This is for direct additions, not via reservations.
        It must respect space not already reserved by other tasks.

        Args:
            resource_type (ResourceType): The type of resource to add.
            quantity (int): The amount of resource to add.

        Returns:
            int: The actual quantity of the resource added (might be less than requested
                 if capacity is exceeded or type not accepted).
        """
        # Use the modified can_accept for non-reservation additions
        if not self.can_accept(resource_type, quantity, for_reservation=False):
            if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
                return 0

            # Calculate available capacity considering other reservations
            available_for_direct_add = self.overall_capacity - self.get_current_load() - self.get_total_reserved_quantity()
            quantity_to_add = min(quantity, available_for_direct_add)

            if quantity_to_add <= 0:
                return 0
        else:
            quantity_to_add = quantity
        
        if quantity_to_add > 0:
            current_amount = self.stored_resources.get(resource_type, 0)
            self.stored_resources[resource_type] = current_amount + quantity_to_add
            print(f"Storage at {self.position} (direct add) received {quantity_to_add} of {resource_type.name}. Total stored: {self.stored_resources.get(resource_type, 0)}")
        return quantity_to_add

    def draw(self, screen: pygame.Surface, grid):
        """Draws the storage point on the screen."""
        screen_pos = grid.grid_to_screen(self.position)
        color = (128, 128, 128) # Grey for storage
        radius = grid.cell_width // 2
        pygame.draw.rect(screen, color, (screen_pos[0] - radius, screen_pos[1] - radius, grid.cell_width, grid.cell_height))
        # Optionally, draw stored resource counts or indicators
</file>

<file path="resources/wheat_field.py">
import pygame
from .node import ResourceNode
from ..resources.resource_types import ResourceType
from ..core import config

class WheatField(ResourceNode):
    """
    A resource node that generates Wheat.
    """

    def __init__(self, position: pygame.Vector2):
        """
        Initializes a WheatField.

        Args:
            position: The position of the field on the grid (pygame.Vector2).
        """

        super().__init__(
            position=position,
            capacity=config.WHEAT_FIELD_CAPACITY, 
            generation_interval=config.WHEAT_GENERATION_INTERVAL,
            resource_type=ResourceType.WHEAT
        )
        self.color = config.RESOURCE_VISUAL_COLORS.get(self.resource_type, (255, 255, 0)) # Default yellow if not in config

    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Added grid parameter
        """
        Draws the wheat field on the given surface.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object (unused in this implementation but part of the required signature).
        """
        # The 'grid' parameter is not used here as drawing is based on
        # self.position and config.GRID_CELL_SIZE.
        rect_x = self.position.x * config.GRID_CELL_SIZE
        rect_y = self.position.y * config.GRID_CELL_SIZE
        node_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)

        pygame.draw.rect(surface, self.color, node_rect)

        # Draw resource count
        resource_text = f"{int(self.current_quantity)}"
        text_surface = font.render(resource_text, True, config.RESOURCE_TEXT_COLOR)
        text_rect = text_surface.get_rect(center=node_rect.center)
        surface.blit(text_surface, text_rect)

    def __str__(self):
        return f"WheatField at {self.position} ({self.current_quantity:.1f}/{self.capacity} {self.resource_type.name})"

    def __repr__(self):
        return f"WheatField(position={self.position})"
</file>

<file path="tasks/task_manager.py">
import uuid
import time
from typing import List, Dict, Optional, TYPE_CHECKING

from .task import Task, GatherAndDeliverTask # Assuming task.py is in the same directory
from .task_types import TaskType, TaskStatus
from ..resources.resource_types import ResourceType # Assuming this path
from ..core import config # For task generation settings

# Forward references to avoid circular imports
if TYPE_CHECKING:
    from ..agents.agent import Agent
    from ..agents.manager import AgentManager
    from ..resources.manager import ResourceManager

class TaskManager:
    """Manages the creation, assignment, and tracking of tasks for agents."""

    def __init__(self, resource_manager: 'ResourceManager', agent_manager: 'AgentManager'):
        self.pending_tasks: List[Task] = []
        self.assigned_tasks: Dict[uuid.UUID, Task] = {} # agent_id -> Task
        self.completed_tasks: List[Task] = [] # For history/metrics
        self.failed_tasks: List[Task] = []     # For analysis/retry
        
        self.resource_manager_ref: 'ResourceManager' = resource_manager
        self.agent_manager_ref: 'AgentManager' = agent_manager
        
        self._next_task_check_time: float = time.time()
        self._task_generation_interval: float = 5.0 # How often to check for new task generation

    def add_task(self, task: Task):
        """Adds a pre-created task to the pending list, sorted by priority."""
        # Higher priority number means more important
        self.pending_tasks.append(task)
        self.pending_tasks.sort(key=lambda t: t.priority, reverse=True)
        print(f"TaskManager: Added new task {task.task_id} ({task.task_type.name}) with priority {task.priority}. Pending: {len(self.pending_tasks)}")

    def create_gather_task(self,
                           resource_type: ResourceType,
                           quantity: int,
                           priority: int,
                           target_dropoff_id: Optional[uuid.UUID] = None, # Optional: specific dropoff
                           target_resource_node_id: Optional[uuid.UUID] = None # Optional: specific node
                           ) -> Optional[Task]:
        """
        Creates a new GatherAndDeliverTask and adds it to the pending list.
        The actual finding of suitable nodes/dropoffs if not specified will occur in Task.prepare().
        """
        # Basic validation: Ensure resource manager can find nodes/dropoffs for this type
        # This is a pre-check; Task.prepare() does the actual claiming/reservation.
        # For now, we assume the task can be created and prepare() will validate further.
        
        task = GatherAndDeliverTask(
            priority=priority,
            resource_type_to_gather=resource_type,
            quantity_to_gather=quantity,
            target_resource_node_id=target_resource_node_id,
            target_dropoff_id=target_dropoff_id
        )
        self.add_task(task)
        return task

    def request_task_for_agent(self, agent: 'Agent') -> Optional[Task]:
        """
        Assigns the highest priority available task to the given agent if one exists.
        Called by an agent when it becomes IDLE.
        """
        if not self.pending_tasks:
            return None

        # Get the highest priority task
        # TODO: Add more sophisticated matching (e.g., agent skills, proximity, current inventory)
        task_to_assign = self.pending_tasks.pop(0) # Highest priority due to sort
        
        task_to_assign.agent_id = agent.id
        task_to_assign.status = TaskStatus.ASSIGNED # Mark as assigned before prepare
        self.assigned_tasks[agent.id] = task_to_assign
        
        print(f"TaskManager: Assigning task {task_to_assign.task_id} ({task_to_assign.task_type.name}) to agent {agent.id}. Assigned: {len(self.assigned_tasks)}")
        return task_to_assign

    def report_task_outcome(self, task: Task, final_status: TaskStatus, agent: 'Agent'):
        """
        Called by an Agent when its current task is finished (completed, failed, or cancelled).
        """
        task.status = final_status # Ensure final status is set on the task object
        task.last_update_time = time.time()

        if agent.id in self.assigned_tasks and self.assigned_tasks[agent.id].task_id == task.task_id:
            del self.assigned_tasks[agent.id]
        else:
            print(f"Warning: TaskManager received outcome for task {task.task_id} from agent {agent.id}, but it was not in assigned_tasks or mismatch.")

        if final_status == TaskStatus.COMPLETED:
            self.completed_tasks.append(task)
            print(f"TaskManager: Task {task.task_id} COMPLETED by agent {agent.id}. Completed: {len(self.completed_tasks)}")
        elif final_status == TaskStatus.FAILED:
            self.failed_tasks.append(task)
            print(f"TaskManager: Task {task.task_id} FAILED for agent {agent.id}. Reason: {task.error_message}. Failed: {len(self.failed_tasks)}")
            # TODO: Potential re-queueing or modification logic for failed tasks
        elif final_status == TaskStatus.CANCELLED:
            # If cancelled, it might just be removed or put in a separate list
            print(f"TaskManager: Task {task.task_id} CANCELLED for agent {agent.id}. Failed: {len(self.failed_tasks)}")
            # For now, treat like failed for tracking, or add a cancelled_tasks list.
            self.failed_tasks.append(task) 


    def update(self, dt: float):
        """
        Periodic update for the TaskManager.
        - Can generate new tasks based on simulation state (e.g., low resources).
        - Can re-prioritize tasks.
        - Can check for timed-out tasks.
        """
        current_time = time.time()
        if current_time >= self._next_task_check_time:
            self._generate_tasks_if_needed()
            self._next_task_check_time = current_time + self._task_generation_interval

        # TODO: Check for tasks that are assigned but stuck (e.g., agent died, task timed out)
        # This would involve iterating self.assigned_tasks and checking task.last_update_time

    def _generate_tasks_if_needed(self):
        """
        Generates tasks based on simulation state, e.g., low resource stock.
        Currently implements logic for Berry stock.
        """
        # --- Berry Task Generation ---
        current_berry_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.BERRY)
        
        # print(f"DEBUG TaskManager: Current global berry stock: {current_berry_stock}, Min Level: {config.MIN_BERRY_STOCK_LEVEL}") # Debug

        if current_berry_stock < config.MIN_BERRY_STOCK_LEVEL:
            # Count existing GATHER_AND_DELIVER tasks for BERRY (pending or assigned)
            active_berry_gather_tasks = sum(
                1 for task in self.pending_tasks
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.BERRY
            )
            active_berry_gather_tasks += sum(
                1 for task in self.assigned_tasks.values()
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.BERRY
            )

            # print(f"DEBUG TaskManager: Active berry gather tasks: {active_berry_gather_tasks}, Max Allowed: {config.MAX_ACTIVE_BERRY_GATHER_TASKS}") # Debug

            if active_berry_gather_tasks < config.MAX_ACTIVE_BERRY_GATHER_TASKS:
                print(f"TaskManager: Low Berry Stock ({current_berry_stock} < {config.MIN_BERRY_STOCK_LEVEL}). Generating new GatherAndDeliverTask for BERRY.")
                self.create_gather_task(
                    resource_type=ResourceType.BERRY,
                    quantity=config.BERRY_GATHER_TASK_QUANTITY,
                    priority=config.BERRY_GATHER_TASK_PRIORITY
                )
            # else:
                # print(f"DEBUG TaskManager: Berry stock low, but max active berry tasks ({config.MAX_ACTIVE_BERRY_GATHER_TASKS}) reached.") # Debug
        # else:
            # print(f"DEBUG TaskManager: Berry stock ({current_berry_stock}) is sufficient. No new berry task needed.") # Debug

# --- Wheat Task Generation ---
        current_wheat_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.WHEAT)
        
        # print(f"DEBUG TaskManager: Current global wheat stock: {current_wheat_stock}, Min Level: {config.MIN_WHEAT_STOCK_LEVEL}") # Debug

        if current_wheat_stock < config.MIN_WHEAT_STOCK_LEVEL:
            active_wheat_gather_tasks = sum(
                1 for task in self.pending_tasks
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.WHEAT
            )
            active_wheat_gather_tasks += sum(
                1 for task in self.assigned_tasks.values()
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.WHEAT
            )

            # print(f"DEBUG TaskManager: Active wheat gather tasks: {active_wheat_gather_tasks}, Max Allowed: {config.MAX_ACTIVE_WHEAT_GATHER_TASKS}") # Debug

            if active_wheat_gather_tasks < config.MAX_ACTIVE_WHEAT_GATHER_TASKS:
                print(f"TaskManager: Low Wheat Stock ({current_wheat_stock} < {config.MIN_WHEAT_STOCK_LEVEL}). Generating new GatherAndDeliverTask for WHEAT.")
                self.create_gather_task(
                    resource_type=ResourceType.WHEAT,
                    quantity=config.WHEAT_GATHER_TASK_QUANTITY,
                    priority=config.WHEAT_GATHER_TASK_PRIORITY
                )
            # else:
                # print(f"DEBUG TaskManager: Wheat stock low, but max active wheat tasks ({config.MAX_ACTIVE_WHEAT_GATHER_TASKS}) reached.") # Debug
        # else:
            # print(f"DEBUG TaskManager: Wheat stock ({current_wheat_stock}) is sufficient. No new wheat task needed.") # Debug
        # TODO: Future: Add logic for other resource types here, following a similar pattern.
        # Example: Check Wheat storage and create tasks if low (conceptual)
        # current_wheat_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.WHEAT)
        # if current_wheat_stock < getattr(config, 'MIN_WHEAT_STOCK_LEVEL', 0): # Assuming MIN_WHEAT_STOCK_LEVEL in config
        #     # ... similar logic to create wheat gathering tasks ...
        #     pass


    def get_task_by_id(self, task_id: uuid.UUID) -> Optional[Task]:
        """Retrieves a task by its ID from any of the lists."""
        for task_list in [self.pending_tasks, list(self.assigned_tasks.values()), self.completed_tasks, self.failed_tasks]:
            for task in task_list:
                if task.task_id == task_id:
                    return task
        return None

    def get_all_tasks_count(self) -> Dict[str, int]:
        return {
            "pending": len(self.pending_tasks),
            "assigned": len(self.assigned_tasks),
            "completed": len(self.completed_tasks),
            "failed": len(self.failed_tasks)
        }
</file>

<file path="tasks/task_types.py">
from enum import Enum, auto

class TaskType(Enum):
    """Defines the types of tasks an agent can perform."""
    GATHER_AND_DELIVER = auto()
    PROCESS_RESOURCE = auto() # Example for future expansion
    COLLECT_PROCESSED_AND_DELIVER = auto() # Example for future expansion
    # Add other task types as needed

class TaskStatus(Enum):
    """Defines the possible states of a task."""
    PENDING = auto()    # Task is created but not yet assigned or prepared
    ASSIGNED = auto()   # Task is assigned to an agent, but not yet prepared
    PREPARING = auto()  # Task is actively trying to claim resources/reserve space
    # IN_PROGRESS states indicate the agent is actively working on a phase of the task
    IN_PROGRESS_MOVE_TO_RESOURCE = auto()
    IN_PROGRESS_GATHERING = auto()
    IN_PROGRESS_MOVE_TO_DROPOFF = auto()
    IN_PROGRESS_DELIVERING = auto()
    # Add other IN_PROGRESS states for more complex tasks (e.g., IN_PROGRESS_PROCESSING)
    COMPLETED = auto()  # Task was successfully finished
    FAILED = auto()     # Task could not be completed
    CANCELLED = auto()  # Task was cancelled before completion
</file>

<file path="tasks/task.py">
import uuid
import time
from abc import ABC, abstractmethod
from typing import Optional, TYPE_CHECKING

from .task_types import TaskType, TaskStatus
from ..resources.resource_types import ResourceType # Assuming this path is correct

# Forward references to avoid circular imports
if TYPE_CHECKING:
    from ..agents.agent import Agent # Assuming agent.py is in src/agents/
    from ..resources.manager import ResourceManager # Assuming manager.py is in src/resources/
    from ..resources.node import ResourceNode
    from ..resources.storage_point import StoragePoint
    # Add ..resources.processing.ProcessingStation if needed for other task types

class Task(ABC):
    """Base class for all tasks an agent can perform."""

    def __init__(self, task_type: TaskType, priority: int):
        self.task_id: uuid.UUID = uuid.uuid4()
        self.task_type: TaskType = task_type
        self.status: TaskStatus = TaskStatus.PENDING
        self.priority: int = priority
        self.agent_id: Optional[uuid.UUID] = None # Will be set when an agent is assigned
        self.creation_time: float = time.time()
        self.last_update_time: float = self.creation_time
        self.error_message: Optional[str] = None

    @abstractmethod
    def prepare(self, agent: 'Agent', resource_manager: 'ResourceManager') -> bool:
        """
        Handles initial claims, reservations, and any other setup required before
        the task can be executed.
        Sets the task status to PREPARING during its execution.
        Returns True if preparation was successful and the task can proceed, False otherwise.
        If successful, should set the task's status to an appropriate IN_PROGRESS state
        and potentially the agent's initial state.
        """
        pass

    @abstractmethod
    def execute_step(self, agent: 'Agent', dt: float, resource_manager: 'ResourceManager') -> TaskStatus:
        """
        Advances the task logic by one step or time delta.
        This method is called repeatedly by the assigned agent.
        It should update the task's status and return it.
        The task itself is responsible for changing the agent's state (e.g., agent.state = AgentState.MOVING_TO_RESOURCE).
        """
        pass

    @abstractmethod
    def cleanup(self, agent: 'Agent', resource_manager: 'ResourceManager', success: bool):
        """
        Called when the task is completed, failed, or cancelled.
        Releases any claims or reservations held by this task.
        Notifies the TaskManager of the outcome.
        """
        pass

    @abstractmethod
    def get_target_description(self) -> str:
        """Returns a string description of the current target or goal of the task for debugging/UI."""
        pass

    def _update_timestamp(self):
        self.last_update_time = time.time()


class GatherAndDeliverTask(Task):
    """A task for an agent to gather a specific resource and deliver it to a dropoff point."""

    def __init__(self,
                 priority: int,
                 resource_type_to_gather: ResourceType,
                 quantity_to_gather: int,
                 target_resource_node_id: Optional[uuid.UUID] = None, # Can be pre-assigned or found in prepare
                 target_dropoff_id: Optional[uuid.UUID] = None): # Can be pre-assigned or found in prepare
        super().__init__(TaskType.GATHER_AND_DELIVER, priority)
        self.resource_type_to_gather: ResourceType = resource_type_to_gather
        self.quantity_to_gather: int = quantity_to_gather # Target amount for this task instance
        
        # These will be populated during prepare() or if pre-assigned
        self.target_resource_node_ref: Optional['ResourceNode'] = None
        self.target_dropoff_ref: Optional['StoragePoint'] = None # Or ProcessingStation

        self.quantity_gathered: int = 0
        self.quantity_delivered: int = 0
        
        self.reserved_at_node: bool = False # More specific: store task_id in node
        self.reserved_at_dropoff_quantity: int = 0
        
        # Internal state machine for the task's progression
        # This could map to more detailed TaskStatus enum values or AgentState values
        self._current_step_key: str = "find_resource_and_dropoff" # Initial step

    def prepare(self, agent: 'Agent', resource_manager: 'ResourceManager') -> bool:
        from ..agents.agent import AgentState # Import here to use AgentState enum
        self._update_timestamp()
        self.status = TaskStatus.PREPARING
        agent.target_position = None # Clear previous agent target

        # 1. Find and Claim Resource Node
        if not self.target_resource_node_ref:
            # Simplified finding logic for now. TaskManager might do this or provide candidates.
            # Agent's current position: agent.position
            # ResourceManager: resource_manager.get_nodes_by_type(self.resource_type_to_gather)
            # TODO: Implement more sophisticated node finding (nearest, available, etc.)
            # For now, assume resource_manager can provide a suitable node or this task was created with one.
            # This part needs robust implementation based on how TaskManager generates tasks.
            
            # Placeholder: Find the first available node of the correct type
            candidate_nodes = resource_manager.get_nodes_by_type(self.resource_type_to_gather)
            for node in sorted(candidate_nodes, key=lambda n: (n.position - agent.position).length_squared()):
                if node.current_quantity >= 1 and node.claim(agent.id, self.task_id): # Using new claim
                    self.target_resource_node_ref = node
                    self.reserved_at_node = True # Or check node.claimed_by_task_id
                    break
            
        if not self.target_resource_node_ref:
            self.error_message = f"Could not find or claim resource node for {self.resource_type_to_gather.name}."
            self.status = TaskStatus.FAILED
            return False

        # 2. Find and Reserve Space at Dropoff
        if not self.target_dropoff_ref:
            # Simplified finding logic.
            # TODO: Implement sophisticated dropoff finding (accepts type, has space, nearest)
            # For now, assume resource_manager can provide a suitable storage point.
            # This part needs robust implementation.
            
            # Placeholder: Find the first storage point that can accept the resource
            # This should ideally consider the quantity we intend to gather.
            # The quantity to reserve should be min(self.quantity_to_gather, agent.inventory_capacity)
            qty_to_reserve_for_delivery = min(self.quantity_to_gather, agent.inventory_capacity)
            qty_to_reserve_for_delivery = min(self.target_resource_node_ref.current_quantity, qty_to_reserve_for_delivery) # Don't reserve more than available

            all_storage_points = resource_manager.storage_points # Assuming direct access
            for sp in sorted(all_storage_points, key=lambda s: (s.position - agent.position).length_squared()):
                # reserve_space should check accepted types and available capacity
                reserved_amount = sp.reserve_space(self.task_id, self.resource_type_to_gather, qty_to_reserve_for_delivery)
                if reserved_amount > 0:
                    self.target_dropoff_ref = sp
                    self.reserved_at_dropoff_quantity = reserved_amount
                    break
        
        if not self.target_dropoff_ref or self.reserved_at_dropoff_quantity == 0:
            self.error_message = f"Could not find or reserve space at dropoff for {self.resource_type_to_gather.name} (wanted to reserve {qty_to_reserve_for_delivery})."
            # Release claimed node if dropoff reservation fails
            if self.target_resource_node_ref and self.reserved_at_node:
                self.target_resource_node_ref.release(agent.id, self.task_id)
                self.reserved_at_node = False
            self.status = TaskStatus.FAILED
            return False

        # If all preparations are successful:
        self.status = TaskStatus.IN_PROGRESS_MOVE_TO_RESOURCE # First active step
        self._current_step_key = "move_to_resource"
        agent.state = AgentState.MOVING_TO_RESOURCE # Set agent's state
        agent.target_position = self.target_resource_node_ref.position
        print(f"Task {self.task_id} PREPARED for agent {agent.id}. Target Node: {self.target_resource_node_ref.position}, Target Dropoff: {self.target_dropoff_ref.position}, Reserved Dropoff Qty: {self.reserved_at_dropoff_quantity}")
        return True

    def execute_step(self, agent: 'Agent', dt: float, resource_manager: 'ResourceManager') -> TaskStatus:
        self._update_timestamp()
        from ..agents.agent import AgentState # Import here to use AgentState enum

        if not self.target_resource_node_ref or not self.target_dropoff_ref:
            self.error_message = "Target resource or dropoff became invalid during execution."
            self.status = TaskStatus.FAILED
            return self.status

        # --- Step: Move to Resource Node ---
        if self._current_step_key == "move_to_resource":
            if agent.state != AgentState.MOVING_TO_RESOURCE: # Ensure agent is in correct state
                 agent.state = AgentState.MOVING_TO_RESOURCE
                 agent.target_position = self.target_resource_node_ref.position

            if agent.target_position is None: # Should have been set in prepare or previous step
                agent.target_position = self.target_resource_node_ref.position

            if agent._move_towards_target(dt): # Agent reached the resource node
                self._current_step_key = "gather_resource"
                self.status = TaskStatus.IN_PROGRESS_GATHERING
                agent.state = AgentState.GATHERING_RESOURCE
                agent.gathering_timer = agent.config.DEFAULT_GATHERING_TIME # Agent needs config access or pass time
                agent.target_position = None # Clear movement target
            return self.status

        # --- Step: Gather Resource ---
        elif self._current_step_key == "gather_resource":
            if agent.state != AgentState.GATHERING_RESOURCE:
                agent.state = AgentState.GATHERING_RESOURCE
                agent.gathering_timer = agent.config.DEFAULT_GATHERING_TIME

            # Check if node still has resources / is still claimed by this task
            if self.target_resource_node_ref.current_quantity <= 0 or \
               self.target_resource_node_ref.claimed_by_task_id != self.task_id:
                self.error_message = "Resource node depleted or claim lost during gathering."
                # Potentially try to re-claim or find new node, or just fail
                self.status = TaskStatus.FAILED
                return self.status

            agent.gathering_timer -= dt
            if agent.gathering_timer <= 0:
                # Determine how much to gather:
                # Max agent can carry = agent.inventory_capacity - agent.current_inventory['quantity']
                # Max task wants = self.quantity_to_gather - self.quantity_gathered
                # Max can be dropped off = self.reserved_at_dropoff_quantity - self.quantity_delivered (assuming we deliver all gathered in one go)
                # Max available at node = self.target_resource_node_ref.current_quantity
                
                # Agent should only gather what it can carry AND what is reserved at dropoff for this trip
                # (assuming one gather -> one deliver cycle for simplicity here)
                can_carry_more = agent.inventory_capacity - agent.current_inventory['quantity']
                
                # Amount to gather for this specific trip, limited by what's reserved at dropoff and what agent can carry
                amount_to_attempt_gather = min(
                    can_carry_more,
                    self.reserved_at_dropoff_quantity, # This is the crucial link to prevent over-collection for storage
                    self.quantity_to_gather - self.quantity_gathered # Overall task goal
                )
                
                if amount_to_attempt_gather > 0:
                    gathered = self.target_resource_node_ref.collect_resource(amount_to_attempt_gather)
                    if gathered > 0:
                        # Assume agent inventory handles mixed types or is cleared for new task type
                        if agent.current_inventory['resource_type'] is None or agent.current_inventory['resource_type'] == self.resource_type_to_gather:
                            agent.current_inventory['resource_type'] = self.resource_type_to_gather
                            agent.current_inventory['quantity'] += gathered
                            self.quantity_gathered += gathered
                            print(f"Task {self.task_id}: Agent {agent.id} gathered {gathered} {self.resource_type_to_gather.name}. Total gathered for task: {self.quantity_gathered}")
                        else:
                            self.error_message = "Agent inventory has different resource type."
                            self.status = TaskStatus.FAILED # Or handle this more gracefully
                            return self.status
                
                # Transition to moving to dropoff
                self._current_step_key = "move_to_dropoff"
                self.status = TaskStatus.IN_PROGRESS_MOVE_TO_DROPOFF
                agent.state = AgentState.MOVING_TO_STORAGE # Or MOVING_TO_PROCESSOR if applicable
                agent.target_position = self.target_dropoff_ref.position
                
                # Release node claim if we are done with it for this task
                # (e.g. if quantity_to_gather is met or node is empty)
                # For simplicity, if task is to gather X, and we gathered X, or node is empty, release.
                if self.quantity_gathered >= self.quantity_to_gather or self.target_resource_node_ref.current_quantity < 1:
                    if self.reserved_at_node: # Check if it was claimed by this task
                         self.target_resource_node_ref.release(agent.id, self.task_id)
                         self.reserved_at_node = False # Update task's view of claim
            return self.status

        # --- Step: Move to Dropoff ---
        elif self._current_step_key == "move_to_dropoff":
            if agent.state != AgentState.MOVING_TO_STORAGE: # Assuming StoragePoint for now
                agent.state = AgentState.MOVING_TO_STORAGE
                agent.target_position = self.target_dropoff_ref.position
            
            if agent.target_position is None:
                agent.target_position = self.target_dropoff_ref.position

            if agent._move_towards_target(dt):
                self._current_step_key = "deliver_resource"
                self.status = TaskStatus.IN_PROGRESS_DELIVERING
                agent.state = AgentState.DELIVERING_RESOURCE
                agent.delivery_timer = agent.config.DEFAULT_DELIVERY_TIME
                agent.target_position = None
            return self.status

        # --- Step: Deliver Resource ---
        elif self._current_step_key == "deliver_resource":
            if agent.state != AgentState.DELIVERING_RESOURCE:
                agent.state = AgentState.DELIVERING_RESOURCE
                agent.delivery_timer = agent.config.DEFAULT_DELIVERY_TIME

            agent.delivery_timer -= dt
            if agent.delivery_timer <= 0:
                amount_to_deliver = agent.current_inventory['quantity'] # Deliver whatever is in inventory for this resource type
                if amount_to_deliver > 0 and agent.current_inventory['resource_type'] == self.resource_type_to_gather:
                    # Use commit_reservation_to_storage
                    delivered_qty = self.target_dropoff_ref.commit_reservation_to_storage(
                        self.task_id,
                        self.resource_type_to_gather,
                        amount_to_deliver
                    )
                    
                    if delivered_qty > 0:
                        agent.current_inventory['quantity'] -= delivered_qty
                        self.quantity_delivered += delivered_qty
                        self.reserved_at_dropoff_quantity -= delivered_qty # Reduce active reservation
                        print(f"Task {self.task_id}: Agent {agent.id} delivered {delivered_qty} {self.resource_type_to_gather.name}. Total delivered for task: {self.quantity_delivered}")
                        if agent.current_inventory['quantity'] == 0:
                            agent.current_inventory['resource_type'] = None
                    else:
                        self.error_message = f"Failed to deliver {amount_to_deliver} to {self.target_dropoff_ref.position} despite reservation."
                        # This is a critical error if reservation was in place.
                        self.status = TaskStatus.FAILED
                        return self.status
                
                # Check if task is complete
                if self.quantity_delivered >= self.quantity_to_gather:
                    self.status = TaskStatus.COMPLETED
                elif agent.inventory_capacity == 0 and self.quantity_gathered < self.quantity_to_gather : # Agent delivered all it could carry, but task needs more
                    # Go back to gather more if task not complete and agent has capacity
                    # This requires re-claiming node if released, re-reserving space if needed.
                    # For simplicity now, if one cycle doesn't complete, it might need a new task or more complex logic.
                    # Current logic: one gather -> one deliver. If more is needed, this task might end and a new one created.
                    # Or, _current_step_key goes back to "move_to_resource" if node still valid and space can be reserved.
                    # This part needs careful design for multi-trip tasks.
                    # For now, let's assume if what was gathered is delivered, and task not met, it's a FAILED or needs more complex state.
                    # A simpler model: a task is for ONE trip. TaskManager makes more tasks.
                    # If we assume task is for ONE trip up to agent capacity or reservation:
                    self.status = TaskStatus.COMPLETED # Completed this trip. TaskManager can check if overall goal met.
                else:
                    # Still items in inventory but task not complete (should not happen if delivered all)
                    # Or, task requires more but agent is empty (handled above)
                    # If task is not complete, but agent is empty, it means this "trip" is done.
                    self.status = TaskStatus.COMPLETED # This specific gather-deliver cycle is done.
                                                     # TaskManager might need to issue a new task if overall goal not met.

            return self.status
        
        return self.status # Should not be reached if steps are exhaustive

    def cleanup(self, agent: 'Agent', resource_manager: 'ResourceManager', success: bool):
        self._update_timestamp()
        print(f"Task {self.task_id} cleanup. Success: {success}. Agent: {agent.id}")
        # Release resource node claim
        if self.target_resource_node_ref and self.reserved_at_node: # self.target_resource_node_ref.claimed_by_task_id == self.task_id:
            self.target_resource_node_ref.release(agent.id, self.task_id)
            self.reserved_at_node = False
            print(f"Task {self.task_id}: Released node {self.target_resource_node_ref.position}")

        # Release any remaining storage reservation
        if self.target_dropoff_ref and self.reserved_at_dropoff_quantity > 0:
            # release_reservation should take task_id and the amount to release (which is current remaining reservation)
            self.target_dropoff_ref.release_reservation(self.task_id, self.reserved_at_dropoff_quantity)
            print(f"Task {self.task_id}: Released {self.reserved_at_dropoff_quantity} from storage {self.target_dropoff_ref.position}")
            self.reserved_at_dropoff_quantity = 0
        
        # Agent's current_task will be set to None by the Agent class after this.
        # TaskManager will be notified by the Agent class.

    def get_target_description(self) -> str:
        if self._current_step_key == "move_to_resource" and self.target_resource_node_ref:
            return f"Moving to resource {self.resource_type_to_gather.name} at {self.target_resource_node_ref.position}"
        elif self._current_step_key == "gather_resource" and self.target_resource_node_ref:
            return f"Gathering {self.resource_type_to_gather.name} at {self.target_resource_node_ref.position}"
        elif self._current_step_key == "move_to_dropoff" and self.target_dropoff_ref:
            return f"Moving to dropoff at {self.target_dropoff_ref.position}"
        elif self._current_step_key == "deliver_resource" and self.target_dropoff_ref:
            return f"Delivering {self.resource_type_to_gather.name} to {self.target_dropoff_ref.position}"
        elif self.status == TaskStatus.PREPARING:
            return f"Preparing to gather {self.resource_type_to_gather.name}"
        return f"Gather/Deliver {self.resource_type_to_gather.name} (Status: {self.status.name})"
</file>

</files>
