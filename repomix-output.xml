This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  agents/
    __init__.py
    agent.py
    manager.py
  core/
    __init__.py
    config.py
    game_loop.py
  input/
    __init__.py
    handlers.py
  rendering/
    __init__.py
    debug_display.py
    grid.py
    task_status_display.py
  resources/
    __init__.py
    berry_bush.py
    manager.py
    mill.py
    node.py
    processing.py
    resource_types.py
    storage_point.py
    wheat_field.py
  tasks/
    task_manager.py
    task_types.py
    task.py
.gitignore
app.py
BERRY_INVENTORY_TASK_PLAN.md
breakdown.md
IMPLEMENTATION_PLAN_AGENT_ENHANCEMENTS.md
intelligent_agent_task_evaluation_plan.md
job_board_task_system_plan.md
main.py
project.md
RESOURCE_TARGET_PLAN.md
SLICE_1.1_PLAN.md
SLICE_1.2_PLAN.md
SLICE_2.1_PLAN.md
SLICE_2.2_PLAN.md
SLICE_2.2_STORAGE_POINT_PLAN.md
SLICE_3.1_PLAN.md
TASK_STATUS_UI_PLAN.md
TASK_SYSTEM_IMPLEMENTATION_PLAN.md
WHEAT_COLLECTION_IMPLEMENTATION_PLAN.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/agents/__init__.py">
# This file makes Python treat the directory 'agents' as a package.
</file>

<file path="src/core/__init__.py">
# Core module initialization
</file>

<file path="src/input/__init__.py">
# Input module initialization
</file>

<file path="src/input/handlers.py">
import pygame

def process_events():
    """
    Processes Pygame events.
    Returns True if the game should quit, False otherwise.
    """
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return True # Signal to quit
    return False # Continue running
</file>

<file path="src/rendering/__init__.py">
# Rendering module initialization
</file>

<file path="src/rendering/debug_display.py">
import pygame
from src.core import config

# Initialize font module (ideally done once at startup in main)
# pygame.font.init() # Assuming it's initialized in main.py later
debug_font = None

def init_debug_font():
    """Initializes the font used for debug text."""
    global debug_font
    # Prioritize Pygame's default font due to potential system font issues (fc-list missing)
    try:
        debug_font = pygame.font.Font(None, 20) # Pygame's default font
    except Exception as e:
        debug_font = None # Ensure it's None if default fails

def display_fps(surface, clock):
    """Renders the current FPS onto the surface."""
    # print("DEBUG: display_fps called") # DEBUG - Redundant with GameLoop log
    if not debug_font:
        init_debug_font() # Initialize if not already done

    if debug_font:
        # print("DEBUG: display_fps - debug_font available, rendering FPS") # DEBUG
        fps = clock.get_fps()
        fps_text = f"FPS: {fps:.2f}"
        try:
            text_surface = debug_font.render(fps_text, True, config.DEBUG_TEXT_COLOR)
            surface.blit(text_surface, (10, 10)) # Position at top-left
            # print("DEBUG: display_fps - FPS text blitted") # DEBUG
        except Exception as e: 
            print(f"ERROR: Failed to render FPS text: {e}")
</file>

<file path="src/rendering/task_status_display.py">
import pygame
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..tasks.task_manager import TaskManager
    from ..tasks.task import Task, GatherAndDeliverTask
    from ..tasks.task_types import TaskStatus # Added for explicit reference if needed by _render_task_details
    from ..core import config # For potential color or layout configs

class TaskStatusDisplay:
    """
    Displays the current status of tasks in the simulation.
    """
    def __init__(self,
                 task_manager: 'TaskManager',
                 font: pygame.font.Font,
                 panel_rect: pygame.Rect,
                 screen_surface: pygame.Surface,
                 config_module: 'config'): # Pass config module for colors etc.
        """
        Initializes the TaskStatusDisplay.

        Args:
            task_manager: Reference to the global TaskManager.
            font: Pygame font for rendering text.
            panel_rect: Rect defining the panel's position and dimensions.
            screen_surface: The main screen surface to blit onto.
            config_module: The game's configuration module.
        """
        self.task_manager_ref = task_manager
        self.font = font
        self.panel_rect = panel_rect
        self.screen_surface = screen_surface
        self.config = config_module

        self.panel_surface = pygame.Surface(self.panel_rect.size)
        self.background_color = pygame.Color(self.config.COLOR_BLACK) # Example, use config
        self.text_color = pygame.Color(self.config.DEBUG_TEXT_COLOR) # Example
        self.header_color = pygame.Color(self.config.COLOR_WHITE) # Example
        self.padding = 10
        self.line_height = self.font.get_linesize() + 2
        self.max_items_per_section = 10 # Configurable or dynamic

        # Colors for different task statuses (can be expanded)
        self.status_colors = {
            "PENDING": pygame.Color('yellow'),
            "ASSIGNED": pygame.Color('orange'),
            "PREPARING": pygame.Color('lightblue'),
            "IN_PROGRESS_MOVE_TO_RESOURCE": pygame.Color('cyan'),
            "IN_PROGRESS_GATHERING": pygame.Color('green'),
            "IN_PROGRESS_MOVE_TO_DROPOFF": pygame.Color('cyan'),
            "IN_PROGRESS_DELIVERING": pygame.Color('lightgreen'),
            "COMPLETED": pygame.Color('grey'),
            "FAILED": pygame.Color('red'),
            "CANCELLED": pygame.Color('magenta'),
        }
        self.default_status_color = self.text_color


    def _draw_text(self, surface: pygame.Surface, text: str, position: tuple[int, int], color: pygame.Color, font: pygame.font.Font) -> None:
        """Helper method to render and blit text."""
        text_surface = font.render(text, True, color)
        surface.blit(text_surface, position)

    def _render_task_details(self, task: 'Task', y_pos: int, surface: pygame.Surface) -> int:
        """Renders details of a single Task object."""
        from ..tasks.task import GatherAndDeliverTask # Local import for type check
        from ..tasks.task_types import TaskStatus # Local import for enum access

        start_y = y_pos
        task_id_short = str(task.task_id).split('-')[0]
        status_color = self.status_colors.get(task.status.name, self.default_status_color)

        # Line 1: Task ID and Type
        line1_text = f"ID: {task_id_short} ({task.task_type.name})"
        self._draw_text(surface, line1_text, (self.padding, y_pos), self.text_color, self.font)
        y_pos += self.line_height

        # Line 2: Status
        line2_text = f"Status: {task.status.name}"
        self._draw_text(surface, line2_text, (self.padding + 10, y_pos), status_color, self.font)
        y_pos += self.line_height

        # Line 3: Agent (if assigned)
        if task.agent_id:
            agent_id_short = str(task.agent_id).split('-')[0]
            line3_text = f"Agent: {agent_id_short}"
            self._draw_text(surface, line3_text, (self.padding + 10, y_pos), self.text_color, self.font)
            y_pos += self.line_height

        # Line 4: Specifics for GatherAndDeliverTask or general description
        details_text = ""
        if isinstance(task, GatherAndDeliverTask):
            details_text = f"Res: {task.resource_type_to_gather.name}, Qty: {task.quantity_gathered}/{task.quantity_to_gather}"
            if task.status in [
                TaskStatus.IN_PROGRESS_MOVE_TO_RESOURCE, TaskStatus.IN_PROGRESS_GATHERING,
                TaskStatus.IN_PROGRESS_MOVE_TO_DROPOFF, TaskStatus.IN_PROGRESS_DELIVERING,
                TaskStatus.PREPARING
            ]:
                details_text += f" | {task.get_target_description()}"

        elif task.status in [
            TaskStatus.IN_PROGRESS_MOVE_TO_RESOURCE, TaskStatus.IN_PROGRESS_GATHERING,
            TaskStatus.IN_PROGRESS_MOVE_TO_DROPOFF, TaskStatus.IN_PROGRESS_DELIVERING,
            TaskStatus.PREPARING # General preparing state
        ]: # For other task types that might have a description
            details_text = task.get_target_description()

        if details_text:
            self._draw_text(surface, details_text, (self.padding + 10, y_pos), self.text_color, self.font)
            y_pos += self.line_height

        # Line 5: Error message (if failed)
        if task.status == TaskStatus.FAILED and task.error_message:
            error_text = f"Error: {task.error_message}"
            # Truncate error message if too long
            max_error_len = (self.panel_rect.width - self.padding * 3) // (self.font.size("A")[0] or 1) # Approx chars
            if len(error_text) > max_error_len:
                error_text = error_text[:max_error_len-3] + "..."
            self._draw_text(surface, error_text, (self.padding + 10, y_pos), self.status_colors.get("FAILED", self.default_status_color), self.font)
            y_pos += self.line_height

        # Separator line
        pygame.draw.line(surface, self.text_color, (self.padding, y_pos), (self.panel_rect.width - self.padding, y_pos), 1)
        y_pos += self.padding // 2
        return y_pos

    def draw(self) -> None:
        """Draws the task status panel."""
        self.panel_surface.fill(self.background_color)
        current_y = self.padding

        # Section: Pending Tasks
        header_text_pending = f"Pending Tasks ({len(self.task_manager_ref.pending_tasks)})"
        self._draw_text(self.panel_surface, header_text_pending, (self.padding, current_y), self.header_color, self.font)
        current_y += self.line_height + self.padding // 2
        for i, task in enumerate(self.task_manager_ref.pending_tasks):
            if i >= self.max_items_per_section:
                self._draw_text(self.panel_surface, f"... and {len(self.task_manager_ref.pending_tasks) - i} more.", (self.padding, current_y), self.text_color, self.font)
                current_y += self.line_height
                break
            current_y = self._render_task_details(task, current_y, self.panel_surface)
        current_y += self.padding # Space before next section

        # Section: In-Progress Tasks
        header_text_assigned = f"In-Progress Tasks ({len(self.task_manager_ref.assigned_tasks)})"
        self._draw_text(self.panel_surface, header_text_assigned, (self.padding, current_y), self.header_color, self.font)
        current_y += self.line_height + self.padding // 2
        for i, task in enumerate(list(self.task_manager_ref.assigned_tasks.values())): # Convert dict_values to list for enumerate
            if i >= self.max_items_per_section:
                self._draw_text(self.panel_surface, f"... and {len(self.task_manager_ref.assigned_tasks) - i} more.", (self.padding, current_y), self.text_color, self.font)
                current_y += self.line_height
                break
            current_y = self._render_task_details(task, current_y, self.panel_surface)
        current_y += self.padding

        # Section: Recently Completed Tasks
        completed_tasks_to_show = self.task_manager_ref.completed_tasks[-self.max_items_per_section:]
        header_text_completed = f"Recently Completed ({len(completed_tasks_to_show)} of {len(self.task_manager_ref.completed_tasks)})"
        self._draw_text(self.panel_surface, header_text_completed, (self.padding, current_y), self.header_color, self.font)
        current_y += self.line_height + self.padding // 2
        for task in reversed(completed_tasks_to_show): # Show newest first
            current_y = self._render_task_details(task, current_y, self.panel_surface)
            if current_y > self.panel_rect.height - self.padding: # Stop if panel is full
                 break
        current_y += self.padding

        # Section: Recently Failed Tasks
        failed_tasks_to_show = self.task_manager_ref.failed_tasks[-self.max_items_per_section:]
        header_text_failed = f"Recently Failed ({len(failed_tasks_to_show)} of {len(self.task_manager_ref.failed_tasks)})"
        self._draw_text(self.panel_surface, header_text_failed, (self.padding, current_y), self.header_color, self.font)
        current_y += self.line_height + self.padding // 2
        for task in reversed(failed_tasks_to_show): # Show newest first
            current_y = self._render_task_details(task, current_y, self.panel_surface)
            if current_y > self.panel_rect.height - self.padding: # Stop if panel is full
                 break
        current_y += self.padding

        # Blit the panel surface to the main screen
        self.screen_surface.blit(self.panel_surface, self.panel_rect.topleft)
</file>

<file path="src/resources/__init__.py">
# This file makes Python treat the `resources` directory as a package.
</file>

<file path="src/resources/mill.py">
import pygame
from .processing import ProcessingStation
from ..resources.resource_types import ResourceType
from ..core import config # For GRID_CELL_SIZE, colors etc.

class Mill(ProcessingStation):
    """
    A specific processing station that converts Wheat into Flour Powder.
    """
    MILL_COLOR_IDLE = (139, 69, 19)  # SaddleBrown
    MILL_COLOR_PROCESSING = (160, 82, 45) # Sienna

    def __init__(self, position: pygame.Vector2):
        """
        Initializes a Mill.

        Args:
            position: The position of the mill on the grid.
        """
        super().__init__(
            position=position,
            accepted_input_type=ResourceType.WHEAT,
            produced_output_type=ResourceType.FLOUR_POWDER,
            conversion_ratio=1.0,  # 1 Wheat -> 1 Flour Powder
            processing_speed=8,    # 8 simulation ticks per unit
            input_capacity=25,
            output_capacity=25
        )
        self.color = self.MILL_COLOR_IDLE
        self.processing_color = self.MILL_COLOR_PROCESSING

    # The draw method from ProcessingStation can be used directly if the
    # color and processing_color are set appropriately, as done above.
    # If a more distinct visual is needed, this draw method can be overridden.
    # For now, we rely on the base class draw method with custom colors.

    # def draw(self, surface: pygame.Surface, font: pygame.font.Font):
    #     """
    #     Draws the mill on the given surface.
    #     Overrides ProcessingStation.draw() for specific Mill visuals if needed.
    #     """
    #     # Call super().draw() or implement custom drawing
    #     # For now, let's ensure the colors are set correctly in __init__
    #     # and rely on the base class draw method.
    #     current_display_color = self.processing_color if self.is_processing else self.color
    #
    #     rect_x = self.position.x * config.GRID_CELL_SIZE
    #     rect_y = self.position.y * config.GRID_CELL_SIZE
    #     station_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)
    #
    #     pygame.draw.rect(surface, current_display_color, station_rect)
    #     pygame.draw.rect(surface, config.COLOR_BLACK, station_rect, 1) # Border
    #
    #     # You can call the base class's text drawing logic or reimplement
    #     super().draw_text_info(surface, font) # Assuming base class has such a helper or draw has it

    def __str__(self):
        return super().__str__() # Or customize if needed

    def __repr__(self):
        return f"Mill(position={self.position})"
</file>

<file path="src/resources/processing.py">
import pygame
from typing import Optional
from ..resources.resource_types import ResourceType
from ..core import config # For potential future use, e.g. visual configuration

class ProcessingStation:
    """
    Base class for resource processing stations (e.g., Mill, Bakery).
    Processes input resources into output resources over time.
    """
    def __init__(self,
                 position: pygame.Vector2,
                 accepted_input_type: ResourceType,
                 produced_output_type: ResourceType,
                 conversion_ratio: float, # e.g., 1.0 means 1 input makes 1 output
                 processing_speed: int,   # Ticks required to process one unit (or one batch based on conversion)
                 input_capacity: int,
                 output_capacity: int):
        """
        Initializes a ProcessingStation.

        Args:
            position: The position of the station on the grid.
            accepted_input_type: The type of resource this station accepts.
            produced_output_type: The type of resource this station produces.
            conversion_ratio: How many input units are needed for one output unit,
                              or how many output units are produced from one input unit.
                              For simplicity, let's assume 1 input unit produces X output units,
                              where X is conversion_ratio. Or 1 input -> 1 output if ratio is 1.0.
                              Let's refine: conversion_ratio = output_units / input_units.
                              If 1 WHEAT makes 1 FLOUR, ratio = 1.0.
                              If 2 WHEAT makes 1 FLOUR, ratio = 0.5 (meaning 1 input makes 0.5 output, effectively needing 2 inputs for 1 output).
                              Let's stick to: 1 input unit produces `conversion_ratio` output units.
                              The plan for Mill implies 1 WHEAT -> 1 FLOUR_POWDER, so ratio = 1.0.
            processing_speed: Number of simulation ticks required to complete one processing cycle.
            input_capacity: Maximum amount of input resources the station can hold.
            output_capacity: Maximum amount of output resources the station can hold.
        """
        if not isinstance(position, pygame.Vector2):
            raise TypeError("Position must be a pygame.Vector2")

        self.position = position
        self.accepted_input_type = accepted_input_type
        self.produced_output_type = produced_output_type
        self.conversion_ratio = float(conversion_ratio) # Ensure float
        self.processing_speed = int(processing_speed) # Ticks per processing cycle
        self.input_capacity = int(input_capacity)
        self.output_capacity = int(output_capacity)

        self.current_input_quantity = 0.0  # Can be float if partial inputs are allowed by agents
        self.current_output_quantity = 0.0 # Can be float
        self.is_processing = False
        self.processing_progress = 0  # Ticks accumulated towards current processing cycle

        # For drawing (subclasses should define specific colors/sprites)
        self.color = (100, 100, 100) # Default grey
        self.processing_color = (150, 150, 50) # Yellowish when processing

    def receive(self, resource_type: ResourceType, quantity: int) -> bool:
        """
        Adds input resources to the station if the type is accepted and there's capacity.
        Agents will typically deliver integer quantities.
        Returns True if resources were successfully added, False otherwise.
        """
        if resource_type == self.accepted_input_type and self.current_input_quantity < self.input_capacity:
            amount_to_add = min(float(quantity), self.input_capacity - self.current_input_quantity)
            if amount_to_add > 0:
                self.current_input_quantity += amount_to_add
                # print(f"{self} received {amount_to_add} of {resource_type.name}. Input: {self.current_input_quantity}") # Debug
                return True
        # print(f"{self} FAILED to receive {quantity} of {resource_type.name}. Input: {self.current_input_quantity}, Capacity: {self.input_capacity}, Accepted: {self.accepted_input_type.name}") # Debug
        return False

    def tick(self):
        """
        Handles the processing logic per simulation tick.
        One processing cycle consumes 1 unit of input and produces `conversion_ratio` units of output.
        """
        if self.current_input_quantity >= 1.0 and self.current_output_quantity < self.output_capacity:
            self.is_processing = True
            self.processing_progress += 1
            if self.processing_progress >= self.processing_speed:
                # One processing cycle complete
                self.current_input_quantity -= 1.0 # Consume one unit of input
                
                produced_amount = 1.0 * self.conversion_ratio
                
                # Ensure we don't overflow output capacity
                actual_produced_amount = min(produced_amount, self.output_capacity - self.current_output_quantity)
                
                self.current_output_quantity += actual_produced_amount
                
                self.processing_progress = 0 # Reset for next cycle
                
                # If we couldn't produce the full amount due to output capacity,
                # the input was still consumed. This implies a need for agents to clear output.
                # print(f"{self} processed. Input: {self.current_input_quantity}, Output: {self.current_output_quantity}") # Debug

                if self.current_input_quantity < 1.0 or self.current_output_quantity >= self.output_capacity:
                    self.is_processing = False # Stop if no more input or output full
        else:
            self.is_processing = False
            self.processing_progress = 0 # Reset if not enough input or output is full

    def dispense(self, requested_quantity: int) -> int:
        """
        Allows an agent to collect processed output resources.
        Returns the actual integer amount of resources dispensed.
        """
        available_integer_output = int(self.current_output_quantity)
        amount_to_dispense = min(requested_quantity, available_integer_output)

        if amount_to_dispense > 0:
            self.current_output_quantity -= float(amount_to_dispense)
            # print(f"{self} dispensed {amount_to_dispense} of {self.produced_output_type.name}. Output: {self.current_output_quantity}") # Debug
            return amount_to_dispense
        return 0

    def can_accept_input(self, resource_type: ResourceType, quantity: int = 1) -> bool:
        """Checks if the station can accept the given resource type and has space for at least the quantity."""
        return resource_type == self.accepted_input_type and (self.current_input_quantity + quantity) <= self.input_capacity

    def has_output(self) -> bool:
        """Checks if there are any processed goods (at least 1 full unit) to collect."""
        return self.current_output_quantity >= 1.0

    def get_visual_state(self) -> str:
        """Returns 'idle' or 'processing' for visualization purposes."""
        return "processing" if self.is_processing else "idle"

    def draw(self, surface: pygame.Surface, font: pygame.font.Font):
        """
        Draws the processing station on the given surface.
        Subclasses should override for specific visuals.
        """
        rect_x = self.position.x * config.GRID_CELL_SIZE
        rect_y = self.position.y * config.GRID_CELL_SIZE
        station_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)

        current_color = self.processing_color if self.is_processing else self.color
        pygame.draw.rect(surface, current_color, station_rect)
        pygame.draw.rect(surface, config.COLOR_BLACK, station_rect, 1) # Border

        # Display input: "I:type qty/cap"
        input_text_str = f"I:{self.accepted_input_type.name[0]}:{int(self.current_input_quantity)}/{self.input_capacity}"
        input_surface = font.render(input_text_str, True, config.DEBUG_TEXT_COLOR)
        input_rect = input_surface.get_rect(midtop=station_rect.midtop)
        input_rect.y += 2 # Small offset
        surface.blit(input_surface, input_rect)
        
        # Display output: "O:type qty/cap"
        output_text_str = f"O:{self.produced_output_type.name[0]}:{int(self.current_output_quantity)}/{self.output_capacity}"
        output_surface = font.render(output_text_str, True, config.DEBUG_TEXT_COLOR)
        output_rect = output_surface.get_rect(midbottom=station_rect.midbottom)
        output_rect.y -= 2 # Small offset
        surface.blit(output_surface, output_rect)

        if self.is_processing:
            progress_text_str = f"{self.processing_progress}/{self.processing_speed}"
            progress_surface = font.render(progress_text_str, True, config.DEBUG_TEXT_COLOR)
            progress_rect = progress_surface.get_rect(center=station_rect.center)
            surface.blit(progress_surface, progress_rect)


    def __str__(self):
        return (f"{self.__class__.__name__} at {self.position} "
                f"[{self.accepted_input_type.name} -> {self.produced_output_type.name}] "
                f"Input: {self.current_input_quantity:.1f}/{self.input_capacity}, "
                f"Output: {self.current_output_quantity:.1f}/{self.output_capacity}, "
                f"State: {self.get_visual_state()} ({self.processing_progress}/{self.processing_speed})")

    def __repr__(self):
        return (f"{self.__class__.__name__}(position={self.position}, "
                f"input_type={self.accepted_input_type.name}, output_type={self.produced_output_type.name})")
</file>

<file path="src/tasks/task_types.py">
from enum import Enum, auto

class TaskType(Enum):
    """Defines the types of tasks an agent can perform."""
    GATHER_AND_DELIVER = auto()
    PROCESS_RESOURCE = auto() # Example for future expansion
    COLLECT_PROCESSED_AND_DELIVER = auto() # Example for future expansion
    # Add other task types as needed

class TaskStatus(Enum):
    """Defines the possible states of a task."""
    PENDING = auto()    # Task is created but not yet assigned or prepared
    ASSIGNED = auto()   # Task is assigned to an agent, but not yet prepared
    PREPARING = auto()  # Task is actively trying to claim resources/reserve space
    # IN_PROGRESS states indicate the agent is actively working on a phase of the task
    IN_PROGRESS_MOVE_TO_RESOURCE = auto()
    IN_PROGRESS_GATHERING = auto()
    IN_PROGRESS_MOVE_TO_DROPOFF = auto()
    IN_PROGRESS_DELIVERING = auto()
    # Add other IN_PROGRESS states for more complex tasks (e.g., IN_PROGRESS_PROCESSING)
    COMPLETED = auto()  # Task was successfully finished
    FAILED = auto()     # Task could not be completed
    CANCELLED = auto()  # Task was cancelled before completion
</file>

<file path="src/tasks/task.py">
import uuid
import time
from abc import ABC, abstractmethod
from typing import Optional, TYPE_CHECKING

from .task_types import TaskType, TaskStatus
from ..resources.resource_types import ResourceType # Assuming this path is correct

# Forward references to avoid circular imports
if TYPE_CHECKING:
    from ..agents.agent import Agent # Assuming agent.py is in src/agents/
    from ..resources.manager import ResourceManager # Assuming manager.py is in src/resources/
    from ..resources.node import ResourceNode
    from ..resources.storage_point import StoragePoint
    # Add ..resources.processing.ProcessingStation if needed for other task types

class Task(ABC):
    """Base class for all tasks an agent can perform."""

    def __init__(self, task_type: TaskType, priority: int):
        self.task_id: uuid.UUID = uuid.uuid4()
        self.task_type: TaskType = task_type
        self.status: TaskStatus = TaskStatus.PENDING
        self.priority: int = priority
        self.agent_id: Optional[uuid.UUID] = None # Will be set when an agent is assigned
        self.creation_time: float = time.time()
        self.last_update_time: float = self.creation_time
        self.error_message: Optional[str] = None

    @abstractmethod
    def prepare(self, agent: 'Agent', resource_manager: 'ResourceManager') -> bool:
        """
        Handles initial claims, reservations, and any other setup required before
        the task can be executed.
        Sets the task status to PREPARING during its execution.
        Returns True if preparation was successful and the task can proceed, False otherwise.
        If successful, should set the task's status to an appropriate IN_PROGRESS state
        and potentially the agent's initial state.
        """
        pass

    @abstractmethod
    def execute_step(self, agent: 'Agent', dt: float, resource_manager: 'ResourceManager') -> TaskStatus:
        """
        Advances the task logic by one step or time delta.
        This method is called repeatedly by the assigned agent.
        It should update the task's status and return it.
        The task itself is responsible for changing the agent's state (e.g., agent.state = AgentState.MOVING_TO_RESOURCE).
        """
        pass

    @abstractmethod
    def cleanup(self, agent: 'Agent', resource_manager: 'ResourceManager', success: bool):
        """
        Called when the task is completed, failed, or cancelled.
        Releases any claims or reservations held by this task.
        Notifies the TaskManager of the outcome.
        """
        pass

    @abstractmethod
    def get_target_description(self) -> str:
        """Returns a string description of the current target or goal of the task for debugging/UI."""
        pass

    def _update_timestamp(self):
        self.last_update_time = time.time()


class GatherAndDeliverTask(Task):
    """A task for an agent to gather a specific resource and deliver it to a dropoff point."""

    def __init__(self,
                 priority: int,
                 resource_type_to_gather: ResourceType,
                 quantity_to_gather: int,
                 target_resource_node_id: Optional[uuid.UUID] = None, # Can be pre-assigned or found in prepare
                 target_dropoff_id: Optional[uuid.UUID] = None): # Can be pre-assigned or found in prepare
        super().__init__(TaskType.GATHER_AND_DELIVER, priority)
        self.resource_type_to_gather: ResourceType = resource_type_to_gather
        self.quantity_to_gather: int = quantity_to_gather # Target amount for this task instance
        
        # These will be populated during prepare() or if pre-assigned
        self.target_resource_node_ref: Optional['ResourceNode'] = None
        self.target_dropoff_ref: Optional['StoragePoint'] = None # Or ProcessingStation

        self.quantity_gathered: int = 0
        self.quantity_delivered: int = 0
        
        self.reserved_at_node: bool = False # More specific: store task_id in node
        self.reserved_at_dropoff_quantity: int = 0
        
        # Internal state machine for the task's progression
        # This could map to more detailed TaskStatus enum values or AgentState values
        self._current_step_key: str = "find_resource_and_dropoff" # Initial step

    def prepare(self, agent: 'Agent', resource_manager: 'ResourceManager') -> bool:
        from ..agents.agent import AgentState # Import here to use AgentState enum
        self._update_timestamp()
        self.status = TaskStatus.PREPARING
        agent.target_position = None # Clear previous agent target

        # 1. Find and Claim Resource Node
        if not self.target_resource_node_ref:
            # Simplified finding logic for now. TaskManager might do this or provide candidates.
            # Agent's current position: agent.position
            # ResourceManager: resource_manager.get_nodes_by_type(self.resource_type_to_gather)
            # TODO: Implement more sophisticated node finding (nearest, available, etc.)
            # For now, assume resource_manager can provide a suitable node or this task was created with one.
            # This part needs robust implementation based on how TaskManager generates tasks.
            
            # Placeholder: Find the first available node of the correct type
            candidate_nodes = resource_manager.get_nodes_by_type(self.resource_type_to_gather)
            for node in sorted(candidate_nodes, key=lambda n: (n.position - agent.position).length_squared()):
                if node.current_quantity >= 1 and node.claim(agent.id, self.task_id): # Using new claim
                    self.target_resource_node_ref = node
                    self.reserved_at_node = True # Or check node.claimed_by_task_id
                    break
            
        if not self.target_resource_node_ref:
            self.error_message = f"Could not find or claim resource node for {self.resource_type_to_gather.name}."
            self.status = TaskStatus.FAILED
            return False

        # 2. Find and Reserve Space at Dropoff
        if not self.target_dropoff_ref:
            # Simplified finding logic.
            # TODO: Implement sophisticated dropoff finding (accepts type, has space, nearest)
            # For now, assume resource_manager can provide a suitable storage point.
            # This part needs robust implementation.
            
            # Placeholder: Find the first storage point that can accept the resource
            # This should ideally consider the quantity we intend to gather.
            # The quantity to reserve should be min(self.quantity_to_gather, agent.inventory_capacity)
            qty_to_reserve_for_delivery = min(self.quantity_to_gather, agent.inventory_capacity)
            qty_to_reserve_for_delivery = min(self.target_resource_node_ref.current_quantity, qty_to_reserve_for_delivery) # Don't reserve more than available

            all_storage_points = resource_manager.storage_points # Assuming direct access
            for sp in sorted(all_storage_points, key=lambda s: (s.position - agent.position).length_squared()):
                # reserve_space should check accepted types and available capacity
                reserved_amount = sp.reserve_space(self.task_id, self.resource_type_to_gather, qty_to_reserve_for_delivery)
                if reserved_amount > 0:
                    self.target_dropoff_ref = sp
                    self.reserved_at_dropoff_quantity = reserved_amount
                    break
        
        if not self.target_dropoff_ref or self.reserved_at_dropoff_quantity == 0:
            self.error_message = f"Could not find or reserve space at dropoff for {self.resource_type_to_gather.name} (wanted to reserve {qty_to_reserve_for_delivery})."
            # Release claimed node if dropoff reservation fails
            if self.target_resource_node_ref and self.reserved_at_node:
                self.target_resource_node_ref.release(agent.id, self.task_id)
                self.reserved_at_node = False
            self.status = TaskStatus.FAILED
            return False

        # If all preparations are successful:
        self.status = TaskStatus.IN_PROGRESS_MOVE_TO_RESOURCE # First active step
        self._current_step_key = "move_to_resource"
        agent.state = AgentState.MOVING_TO_RESOURCE # Set agent's state
        agent.target_position = self.target_resource_node_ref.position
        print(f"Task {self.task_id} PREPARED for agent {agent.id}. Target Node: {self.target_resource_node_ref.position}, Target Dropoff: {self.target_dropoff_ref.position}, Reserved Dropoff Qty: {self.reserved_at_dropoff_quantity}")
        return True

    def execute_step(self, agent: 'Agent', dt: float, resource_manager: 'ResourceManager') -> TaskStatus:
        self._update_timestamp()
        from ..agents.agent import AgentState # Import here to use AgentState enum

        if not self.target_resource_node_ref or not self.target_dropoff_ref:
            self.error_message = "Target resource or dropoff became invalid during execution."
            self.status = TaskStatus.FAILED
            return self.status

        # --- Step: Move to Resource Node ---
        if self._current_step_key == "move_to_resource":
            if agent.state != AgentState.MOVING_TO_RESOURCE: # Ensure agent is in correct state
                 agent.state = AgentState.MOVING_TO_RESOURCE
                 agent.target_position = self.target_resource_node_ref.position

            if agent.target_position is None: # Should have been set in prepare or previous step
                agent.target_position = self.target_resource_node_ref.position

            if agent._move_towards_target(dt): # Agent reached the resource node
                self._current_step_key = "gather_resource"
                self.status = TaskStatus.IN_PROGRESS_GATHERING
                agent.state = AgentState.GATHERING_RESOURCE
                agent.gathering_timer = agent.config.DEFAULT_GATHERING_TIME # Agent needs config access or pass time
                agent.target_position = None # Clear movement target
            return self.status

        # --- Step: Gather Resource ---
        elif self._current_step_key == "gather_resource":
            if agent.state != AgentState.GATHERING_RESOURCE:
                agent.state = AgentState.GATHERING_RESOURCE
                agent.gathering_timer = agent.config.DEFAULT_GATHERING_TIME

            # Check if node still has resources / is still claimed by this task
            if self.target_resource_node_ref.current_quantity <= 0 or \
               self.target_resource_node_ref.claimed_by_task_id != self.task_id:
                self.error_message = "Resource node depleted or claim lost during gathering."
                # Potentially try to re-claim or find new node, or just fail
                self.status = TaskStatus.FAILED
                return self.status

            agent.gathering_timer -= dt
            if agent.gathering_timer <= 0:
                # Determine how much to gather:
                # Max agent can carry = agent.inventory_capacity - agent.current_inventory['quantity']
                # Max task wants = self.quantity_to_gather - self.quantity_gathered
                # Max can be dropped off = self.reserved_at_dropoff_quantity - self.quantity_delivered (assuming we deliver all gathered in one go)
                # Max available at node = self.target_resource_node_ref.current_quantity
                
                # Agent should only gather what it can carry AND what is reserved at dropoff for this trip
                # (assuming one gather -> one deliver cycle for simplicity here)
                can_carry_more = agent.inventory_capacity - agent.current_inventory['quantity']
                
                # Amount to gather for this specific trip, limited by what's reserved at dropoff and what agent can carry
                amount_to_attempt_gather = min(
                    can_carry_more,
                    self.reserved_at_dropoff_quantity, # This is the crucial link to prevent over-collection for storage
                    self.quantity_to_gather - self.quantity_gathered # Overall task goal
                )
                
                if amount_to_attempt_gather > 0:
                    gathered = self.target_resource_node_ref.collect_resource(amount_to_attempt_gather)
                    if gathered > 0:
                        # Assume agent inventory handles mixed types or is cleared for new task type
                        if agent.current_inventory['resource_type'] is None or agent.current_inventory['resource_type'] == self.resource_type_to_gather:
                            agent.current_inventory['resource_type'] = self.resource_type_to_gather
                            agent.current_inventory['quantity'] += gathered
                            self.quantity_gathered += gathered
                            print(f"Task {self.task_id}: Agent {agent.id} gathered {gathered} {self.resource_type_to_gather.name}. Total gathered for task: {self.quantity_gathered}")
                        else:
                            self.error_message = "Agent inventory has different resource type."
                            self.status = TaskStatus.FAILED # Or handle this more gracefully
                            return self.status
                
                # Transition to moving to dropoff
                self._current_step_key = "move_to_dropoff"
                self.status = TaskStatus.IN_PROGRESS_MOVE_TO_DROPOFF
                agent.state = AgentState.MOVING_TO_STORAGE # Or MOVING_TO_PROCESSOR if applicable
                agent.target_position = self.target_dropoff_ref.position
                
                # Release node claim if we are done with it for this task
                # (e.g. if quantity_to_gather is met or node is empty)
                # For simplicity, if task is to gather X, and we gathered X, or node is empty, release.
                if self.quantity_gathered >= self.quantity_to_gather or self.target_resource_node_ref.current_quantity < 1:
                    if self.reserved_at_node: # Check if it was claimed by this task
                         self.target_resource_node_ref.release(agent.id, self.task_id)
                         self.reserved_at_node = False # Update task's view of claim
            return self.status

        # --- Step: Move to Dropoff ---
        elif self._current_step_key == "move_to_dropoff":
            if agent.state != AgentState.MOVING_TO_STORAGE: # Assuming StoragePoint for now
                agent.state = AgentState.MOVING_TO_STORAGE
                agent.target_position = self.target_dropoff_ref.position
            
            if agent.target_position is None:
                agent.target_position = self.target_dropoff_ref.position

            if agent._move_towards_target(dt):
                self._current_step_key = "deliver_resource"
                self.status = TaskStatus.IN_PROGRESS_DELIVERING
                agent.state = AgentState.DELIVERING_RESOURCE
                agent.delivery_timer = agent.config.DEFAULT_DELIVERY_TIME
                agent.target_position = None
            return self.status

        # --- Step: Deliver Resource ---
        elif self._current_step_key == "deliver_resource":
            if agent.state != AgentState.DELIVERING_RESOURCE:
                agent.state = AgentState.DELIVERING_RESOURCE
                agent.delivery_timer = agent.config.DEFAULT_DELIVERY_TIME

            agent.delivery_timer -= dt
            if agent.delivery_timer <= 0:
                amount_to_deliver = agent.current_inventory['quantity'] # Deliver whatever is in inventory for this resource type
                if amount_to_deliver > 0 and agent.current_inventory['resource_type'] == self.resource_type_to_gather:
                    # Use commit_reservation_to_storage
                    delivered_qty = self.target_dropoff_ref.commit_reservation_to_storage(
                        self.task_id,
                        self.resource_type_to_gather,
                        amount_to_deliver
                    )
                    
                    if delivered_qty > 0:
                        agent.current_inventory['quantity'] -= delivered_qty
                        self.quantity_delivered += delivered_qty
                        self.reserved_at_dropoff_quantity -= delivered_qty # Reduce active reservation
                        print(f"Task {self.task_id}: Agent {agent.id} delivered {delivered_qty} {self.resource_type_to_gather.name}. Total delivered for task: {self.quantity_delivered}")
                        if agent.current_inventory['quantity'] == 0:
                            agent.current_inventory['resource_type'] = None
                    else:
                        self.error_message = f"Failed to deliver {amount_to_deliver} to {self.target_dropoff_ref.position} despite reservation."
                        # This is a critical error if reservation was in place.
                        self.status = TaskStatus.FAILED
                        return self.status
                
                # Check if task is complete
                if self.quantity_delivered >= self.quantity_to_gather:
                    self.status = TaskStatus.COMPLETED
                elif agent.inventory_capacity == 0 and self.quantity_gathered < self.quantity_to_gather : # Agent delivered all it could carry, but task needs more
                    # Go back to gather more if task not complete and agent has capacity
                    # This requires re-claiming node if released, re-reserving space if needed.
                    # For simplicity now, if one cycle doesn't complete, it might need a new task or more complex logic.
                    # Current logic: one gather -> one deliver. If more is needed, this task might end and a new one created.
                    # Or, _current_step_key goes back to "move_to_resource" if node still valid and space can be reserved.
                    # This part needs careful design for multi-trip tasks.
                    # For now, let's assume if what was gathered is delivered, and task not met, it's a FAILED or needs more complex state.
                    # A simpler model: a task is for ONE trip. TaskManager makes more tasks.
                    # If we assume task is for ONE trip up to agent capacity or reservation:
                    self.status = TaskStatus.COMPLETED # Completed this trip. TaskManager can check if overall goal met.
                else:
                    # Still items in inventory but task not complete (should not happen if delivered all)
                    # Or, task requires more but agent is empty (handled above)
                    # If task is not complete, but agent is empty, it means this "trip" is done.
                    self.status = TaskStatus.COMPLETED # This specific gather-deliver cycle is done.
                                                     # TaskManager might need to issue a new task if overall goal not met.

            return self.status
        
        return self.status # Should not be reached if steps are exhaustive

    def cleanup(self, agent: 'Agent', resource_manager: 'ResourceManager', success: bool):
        self._update_timestamp()
        print(f"Task {self.task_id} cleanup. Success: {success}. Agent: {agent.id}")
        # Release resource node claim
        if self.target_resource_node_ref and self.reserved_at_node: # self.target_resource_node_ref.claimed_by_task_id == self.task_id:
            self.target_resource_node_ref.release(agent.id, self.task_id)
            self.reserved_at_node = False
            print(f"Task {self.task_id}: Released node {self.target_resource_node_ref.position}")

        # Release any remaining storage reservation
        if self.target_dropoff_ref and self.reserved_at_dropoff_quantity > 0:
            # release_reservation should take task_id and the amount to release (which is current remaining reservation)
            self.target_dropoff_ref.release_reservation(self.task_id, self.reserved_at_dropoff_quantity)
            print(f"Task {self.task_id}: Released {self.reserved_at_dropoff_quantity} from storage {self.target_dropoff_ref.position}")
            self.reserved_at_dropoff_quantity = 0
        
        # Agent's current_task will be set to None by the Agent class after this.
        # TaskManager will be notified by the Agent class.

    def get_target_description(self) -> str:
        if self._current_step_key == "move_to_resource" and self.target_resource_node_ref:
            return f"Moving to resource {self.resource_type_to_gather.name} at {self.target_resource_node_ref.position}"
        elif self._current_step_key == "gather_resource" and self.target_resource_node_ref:
            return f"Gathering {self.resource_type_to_gather.name} at {self.target_resource_node_ref.position}"
        elif self._current_step_key == "move_to_dropoff" and self.target_dropoff_ref:
            return f"Moving to dropoff at {self.target_dropoff_ref.position}"
        elif self._current_step_key == "deliver_resource" and self.target_dropoff_ref:
            return f"Delivering {self.resource_type_to_gather.name} to {self.target_dropoff_ref.position}"
        elif self.status == TaskStatus.PREPARING:
            return f"Preparing to gather {self.resource_type_to_gather.name}"
        return f"Gather/Deliver {self.resource_type_to_gather.name} (Status: {self.status.name})"
</file>

<file path=".gitignore">
__pycache__/
</file>

<file path="app.py">
import pygame.examples.aliens as aliens

aliens.main()
</file>

<file path="BERRY_INVENTORY_TASK_PLAN.md">
# Phase 1: Berry Inventory Management and Task Generation

**Goal:** Implement a system where the `TaskManager` checks the global inventory of Berries. If the total quantity of Berries across all `StoragePoint`s falls below a configurable threshold, and the number of active Berry gathering tasks is below a limit, a new `GatherAndDeliverTask` for Berries will be generated.

**Steps:**

1.  **Update Configuration (`src/core/config.py`):**
    *   Define new constants for Berry task generation:
        *   `MIN_BERRY_STOCK_LEVEL`: Integer, e.g., `50`. The minimum total berries desired across all storage.
        *   `BERRY_GATHER_TASK_QUANTITY`: Integer, e.g., `20`. The amount of berries a new task should aim to collect.
        *   `BERRY_GATHER_TASK_PRIORITY`: Integer, e.g., `5`. The priority for these auto-generated berry tasks.
        *   `MAX_ACTIVE_BERRY_GATHER_TASKS`: Integer, e.g., `3`. The maximum number of `GatherAndDeliverTask` for berries (both pending and assigned) that can exist simultaneously.

2.  **Enhance Resource Manager (`src/resources/manager.py`):**
    *   Implement a new method: `get_global_resource_quantity(self, resource_type: ResourceType) -> int`:
        *   This method will iterate through `self.storage_points`.
        *   For each `StoragePoint`, it will access its `stored_resources` dictionary.
        *   It will sum the quantity of the specified `resource_type` found in all storage points.
        *   It will return the total integer sum.

3.  **Modify Task Manager (`src/tasks/task_manager.py`):**
    *   Update the `_generate_tasks_if_needed(self)` method:
        *   Remove or comment out the existing example logic for generating berry tasks.
        *   **Berry Stock Check:**
            *   Call `self.resource_manager_ref.get_global_resource_quantity(ResourceType.BERRY)` to get the current total berry stock.
            *   Retrieve `config.MIN_BERRY_STOCK_LEVEL`, `config.MAX_ACTIVE_BERRY_GATHER_TASKS`, `config.BERRY_GATHER_TASK_QUANTITY`, and `config.BERRY_GATHER_TASK_PRIORITY`.
            *   If `current_berry_stock < config.MIN_BERRY_STOCK_LEVEL`:
                *   Count the number of existing `GatherAndDeliverTask` instances for `ResourceType.BERRY` in both `self.pending_tasks` and `self.assigned_tasks.values()`.
                *   If `current_active_berry_tasks < config.MAX_ACTIVE_BERRY_GATHER_TASKS`:
                    *   Call `self.create_gather_task()` with:
                        *   `resource_type=ResourceType.BERRY`
                        *   `quantity=config.BERRY_GATHER_TASK_QUANTITY`
                        *   `priority=config.BERRY_GATHER_TASK_PRIORITY`
                    *   Add a log message indicating a new berry task was generated due to low stock.

**Visual Plan (Mermaid Diagram):**

```mermaid
graph TD
    A[Start: TaskManager._generate_tasks_if_needed] --> B{Check Berry Stock};
    B --> C[Read config: MIN_BERRY_STOCK_LEVEL, MAX_ACTIVE_BERRY_GATHER_TASKS];
    C --> D[Call ResourceManager.get_global_resource_quantity(BERRY)];
    D -- global_berry_qty --> E{global_berry_qty < MIN_BERRY_STOCK_LEVEL?};
    E -- Yes --> F[Count active BERRY GatherTasks (pending & assigned)];
    F -- active_berry_task_count --> G{active_berry_task_count < MAX_ACTIVE_BERRY_GATHER_TASKS?};
    G -- Yes --> H[Read config: BERRY_GATHER_TASK_QUANTITY, BERRY_GATHER_TASK_PRIORITY];
    H --> I[Create new GatherAndDeliverTask for BERRIES];
    I --> J[Log Task Creation];
    J --> K[End];
    G -- No --> K;
    E -- No --> K;

    subgraph ResourceManager
        direction LR
        D1[get_global_resource_quantity] --> D2{Iterate self.storage_points};
        D2 --> D3[For each StoragePoint: sum sp.stored_resources[BERRY]];
        D3 --> D4[Return total_berry_quantity];
    end

    subgraph Config
        direction LR
        Cfg1[config.py]:::nofill;
        Cfg1 -.-> C;
        Cfg1 -.-> H;
    end
</file>

<file path="breakdown.md">
# Implementation Plan: Food-Themed Resource Chain Simulator

## Epic 1: Core Simulation Engine

### Slice 1.1: Functional Game Window

**Technical Implementation:**

1.  Create project structure with main script and module folders
2.  Initialize PyGame and configure display settings
3.  Implement fixed timestep game loop with separate update and render cycles
4.  Create simple grid visualization with configurable cell size
5.  Add basic input handling for window closing and keyboard controls
6.  Create Config class for simulation parameters
7.  Set up debug information display

**Testing Criteria:**

-   Window opens at specified resolution
-   Grid renders correctly with visible lines
-   Game loop maintains consistent simulation rate
-   Window responds to close command
-   FPS counter displays correctly

### Slice 1.2: Basic Resource Generation

**Technical Implementation:**

1.  Create ResourceNode base class with position, capacity, and generation rate
2.  Implement BerryBush subclass with appropriate visual representation
3.  Add resource accumulation logic tied to simulation ticks
4.  Create ResourceManager to track all resource nodes
5.  Implement visual representation of resources (size/color indicating quantity)
6.  Add resource collection point class for storing harvested resources

**Testing Criteria:**

-   Berry bushes appear on grid at specified locations
-   Resources accumulate at consistent rate based on simulation ticks
-   Visual indicators accurately reflect resource quantities
-   Resource generation respects maximum capacity
-   ResourceManager correctly tracks all resource nodes

## Epic 2: Agent Behavior System

### Slice 2.1: Agent Movement

**Technical Implementation:**

1.  Create Agent class with position, movement speed, and state machine
2.  Implement basic movement functions (move toward target, random movement)
3.  Create pathfinding for grid-based movement
4.  Add AgentManager to handle agent updates and rendering
5.  Implement agent state visualization (color coding based on current state)
6.  Create agent spawner function

**Testing Criteria:**

-   Agents appear on grid and move smoothly
-   Agents avoid obstacles and other agents
-   Movement speed is consistent with simulation rate
-   Agent states are visually distinguishable
-   Multiple agents can operate simultaneously

### Slice 2.2: Resource Collection

**Technical Implementation:**

1.  Expand agent state machine with gathering, carrying, and delivering states
2.  Implement resource detection (find nearest resource of specific type)
3.  Create gathering interaction (agent moves to resource, collects after delay)
4.  Add inventory system to agents for carrying resources
5.  Implement storage/dropoff points for collected resources
6.  Create visual feedback for resource collection

**Testing Criteria:**

-   Agents detect and move toward nearest available resource
-   Resources are removed from nodes when collected
-   Agents visually indicate when carrying resources
-   Resources are successfully delivered to storage
-   Collection has appropriate time delay

## Epic 3: Resource Processing Chain

### Slice 3.1: Basic Processing (Wheat to Flour)

**Technical Implementation:**

1.  Create WheatField resource node
2.  Implement ProcessingStation base class with input/output resource types
3.  Create Mill subclass that converts wheat to flour
4.  Add processing time and capacity constraints
5.  Implement agent logic for delivering resources to appropriate stations
6.  Create storage for processed resources

**Testing Criteria:**

-   Wheat fields generate wheat resources
-   Agents gather wheat and deliver to mill
-   Mill processes wheat into flour at specified rate
-   Flour is stored correctly
-   Processing stations show visual state (idle/processing)

### Slice 3.2: Complex Processing (Flour to Bread)

**Technical Implementation:**

1.  Add WaterSource resource node
2.  Create Bakery processing station that requires multiple inputs
3.  Implement recipe system for combining ingredients
4.  Add agent logic for gathering multiple resource types
5.  Implement priority system for resource collection
6.  Create bread storage and visualization

**Testing Criteria:**

-   Water sources generate water resources
-   Bakery requires both flour and water inputs
-   Agents collect required ingredients
-   Bread is produced according to recipe
-   Complete production chain operates without bottlenecks

## Epic 4: Player Interaction System

### Slice 4.1: Resource Display UI

**Technical Implementation:**

1.  Design UI panel layout for resource information
2.  Implement resource count display for all resource types
3.  Add simple production rate statistics
4.  Create resource flow visualization
5.  Implement UI manager for handling all UI elements

**Testing Criteria:**

-   UI displays accurate resource counts
-   Production statistics update correctly
-   UI remains responsive with simulation running
-   Information is clearly visible and well-organized

### Slice 4.2: Agent Control

**Technical Implementation:**

1.  Design priority selection UI elements
2.  Implement priority-based decision making for agents
3.  Create agent selection mechanism
4.  Add direct command functionality for selected agents
5.  Implement visual feedback for current agent assignments

**Testing Criteria:**

-   Changing priorities affects agent behavior
-   Selected agents are visually distinct
-   Direct commands override automatic behavior
-   UI clearly shows current priority settings
-   Agent behavior respects priority system

## Epic 5: System Balance and Polish

### Slice 5.1: Resource Balance

**Technical Implementation:**

1.  Create resource generation rate configuration system
2.  Implement processing time adjustment
3.  Add agent speed and capacity configuration
4.  Create metrics tracking for resource flow
5.  Implement dynamic balance adjustments based on performance

**Testing Criteria:**

-   Resources flow through system without major bottlenecks
-   All stations receive sufficient resources
-   End products are created at reasonable rate
-   System remains stable over extended run time
-   Configuration changes have expected effects

### Slice 5.2: State Visualization

**Technical Implementation:**

1.  Enhance color coding system for all entities
2.  Add simple animations for agent actions
3.  Implement hover information for resources and stations
4.  Create visual indicators for system bottlenecks
5.  Add optional debug visualization mode

**Testing Criteria:**

-   Entity states are clearly communicated visually
-   Animations provide clear feedback on actions
-   Hover information is accurate and helpful
-   System bottlenecks are easily identifiable
-   Visual clarity maintained with many active entities

## Development Approach

### Phase 1 (First Hour)

-   Complete Slice 1.1: Functional Game Window
-   Complete Slice 1.2: Basic Resource Generation
-   Start Slice 2.1: Agent Movement

### Phase 2 (Second Hour)

-   Complete Slice 2.1: Agent Movement
-   Complete Slice 2.2: Resource Collection
-   Start Slice 3.1: Basic Processing

### Phase 3 (Third Hour)

-   Complete Slice 3.1: Basic Processing
-   Start Slice 4.1: Resource Display UI
-   Start Slice 3.2: Complex Processing (if time permits)

### Phase 4 (Fourth Hour)

-   Complete remaining work on Slice 4.1 and/or 3.2
-   Implement Slice 4.2: Agent Control (if time permits)
-   Basic balancing and bug fixes

### Extension Points (Beyond Initial Scope)

-   Add agent needs system (hunger, rest)
-   Implement weather effects on resource generation
-   Add resource quality variations
-   Create more complex recipes and processing chains
-   Implement economic system with resource values
</file>

<file path="IMPLEMENTATION_PLAN_AGENT_ENHANCEMENTS.md">
# Implementation Plan: Agent Resource Gathering & Targeting Enhancements

This plan integrates the solutions for "Problem 1: Agents Gather Resources Even if Storage is Full" and "Problem 2: Multiple Agents Target the Same Resource Node" as detailed in [`RESOURCE_TARGET_PLAN.md`](RESOURCE_TARGET_PLAN.md).

## Phase 1: Enhance `ResourceNode` for Reservation

**File:** [`src/resources/node.py`](src/resources/node.py)

1.  **Add `is_targeted` attribute to `ResourceNode.__init__`:**
    *   Modify the `__init__` method to include `self.is_targeted: bool = False`.
    ```python
    # In src/resources/node.py, within the ResourceNode class:
    class ResourceNode(ABC):
        def __init__(self, position: pygame.Vector2, capacity: int, generation_rate: float, resource_type: ResourceType):
            # ... existing initializations ...
            self.current_quantity = 0.0
            
            # --- NEW ATTRIBUTE for reservation ---
            self.is_targeted: bool = False
    ```

2.  **Implement `claim(self) -> bool` method in `ResourceNode`:**
    *   Add the `claim` method as specified in [`RESOURCE_TARGET_PLAN.md#L166-L173`](RESOURCE_TARGET_PLAN.md:166).
    ```python
    # In src/resources/node.py, within the ResourceNode class:
    
        # --- NEW METHODS for reservation ---
        def claim(self) -> bool:
            """Attempts to claim this resource node. Returns True if successful, False otherwise."""
            if not self.is_targeted:
                self.is_targeted = True
                # print(f"DEBUG: Node {self.position} claimed.") # Optional debug
                return True
            # print(f"DEBUG: Node {self.position} FAILED to claim (already targeted).") # Optional debug
            return False
    ```

3.  **Implement `release(self)` method in `ResourceNode`:**
    *   Add the `release` method as specified in [`RESOURCE_TARGET_PLAN.md#L175-L181`](RESOURCE_TARGET_PLAN.md:175).
    ```python
    # In src/resources/node.py, within the ResourceNode class:
    
        def release(self):
            """Releases the claim on this resource node."""
            if self.is_targeted:
                self.is_targeted = False
                # print(f"DEBUG: Node {self.position} released.") # Optional debug
            # else:
                # print(f"DEBUG: Node {self.position} release called but was not targeted.") # Optional debug
    ```
    *   Ensure necessary imports like `pygame` and `ResourceType` are present (they appear to be already).

## Phase 2: Integrate Reservation and Pre-Gathering Checks into `Agent` Logic

**File:** [`src/agents/agent.py`](src/agents/agent.py)

1.  **Modify `_find_best_resource_target` method:**
    *   Integrate the logic from [`RESOURCE_TARGET_PLAN.md#L199-L249`](RESOURCE_TARGET_PLAN.md:199) to check `node.is_targeted` and call `node.claim()`.

2.  **Modify `Agent.update` method - `IDLE` state:**
    *   Replace the current `IDLE` state block with the refined logic from [`RESOURCE_TARGET_PLAN.md#L364-L433`](RESOURCE_TARGET_PLAN.md:364). This refined logic incorporates:
        *   Releasing any previous target if an agent unexpectedly returns to `IDLE`.
        *   Checking inventory: if not empty, transition to `CARRYING_RESOURCE`.
        *   If inventory is empty:
            *   Iterate through `self.resource_priorities`.
            *   For each `res_type_priority`:
                *   Get candidate nodes (available quantity, not `is_targeted`).
                *   Sort candidates by distance (optional, but good practice).
                *   For each `potential_node` in sorted candidates:
                    *   Call `self._can_find_dropoff_for_resource(potential_node.resource_type, 1, resource_manager)`.
                    *   If a drop-off exists, attempt `potential_node.claim()`.
                    *   If claimed successfully, this `potential_node` becomes `chosen_node_to_gather`. Break from loops.
            *   If `chosen_node_to_gather` is found:
                *   Set `self.target_resource_node = chosen_node_to_gather`.
                *   Set `self.target_position`.
                *   Change `self.state` to `AgentState.MOVING_TO_RESOURCE`.
            *   Else (no suitable raw resource found):
                *   Attempt to find a processed good to collect (e.g., `FLOUR_POWDER`), including a `_can_find_dropoff_for_resource` check for it.
                *   If successful, set target and state to `MOVING_TO_PROCESSOR`.
            *   Else (no tasks found):
                *   Change `self.state` to `AgentState.MOVING_RANDOMLY`.

3.  **Modify `Agent.update` method - Other State Transitions for Releasing Claims:**
    *   **`IDLE` state (entry):**
        *   As per [`RESOURCE_TARGET_PLAN.md#L262-L266`](RESOURCE_TARGET_PLAN.md:262) and refined logic [`RESOURCE_TARGET_PLAN.md#L366-L370`](RESOURCE_TARGET_PLAN.md:366). If `self.target_resource_node` exists, call `release()` and set it to `None`.
    *   **`MOVING_TO_RESOURCE` state:**
        *   As per [`RESOURCE_TARGET_PLAN.md#L284-L294`](RESOURCE_TARGET_PLAN.md:284).
        *   If `self.target_resource_node` is `None` or `self.target_position` is `None`: release node (if any), set state to `IDLE`.
        *   If `self.target_resource_node.current_quantity <= 0` (target depleted): release node, set state to `IDLE`.
    *   **`GATHERING_RESOURCE` state:**
        *   As per [`RESOURCE_TARGET_PLAN.md#L302-L332`](RESOURCE_TARGET_PLAN.md:302).
        *   If `self.target_resource_node` is `None`: set state to `IDLE`.
        *   If `self.target_resource_node.current_quantity <= 0` (depleted during gathering): release node, set state to `CARRYING_RESOURCE`.
        *   After gathering is complete (timer <= 0): release `self.target_resource_node`, set it to `None`, and transition to `CARRYING_RESOURCE`.

## Visual Plan: Mermaid Diagram

```mermaid
classDiagram
    class Agent {
        +state: AgentState
        +target_resource_node: Optional~ResourceNode~
        +resource_priorities: List~ResourceType~
        +current_inventory: Dict
        +update(dt, resource_manager)
        -_find_best_resource_target(resource_manager) Optional~ResourceNode~
        -_can_find_dropoff_for_resource(resource_type, quantity, resource_manager) bool
    }
    class ResourceNode {
        +position: Vector2
        +resource_type: ResourceType
        +current_quantity: float
        +is_targeted: bool  // New
        +claim() bool      // New
        +release()         // New
        +collect_resource(amount) int
    }
    class ResourceManager {
        +nodes: List~ResourceNode~
        +storage_points: List~StoragePoint~
        +processing_stations: List~ProcessingStation~
        +get_nodes_by_type(resource_type) List~ResourceNode~
        +get_nearest_station_accepting(position, resource_type) Optional~ProcessingStation~
        +get_stations_with_output(resource_type) List~ProcessingStation~
    }
    class StoragePoint {
        +can_accept(resource_type, quantity) bool
    }
    class ProcessingStation {
        +can_accept_input(resource_type, quantity) bool
        +has_output() bool
    }

    Agent --|> ResourceManager : uses
    Agent --|> ResourceNode : targets
    Agent --|> StoragePoint : uses for dropoff
    Agent --|> ProcessingStation : uses for dropoff/pickup
    ResourceManager o-- ResourceNode
    ResourceManager o-- StoragePoint
    ResourceManager o-- ProcessingStation

stateDiagram-v2
    [*] --> IDLE
    IDLE --> MOVING_TO_RESOURCE : Found & Claimed Node\nAND Dropoff Exists
    IDLE --> MOVING_TO_PROCESSOR : Found Output & Dropoff Exists
    IDLE --> CARRYING_RESOURCE : Has Inventory
    IDLE --> MOVING_RANDOMLY : No suitable task

    MOVING_TO_RESOURCE --> GATHERING_RESOURCE : Reached Node
    MOVING_TO_RESOURCE --> IDLE : Target Invalid (Release Node)
    
    GATHERING_RESOURCE --> CARRYING_RESOURCE : Finished/Interrupted (Release Node)
    GATHERING_RESOURCE --> IDLE : Target Invalid (Release Node)

    CARRYING_RESOURCE --> MOVING_TO_STORAGE : Found Storage
    CARRYING_RESOURCE --> MOVING_TO_PROCESSOR : Found Processor for Input
    CARRYING_RESOURCE --> IDLE : Inventory Empty
    CARRYING_RESOURCE --> MOVING_RANDOMLY : No Dropoff

    MOVING_TO_STORAGE --> DELIVERING_RESOURCE
    DELIVERING_RESOURCE --> IDLE : Delivered
    DELIVERING_RESOURCE --> CARRYING_RESOURCE : Delivery Failed/Partial

    MOVING_TO_PROCESSOR --> DELIVERING_TO_PROCESSOR : Reached (to deliver input)
    MOVING_TO_PROCESSOR --> COLLECTING_FROM_PROCESSOR : Reached (to collect output)
    MOVING_TO_PROCESSOR --> IDLE : Target Invalid

    DELIVERING_TO_PROCESSOR --> IDLE : Delivered
    DELIVERING_TO_PROCESSOR --> CARRYING_RESOURCE : Delivery Failed

    COLLECTING_FROM_PROCESSOR --> CARRYING_RESOURCE : Collected
    COLLECTING_FROM_PROCESSOR --> IDLE : Collection Failed
    
    MOVING_RANDOMLY --> IDLE : Reached Random Target
</file>

<file path="intelligent_agent_task_evaluation_plan.md">
# Intelligent Agent Task Evaluation Plan

This document outlines the plan to enhance the `Agent`'s task selection logic, ensuring they only attempt "jobs worth doing." This involves agents performing preliminary checks on task feasibility *before* claiming a task from the job board. This plan builds upon the existing "Job Board Task Management System."

## 1. Core Principle: "A Job Worth Doing"

An agent will consider a task (specifically a `GatherAndDeliverTask` for now) "worth doing" if it meets the following criteria *prior* to attempting a claim:

1.  **Resource Availability at Source:** There must be at least one accessible `ResourceNode` of the required type that currently has a minimum quantity of resources available (e.g., `current_quantity >= 1`).
2.  **Space at Dropoff:** There must be at least one accessible `StoragePoint` (or relevant `ProcessingStation`) that accepts the resource type and has available capacity for reservation/dropoff.
3.  **Agent's Inventory Compatibility & Capacity:**
    *   If the agent is carrying a *different* resource type than the task requires, it must have sufficient *remaining* inventory capacity to make the new task worthwhile.
    *   If the agent's inventory is full of a different resource, it should generally not pick a task for a new resource type unless specific conditions are met (e.g., high priority task, ability to discard current inventory - not planned for now).
4.  **Alignment with `resource_priorities`:** The task should align with the agent's defined `resource_priorities`, if any. Tasks matching priorities are preferred.

If a task fails any of these preliminary checks, the agent will not attempt to claim it at that moment and will continue evaluating other tasks or return to an idle/random movement state.

## 2. System Flow Diagram (Focus on Agent Evaluation)

```mermaid
sequenceDiagram
    participant A as Agent
    participant TM as TaskManager
    participant RM as ResourceManager

    A->>TM: Request available tasks (get_available_tasks())
    TM-->>A: List of posted tasks (jobBoardTasks)

    A->>A: Start _evaluate_and_select_task(jobBoardTasks, RM)
    loop for each task in jobBoardTasks
        A->>A: Check agent.resource_priorities (if any)
        alt Priority Match OR No Priorities
            A->>RM: Query: Has available sources for task.resource_type? (has_available_sources())
            RM-->>A: Boolean (sourcesAvailable)
            alt sourcesAvailable is true
                A->>RM: Query: Has available dropoffs for task.resource_type? (has_available_dropoffs())
                RM-->>A: Boolean (dropoffsAvailable)
                alt dropoffsAvailable is true
                    A->>A: Check own inventory compatibility & capacity
                    alt Inventory OK
                        A->>A: Task deemed "worth doing". Select this task.
                        Note over A: Break loop, proceed to claim.
                    else Inventory Not OK
                        Note over A: Continue to next task.
                    end
                else dropoffsAvailable is false
                     Note over A: Continue to next task.
                end
            else sourcesAvailable is false
                Note over A: Continue to next task.
            end
        else Priority Mismatch
            Note over A: Continue to next task.
        end
    end
    A->>A: End _evaluate_and_select_task() -> returns selectedTask or None

    alt selectedTask is not None
        A->>TM: Attempt to claim task (attempt_claim_task(selectedTask.task_id))
        TM-->>A: Claim success/failure
        Note over A: Proceed with prepare/execute or re-evaluate.
    else selectedTask is None
        Note over A: No "worth doing" task found. Return to IDLE/MOVING_RANDOMLY.
    end
```

## 3. Detailed Changes by Component

### 3.1. `Agent` (`agents/agent.py`)

*   **Modified `_evaluate_and_select_task(self, available_tasks: List['Task'], resource_manager: 'ResourceManager') -> Optional['Task']`:**
    *   This method will be significantly enhanced.
    *   It will iterate through `available_tasks`. For each `GatherAndDeliverTask`:
        1.  **Filter by `resource_priorities`:** If `self.resource_priorities` exist, tasks not matching these priorities might be skipped or considered lower preference.
        2.  **Check Source Availability:** Call a new `resource_manager.has_available_sources(task.resource_type_to_gather, min_quantity=1)` method. If `False`, skip this task.
        3.  **Check Dropoff Availability:** Call a new `resource_manager.has_available_dropoffs(task.resource_type_to_gather, min_capacity=1)` method. If `False`, skip this task.
        4.  **Check Agent Inventory:**
            *   If `self.current_inventory['quantity'] > 0` and `self.current_inventory['resource_type'] != task.resource_type_to_gather`:
                *   Check if `self.inventory_capacity - self.current_inventory['quantity']` is sufficient for a meaningful amount of `task.resource_type_to_gather`. If not, skip this task.
            *   If `self.current_inventory['quantity'] == self.inventory_capacity` and `self.current_inventory['resource_type'] != task.resource_type_to_gather`, skip this task (agent is full of something else).
        5.  If all checks pass, this task is a candidate. The agent might select the first such candidate, or if multiple candidates exist, it could use task priority (`task.priority`) or other heuristics (e.g., estimated proximity - future enhancement) to choose.
    *   If no task passes all checks, return `None`.
*   **`update()` method:**
    *   When `_evaluate_and_select_task()` returns `None`, the agent will transition to `MOVING_RANDOMLY` (or remain `IDLE` for a longer cooldown) before re-entering `EVALUATING_TASKS`. This ensures agents don't get stuck rapidly polling an empty/unsuitable job board.

### 3.2. `ResourceManager` (`resources/manager.py`)

*   **New Query Methods (Read-Only Checks):**
    *   `has_available_sources(self, resource_type: ResourceType, min_quantity: int = 1) -> bool`:
        *   Iterates through `self.nodes`.
        *   Returns `True` if any `ResourceNode` matches `resource_type` and has `current_quantity >= min_quantity` and is *not* currently claimed by another task (`claimed_by_task_id is None`).
        *   Returns `False` otherwise.
    *   `has_available_dropoffs(self, resource_type: ResourceType, min_capacity: int = 1) -> bool`:
        *   Iterates through `self.storage_points`.
        *   Returns `True` if any `StoragePoint` accepts `resource_type` and `get_available_capacity_for_reservation() >= min_capacity`.
        *   (Future: Could also check `ProcessingStation` input buffers if tasks involve delivering to them).
        *   Returns `False` otherwise.
    *   These methods are crucial for agents to make informed decisions without prematurely affecting the state of resources (i.e., without claiming or reserving).

### 3.3. `Task` (`tasks/task.py`) and `TaskManager` (`tasks/task_manager.py`)

*   No direct changes are anticipated for these components as part of *this specific plan*, as the focus is on the agent's pre-claim evaluation. However, the success rate of `Task.prepare()` should improve due to more intelligent agent pre-selection.
*   The `TaskManager` will continue to re-post tasks if `prepare()` or `execute_step()` still lead to a failure, but the frequency of such immediate re-postings due to initial conditions should decrease.

## 4. Benefits of This Refinement

*   **Reduced Wasted Agent Cycles:** Agents will spend less time attempting to claim and prepare tasks that are currently impossible (e.g., no resources available at source, no space at dropoff).
*   **More Realistic Agent Behavior:** Agents will appear more intelligent, idling or moving randomly when there are no genuinely viable jobs, rather than repeatedly failing.
*   **Improved System Performance (Potentially):** Fewer failed `prepare()` calls and less task churn (claim -> fail -> re-post -> re-claim) can lead to a more efficient simulation.
*   **Clearer Debugging:** When agents are idle, it will be more indicative of a genuine lack of "worthwhile" work in the simulation according to their defined criteria.

## 5. Next Steps (Implementation Order)

1.  Implement the new query methods (`has_available_sources`, `has_available_dropoffs`) in `ResourceManager`.
2.  Refactor `Agent._evaluate_and_select_task()` to incorporate the new evaluation criteria using the `ResourceManager` query methods and agent inventory checks.
3.  Test thoroughly to ensure agents correctly identify "worthwhile" tasks and behave as expected when no such tasks are available.

This plan focuses on making the agent's decision *before* claiming a task more robust.
</file>

<file path="job_board_task_system_plan.md">
# Job Board Task Management System Plan

This document outlines the plan to transition the current task management system to a "job board" model. In this model, the `TaskManager` posts available tasks, and `Agents` autonomously evaluate and select tasks to undertake. This approach aims to increase agent autonomy, system robustness, and flexibility in task handling.

## 1. Core Concepts

*   **Job Board:** A central repository (likely evolving from the current `TaskManager.pending_tasks` list) where all available tasks are posted.
*   **Agent-Driven Selection:** `Agents` will proactively query the job board, evaluate tasks based on their internal logic and current state, and decide which tasks to attempt.
*   **Task Claiming:** A mechanism for agents to "claim" a task from the job board, ensuring that a task is worked on by only one agent at a time.
*   **Resilient Failure Handling:** Failed tasks can be re-posted to the job board, potentially with modifications, allowing for re-attempts by the same or different agents.

## 2. System Flow Diagram

```mermaid
sequenceDiagram
    participant A as Agent
    participant TM as TaskManager
    participant RM as ResourceManager
    participant T as Task

    Note over A, TM: Agent becomes Idle
    A->>TM: Request available tasks (get_available_tasks())
    TM-->>A: List of posted tasks

    Note over A: Agent evaluates tasks (internal logic)
    alt Suitable task found
        A->>TM: Attempt to claim task (attempt_claim_task(task_id))
        TM->>TM: Verify task availability
        alt Task available
            TM-->>A: Task claimed successfully (assigned_task)
            A->>T: Prepare task (task.prepare(agent, RM))
            T-->>A: Preparation success/failure
            alt Preparation successful
                loop Task Execution
                    A->>T: Execute step (task.execute_step(agent, dt, RM))
                    T-->>A: Current task status
                end
                A->>TM: Report task outcome (report_task_outcome(task, status, agent))
                TM->>T: Cleanup task (task.cleanup(agent, RM, success))
                alt Task Failed & Re-postable
                    TM->>TM: Re-post task to job board
                end
            else Preparation failed
                A->>TM: Report task outcome (report_task_outcome(task, FAILED, agent))
                TM->>T: Cleanup task (task.cleanup(agent, RM, false))
                TM->>TM: Re-post task to job board (optional)
            end
        else Task not available (already claimed)
            TM-->>A: Task claim failed
            Note over A: Agent re-evaluates or returns to idle
        end
    else No suitable task found
        Note over A: Agent returns to idle/random movement
    end

    Note over TM, RM: TaskManager periodically generates new tasks
    TM->>TM: _generate_tasks_if_needed()
    TM->>TM: Add new tasks to job board (pending_tasks)
```

## 3. Detailed Changes by Component

### 3.1. `TaskManager` (`tasks/task_manager.py`)

*   **Task Posting:**
    *   Newly generated tasks (via `_generate_tasks_if_needed()`) will be added to the `pending_tasks` list, which now serves as the job board.
    *   Tasks on the board will have a status like `TaskStatus.PENDING` or a new `TaskStatus.POSTED`.
*   **New/Modified Methods:**
    *   `get_available_tasks() -> List[Task]`: Returns a list of tasks currently on the job board (from `pending_tasks`).
    *   `attempt_claim_task(task_id: uuid.UUID, agent: 'Agent') -> Optional[Task]`:
        *   Checks if the task with `task_id` is still in `pending_tasks`.
        *   If available, removes it from `pending_tasks`, assigns it to the `agent` (sets `task.agent_id`, adds to `assigned_tasks`), and returns the `Task`.
        *   If not available (e.g., already claimed), returns `None`.
    *   `report_task_outcome(task: Task, final_status: TaskStatus, agent: 'Agent')`:
        *   Will be enhanced to handle re-posting. If `final_status` is `FAILED` and the task is deemed re-postable, it will be added back to `pending_tasks` (possibly after a delay or with modifications).
*   **Deprecated Methods:**
    *   `request_task_for_agent()`: This method will be removed or its functionality significantly reduced, as agents will now pull tasks.
*   **`update()` Method:**
    *   May include logic to manage stale tasks on the job board (e.g., increase priority, modify, or eventually remove tasks that remain unclaimed for too long).

### 3.2. `Agent` (`agents/agent.py`)

*   **State Management:**
    *   A new `AgentState` will be introduced, e.g., `EVALUATING_TASKS`.
*   **Modified `update()` Logic:**
    *   When `self.current_task is None` and `self.state == AgentState.IDLE`:
        1.  Transition to `AgentState.EVALUATING_TASKS`.
        2.  Call `self.task_manager_ref.get_available_tasks()`.
        3.  Execute a new internal task evaluation method (see below).
        4.  If a suitable task is chosen, call `self.task_manager_ref.attempt_claim_task(chosen_task.task_id, self)`.
        5.  If `attempt_claim_task` is successful:
            *   Set `self.current_task` to the claimed task.
            *   Call `self.current_task.prepare(self, resource_manager)`.
            *   Handle the result of `prepare()` (proceed to execution or report failure).
        6.  If no task is chosen or claim fails, the agent might revert to `MOVING_RANDOMLY` or re-attempt evaluation after a delay.
*   **New Internal Method: `_evaluate_and_select_task(self, available_tasks: List['Task'], resource_manager: 'ResourceManager') -> Optional['Task']`:**
    *   This method will contain the agent's decision-making logic.
    *   It will iterate through `available_tasks` and evaluate them based on:
        *   **Task Type & Requirements:** Compatibility with agent capabilities.
        *   **Agent's `resource_priorities`**.
        *   **Agent's Current State:** `current_inventory` (capacity, type of resource carried).
        *   **Task Feasibility:** Proximity (estimated), perceived difficulty, availability of resources (preliminary check using `resource_manager`).
    *   Returns the selected `Task` object or `None` if no suitable task is found.
*   **`resource_priorities`:** This attribute will become central to the agent's task selection logic.

### 3.3. `Task` (`tasks/task.py`)

*   **Information for Evaluation:**
    *   Tasks might need to expose more summary information accessible before `prepare()` to aid agents in their evaluation. This could include:
        *   Target resource type(s).
        *   Target quantity.
        *   General location hints (if applicable, without requiring full `prepare()`-level resource locking).
    *   The `get_target_description()` method could be enhanced, or new properties added.
*   **`prepare()` Method:**
    *   Remains critical for detailed validation, resource claiming, and reservation *after* an agent has claimed the task. If `prepare()` fails, the task is reported as failed to the `TaskManager`, which may then re-post it.

### 3.4. `TaskStatus` (`tasks/task_types.py`)

*   **New Status (Optional):** Consider adding `POSTED` to explicitly indicate tasks on the job board, distinct from `PENDING` (which might mean created but not yet ready for the board). Alternatively, `PENDING` can continue to serve this role.
*   **Lifecycle:** The status lifecycle will need to accommodate tasks returning to the job board after a failure (e.g., `FAILED` -> `POSTED`/`PENDING`).

## 4. Benefits

*   **Increased Agent Autonomy:** Agents make more decisions about their work.
*   **Decentralization:** Reduces the `TaskManager`'s role as a direct assigner.
*   **Improved Robustness & Resilience:** Failed tasks are not necessarily lost. They can be re-attempted by other agents or the same agent under different conditions, making the system more tolerant to transient issues (e.g., a resource node being temporarily depleted or claimed).
*   **Flexibility:** The system can adapt better to varying numbers of agents or agents with different specializations or efficiencies.

## 5. Potential Challenges & Considerations

*   **Increased Complexity:** Agent logic for task evaluation will be more sophisticated. The `TaskManager` also gains new responsibilities for managing the job board and re-posting logic.
*   **Task Starvation:** Some tasks might remain on the board if no agent deems them suitable. The `TaskManager.update()` might need logic to escalate the priority of, modify, or eventually expire such tasks.
*   **Concurrency in Claiming:** The `attempt_claim_task` method in `TaskManager` must be robust to handle near-simultaneous claims for the same task, ensuring only one agent successfully claims it.
*   **Performance:** Frequent querying of the job board by many agents could have performance implications if not managed efficiently.
*   **Agent Oscillation:** Agents might repeatedly pick up and drop tasks if evaluation criteria are not well-defined or if the environment changes rapidly.

This plan provides a foundational architecture for the job board system. Further refinement of agent evaluation heuristics and `TaskManager` policies for re-posting and managing stale tasks will be necessary during implementation.
</file>

<file path="project.md">
# Pastorial
A simple resource chain simulator with autonomous agents that gather and process food resources. Agents move between berry bushes, wheat fields, and processing stations to create a production chain from raw materials to finished goods. Players can influence agent behavior by setting priorities.

 ### Core Features
 - Simulation environment with resource nodes
 - Autonomous agents with basic AI
 - Linear resource processing chain
 - Simple UI for resource tracking
 - Basic player controls for agent priorities

 ### Implementation Plan

 - Follow the vertical slices outlined previously
 - Start with minimal viable implementations
 - Focus on core game loop and agent behavior first

 ### Success Criteria

 - Agents autonomously gather and process resources
 - Complete production chain functions
 - Simulation runs without crashing for at least 5 minutes
 - Player can influence agent behavior

 ## Project Implementation Plan
  - Detailed plan found a ./breakdown.md

Setup PyGame with fixed timestep loop 
Create resource nodes and visualization

Berry bushes, wheat fields, water sources
Simple colored circles with resource counts

Implement basic agent behavior system 

Movement and state machine
Basic decision making for resource gathering

Create processing stations 

Mill (wheat  flour)
Bakery (flour + water  bread)

Implement player controls 

Priority settings
Direct commands


Add UI for resources and status
Testing and balancing
</file>

<file path="RESOURCE_TARGET_PLAN.md">
Problem 1: Agents Gather Resources Even if Storage is Full
Recommended Solution: Pre-Gathering Storage Check

This involves modifying the agent's decision-making process to ensure a valid drop-off location exists before committing to gather a resource.

1. Modify Agent class (agents/agent.py)
1.1. New Helper Method: _can_find_dropoff_for_resource(self, resource_type: ResourceType, quantity_to_check: int, resource_manager) -> bool
This method will check if there's any suitable storage or processing station that can accept the given resource type.

Python

# Add this method to the Agent class in agents/agent.py

    def _can_find_dropoff_for_resource(self, resource_type: ResourceType, quantity_to_check: int, resource_manager) -> bool:
        """
        Checks if a suitable drop-off (StoragePoint or ProcessingStation) exists
        for the given resource type and quantity without assigning it as a target.
        """
        # Check for StoragePoints
        try:
            candidate_storages = resource_manager.storage_points
            for storage_point in candidate_storages:
                if hasattr(storage_point, 'can_accept') and \
                   storage_point.can_accept(resource_type, quantity_to_check):
                    # print(f"DEBUG: Agent {self.position} found potential storage for {resource_type.name} at {storage_point.position}")
                    return True
        except AttributeError:
            print(f"Warning: resource_manager missing 'storage_points' during dropoff check. Agent: {self.position}")
            # Fall through to check processing stations if applicable

        # Check for ProcessingStations (if the resource is an input for any)
        # This logic assumes raw resources might go to processing stations.
        # If only specific resources (e.g., WHEAT to Mill) are processed, this check needs to be more specific.
        if resource_type == ResourceType.WHEAT: # Example: Only WHEAT is processed
            try:
                # Check if any station accepts this input type and has capacity
                # We don't need the *nearest* here, just *any* station.
                for station in resource_manager.processing_stations:
                    if station.accepted_input_type == resource_type and \
                       station.can_accept_input(resource_type, quantity_to_check):
                        # print(f"DEBUG: Agent {self.position} found potential processing for {resource_type.name} at {station.position}")
                        return True
            except AttributeError:
                print(f"Warning: resource_manager missing 'processing_stations' during dropoff check. Agent: {self.position}")

        # print(f"DEBUG: Agent {self.position} could NOT find dropoff for {resource_type.name}")
        return False
1.2. Modify Agent.update method (IDLE state logic)
The IDLE state logic needs to incorporate the _can_find_dropoff_for_resource check.

Python

# In agents/agent.py, within the Agent class:
# Modify the 'update' method, specifically the 'AgentState.IDLE' block:

    def update(self, dt: float, resource_manager):
        # ... (other parts of the update method remain the same) ...

        if self.state == AgentState.IDLE:
            if self.current_inventory['quantity'] > 0:
                self.state = AgentState.CARRYING_RESOURCE
                print(f"Agent {self.position} IDLE (has inventory) -> CARRYING_RESOURCE")
            else: # Inventory is empty
                # Find the best resource node *that also has a valid drop-off point*
                best_node_with_dropoff: Optional[ResourceNode] = None
                min_dist_sq_for_best_node = math.inf

                # Iterate through resource priorities to find a suitable task
                for res_type_priority in self.resource_priorities:
                    try:
                        candidate_nodes = resource_manager.get_nodes_by_type(res_type_priority)
                    except AttributeError:
                        print(f"Warning: resource_manager missing 'get_nodes_by_type'. Agent: {self.position}")
                        continue # Try next priority

                    potential_target_node_for_priority: Optional[ResourceNode] = None
                    min_dist_sq_for_priority_node = math.inf

                    for node in candidate_nodes:
                        if (hasattr(node, 'current_quantity') and int(node.current_quantity) >= 1 and
                            hasattr(node, 'resource_type') and node.resource_type == res_type_priority and
                            hasattr(node, 'position')):
                            
                            # --- MODIFICATION START: Check for drop-off feasibility ---
                            # Assume agent will try to gather at least 1 unit, or up to capacity
                            # For a simpler check, we can assume they'll gather 1 unit.
                            # A more complex check could estimate potential gather amount.
                            # For now, let's check if a drop-off exists for this resource type for a nominal quantity (e.g., 1)
                            if self._can_find_dropoff_for_resource(node.resource_type, 1, resource_manager):
                                dist_sq = (node.position - self.position).length_squared()
                                if dist_sq < min_dist_sq_for_priority_node:
                                    min_dist_sq_for_priority_node = dist_sq
                                    potential_target_node_for_priority = node
                            # --- MODIFICATION END ---
                    
                    if potential_target_node_for_priority:
                        # Found the best node for this priority that has a drop-off
                        # Now compare if this is better than a node from a higher priority (if any was found)
                        # Since we iterate through priorities, the first one found is the highest priority
                        best_node_with_dropoff = potential_target_node_for_priority
                        break # Found a suitable node for the current highest feasible priority

                if best_node_with_dropoff:
                    self.target_resource_node = best_node_with_dropoff
                    self.target_position = pygame.math.Vector2(self.target_resource_node.position)
                    self.state = AgentState.MOVING_TO_RESOURCE
                    print(f"DEBUG: Agent.update (IDLE -> MOVING_TO_RESOURCE): AgentGridPos={self.position}, TargetNodePos(resource)={self.target_resource_node.position} (Dropoff exists for {self.target_resource_node.resource_type.name})")
                else:
                    # No raw resources found with valid drop-offs.
                    # Check if we should collect processed goods (existing logic).
                    self.target_processing_station = self._find_best_station_with_output(resource_manager, ResourceType.FLOUR_POWDER)
                    if self.target_processing_station:
                        # Before moving to collect, ensure there's storage for what we are about to collect
                        if self._can_find_dropoff_for_resource(ResourceType.FLOUR_POWDER, 1, resource_manager):
                            self.target_position = pygame.math.Vector2(self.target_processing_station.position)
                            self.state = AgentState.MOVING_TO_PROCESSOR # Moving to collect output
                            print(f"DEBUG: Agent.update (IDLE -> MOVING_TO_PROCESSOR to collect FLOUR_POWDER): AgentGridPos={self.position}, TargetStationPos={self.target_processing_station.position} (Dropoff exists for FLOUR_POWDER)")
                        else:
                            print(f"Agent {self.position} found FLOUR_POWDER to collect but no place to store it. Moving randomly.")
                            self.state = AgentState.MOVING_RANDOMLY
                    else:
                        self.state = AgentState.MOVING_RANDOMLY
                        print(f"Agent {self.position} IDLE -> MOVING_RANDOMLY (no resources with dropoffs or flour to collect with dropoff)")
        
        # ... (rest of the update method logic for other states) ...
Explanation of Changes for Problem 1:

The _can_find_dropoff_for_resource method is introduced to encapsulate the logic of checking StoragePoints and relevant ProcessingStations for their can_accept capability for a given resource type.
In the IDLE state of Agent.update:
When an agent is looking for a raw resource node, it iterates through its resource_priorities.
For each candidate ResourceNode, it now calls self._can_find_dropoff_for_resource(node.resource_type, 1, resource_manager) to verify that a drop-off exists for the type of resource the node provides.
Only if such a drop-off exists will the node be considered a valid target.
A similar check is added before deciding to collect processed goods (e.g., FLOUR_POWDER from a Mill).
Problem 2: Multiple Agents Target the Same Resource Node
Recommended Solution: Resource Node Reservation/Targeting Flags

This involves adding a way for agents to "claim" a resource node they are targeting, so other agents will ignore it.

1. Modify ResourceNode class (resources/node.py)
1.1. Add New Attributes and Methods
Python

# In resources/node.py, within the ResourceNode class:

from abc import ABC, abstractmethod
import pygame # Ensure pygame is imported if not already for Vector2
from ..resources.resource_types import ResourceType # Import ResourceType

class ResourceNode(ABC):
    def __init__(self, position: pygame.Vector2, capacity: int, generation_rate: float, resource_type: ResourceType):
        if not isinstance(position, pygame.Vector2):
            raise TypeError("Position must be a pygame.Vector2")
        self.position = position
        self.capacity = int(capacity)
        self.generation_rate = generation_rate
        self.resource_type = resource_type
        self.current_quantity = 0.0
        
        # --- NEW ATTRIBUTE for reservation ---
        self.is_targeted: bool = False 
        # self.targeted_by_agent_id: Optional[int] = None # Alternative if you have agent IDs

    # ... (update method remains the same) ...

    # --- NEW METHODS for reservation ---
    def claim(self) -> bool:
        """Attempts to claim this resource node. Returns True if successful, False otherwise."""
        if not self.is_targeted:
            self.is_targeted = True
            # print(f"DEBUG: Node {self.position} claimed.")
            return True
        # print(f"DEBUG: Node {self.position} FAILED to claim (already targeted).")
        return False

    def release(self):
        """Releases the claim on this resource node."""
        if self.is_targeted:
            self.is_targeted = False
            # print(f"DEBUG: Node {self.position} released.")
        # else:
            # print(f"DEBUG: Node {self.position} release called but was not targeted.")


    @abstractmethod
    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid):
        pass

    def collect_resource(self, amount_to_collect: int) -> int:
        # ... (existing collect_resource logic) ...
2. Modify Agent class (agents/agent.py)
2.1. Modify _find_best_resource_target method
This method needs to check the is_targeted flag and claim the node.

Python

# In agents/agent.py, within the Agent class:
# Modify the '_find_best_resource_target' method:

    def _find_best_resource_target(self, resource_manager) -> Optional[ResourceNode]:
        best_node_choice: Optional[ResourceNode] = None
        min_dist_sq = math.inf

        for res_type in self.resource_priorities:
            try:
                candidate_nodes = resource_manager.get_nodes_by_type(res_type)
            except AttributeError:
                print(f"Warning: resource_manager missing 'get_nodes_by_type'. Agent: {self.position}")
                return None

            for node in candidate_nodes:
                # --- MODIFICATION START: Check if node is targeted and has quantity ---
                if (hasattr(node, 'current_quantity') and int(node.current_quantity) >= 1 and
                    hasattr(node, 'resource_type') and node.resource_type == res_type and
                    hasattr(node, 'position') and
                    hasattr(node, 'is_targeted') and not node.is_targeted): # Check if not already targeted
                    # --- MODIFICATION END ---
                    
                    # This is where the Pre-Gathering Storage Check (from Problem 1) should also be integrated
                    # if you want _find_best_resource_target to be the sole decision point.
                    # For clarity, the solution for Problem 1 was placed in the Agent.update's IDLE state directly.
                    # If you prefer it here, you'd call self._can_find_dropoff_for_resource here.
                    # For now, assuming the IDLE state handles the dropoff check before calling this.
                    # OR, if this method is called by the IDLE state's new logic, this check here is fine.

                    dist_sq = (node.position - self.position).length_squared()
                    if dist_sq < min_dist_sq:
                        min_dist_sq = dist_sq
                        best_node_choice = node
            
            if best_node_choice: # Found a suitable node for this priority
                # --- MODIFICATION: Attempt to claim the chosen node ---
                if best_node_choice.claim():
                    print(f"DEBUG: Agent._find_best_resource_target: AgentGridPos={self.position} found and CLAIMED best resource: {best_node_choice.resource_type.name} at NodePos={best_node_choice.position}")
                    return best_node_choice
                else:
                    # Claim failed (race condition, another agent claimed it just now)
                    print(f"DEBUG: Agent._find_best_resource_target: AgentGridPos={self.position} found resource {best_node_choice.position} but FAILED to claim. Re-evaluating.")
                    best_node_choice = None # Reset and continue search for other nodes or lower priorities
                    min_dist_sq = math.inf # Reset min_dist for this priority to re-evaluate other nodes
                    # Potentially restart search for this res_type or continue to next node in this res_type list
                    # For simplicity, let's just nullify and let the outer loop continue,
                    # or the next priority be checked.
                    # A more robust solution might re-scan nodes of the current priority.
                    # However, with the current loop structure, it will naturally look at other nodes for this priority
                    # or move to the next priority if this was the last suitable one.
        
        if not best_node_choice: # Fallback if loop completed without claiming a node
            print(f"Agent at {self.position} found no suitable AND claimable resource target.")
        return best_node_choice # Returns None if no claimable node was found
2.2. Modify Agent.update method for state transitions (releasing claims)
Ensure nodes are released when the agent is done with them or changes its mind.

Python

# In agents/agent.py, within the Agent class:
# Modify the 'update' method in various states:

    def update(self, dt: float, resource_manager):
        # ...
        if self.state == AgentState.IDLE:
            # ... (logic as modified for Problem 1) ...
            # Ensure any previous target_resource_node is released if an agent becomes IDLE unexpectedly
            if self.target_resource_node and hasattr(self.target_resource_node, 'release'):
                print(f"DEBUG: Agent {self.position} becoming IDLE, releasing previous target {self.target_resource_node.position}")
                self.target_resource_node.release()
                self.target_resource_node = None # Clear it
            
            # ... (rest of IDLE logic to find new target) ...
            # If after all checks, a new target_resource_node is set in IDLE (e.g., by _find_best_resource_target called within IDLE's new logic)
            # it should have already been claimed by _find_best_resource_target.
            # The assignment of self.target_resource_node happens in the IDLE state based on the output of _find_best_resource_target
            # (or similar logic as shown in Problem 1's solution).

            # The original line: self.target_resource_node = self._find_best_resource_target(resource_manager)
            # is now integrated into the more complex decision logic in IDLE for Problem 1.
            # Let's assume `best_node_with_dropoff` from Problem 1's solution IS the result of a find-and-claim attempt.
            # If `best_node_with_dropoff` is set:
            #   self.target_resource_node = best_node_with_dropoff # It was already claimed if found
            #   ... set state to MOVING_TO_RESOURCE ...

        # ...

        elif self.state == AgentState.MOVING_TO_RESOURCE:
            if not self.target_resource_node or not self.target_position:
                # --- MODIFICATION: Release if target becomes invalid ---
                if self.target_resource_node and hasattr(self.target_resource_node, 'release'):
                    self.target_resource_node.release()
                self.state = AgentState.IDLE; self.target_resource_node = None; return

            if self.target_resource_node.current_quantity <= 0: # Target depleted
                # --- MODIFICATION: Release if target depleted ---
                if hasattr(self.target_resource_node, 'release'):
                    self.target_resource_node.release()
                self.state = AgentState.IDLE; self.target_resource_node = None; self.target_position = None; return
            
            if self._move_towards_target(dt):
                self.state = AgentState.GATHERING_RESOURCE
                self.gathering_timer = config.DEFAULT_GATHERING_TIME
                self.target_position = None
                # Node remains claimed while gathering

        elif self.state == AgentState.GATHERING_RESOURCE:
            if not self.target_resource_node:
                # --- MODIFICATION: Release if target lost (should ideally not happen if claimed) ---
                # This implies an external change or an issue. If it had a target, it should be released.
                # However, target_resource_node should still be set here from MOVING_TO_RESOURCE.
                # For safety, we could add a check and release, but let's assume it's set.
                self.state = AgentState.IDLE; return # Go to IDLE to re-evaluate

            if self.target_resource_node.current_quantity <= 0: # Depleted during gathering
                # --- MODIFICATION: Release after attempting to gather from depleted node ---
                if hasattr(self.target_resource_node, 'release'):
                    self.target_resource_node.release()
                self.state = AgentState.CARRYING_RESOURCE; self.target_resource_node = None; self.gathering_timer = 0; return
            
            self.gathering_timer -= dt
            if self.gathering_timer <= 0:
                amount_to_gather = self.inventory_capacity - self.current_inventory['quantity']
                if amount_to_gather > 0:
                    node_resource_type = getattr(self.target_resource_node, 'resource_type', None)
                    if node_resource_type and (self.current_inventory['resource_type'] is None or self.current_inventory['resource_type'] == node_resource_type):
                        gathered_amount = self.target_resource_node.collect_resource(amount_to_gather)
                        if gathered_amount > 0:
                            self.current_inventory['resource_type'] = node_resource_type
                            self.current_inventory['quantity'] += gathered_amount
                            print(f"Agent {self.position} gathered {gathered_amount} of {node_resource_type.name}")
                
                # --- MODIFICATION: Release node after gathering is complete (or attempted) ---
                if hasattr(self.target_resource_node, 'release'):
                    self.target_resource_node.release()
                self.state = AgentState.CARRYING_RESOURCE
                self.target_resource_node = None # Clear the reference

        # ... (other states) ...

        # IMPORTANT: Ensure that if an agent is "reset" or "dies" (if such mechanics exist or are planned),
        # any claimed resource node is released. This might require a cleanup method on the agent
        # or the AgentManager handling such events.
Explanation of Changes for Problem 2:

ResourceNode:
Gains an is_targeted boolean attribute (default False).
claim(): Sets is_targeted to True if it wasn't already. Returns success/failure.
release(): Sets is_targeted to False.
Agent:
_find_best_resource_target:
Filters out nodes where node.is_targeted is True.
If a suitable, untargeted node is found, it calls node.claim(). Only if the claim is successful does the agent select this node. This handles potential race conditions where two agents might see the same node as free almost simultaneously.
update method (State Transitions):
IDLE: If an agent becomes IDLE and previously had a target_resource_node (e.g., task interrupted), that node is released. The process of finding a new target resource node (as detailed in Problem 1 solution) should incorporate the claim mechanism (e.g., the _find_best_resource_target called from IDLE's logic will attempt the claim).
MOVING_TO_RESOURCE: If the target node becomes invalid (e.g., disappears or is depleted before arrival), it's released.
GATHERING_RESOURCE: The node is released once gathering is finished (or if it's found to be depleted upon starting to gather, or if inventory fills up).
The agent no longer holds a claim on the target_resource_node once it transitions to CARRYING_RESOURCE.
Integration Note for Problem 1 & 2:

The solution for Problem 1 (Pre-Gathering Storage Check) modifies the agent's decision process in the IDLE state before it even calls _find_best_resource_target (or, _find_best_resource_target could be adapted to include this check). The solution for Problem 2 (Reservation) modifies _find_best_resource_target itself to handle claiming.

You'll need to ensure these two pieces of logic work together smoothly. The IDLE state logic from Problem 1's solution should now call the modified _find_best_resource_target (from Problem 2's solution) which handles both finding a non-targeted node AND attempting to claim it.

Refined Agent.update IDLE state (combining concepts):

Python

# In agents/agent.py, Agent.update, IDLE state:
        if self.state == AgentState.IDLE:
            # Release any previous target if unexpectedly returning to IDLE
            if self.target_resource_node and hasattr(self.target_resource_node, 'release'):
                print(f"DEBUG: Agent {self.position} becoming IDLE, releasing previous target {self.target_resource_node.position if self.target_resource_node else 'None'}")
                self.target_resource_node.release()
                self.target_resource_node = None

            if self.current_inventory['quantity'] > 0:
                self.state = AgentState.CARRYING_RESOURCE
                print(f"Agent {self.position} IDLE (has inventory) -> CARRYING_RESOURCE")
            else: # Inventory is empty
                # Try to find a raw resource to collect first
                # _find_best_resource_target now handles checking 'is_targeted' and claiming.
                # We also need to ensure _can_find_dropoff_for_resource is checked for its type.

                # New approach for IDLE: Iterate priorities, for each find node, check dropoff, then try to claim.
                chosen_node_to_gather: Optional[ResourceNode] = None
                for res_type_priority in self.resource_priorities:
                    # Get all nodes of this type (that are not already targeted and have quantity)
                    # This part of logic is somewhat duplicated from _find_best_resource_target,
                    # suggesting _find_best_resource_target could be refactored or called differently.
                    # For this guide, let's keep it explicit here for clarity of the combined logic.
                    
                    candidate_nodes_for_priority = []
                    try:
                        all_nodes_of_type = resource_manager.get_nodes_by_type(res_type_priority)
                        for node in all_nodes_of_type:
                            if (hasattr(node, 'current_quantity') and int(node.current_quantity) >= 1 and
                                hasattr(node, 'is_targeted') and not node.is_targeted):
                                candidate_nodes_for_priority.append(node)
                    except AttributeError:
                        continue # Next priority

                    # Sort them by distance (optional, but good for "best")
                    candidate_nodes_for_priority.sort(key=lambda n: (n.position - self.position).length_squared())

                    for potential_node in candidate_nodes_for_priority:
                        if self._can_find_dropoff_for_resource(potential_node.resource_type, 1, resource_manager):
                            # Now, try to claim this node
                            if potential_node.claim():
                                chosen_node_to_gather = potential_node
                                break # Found and claimed a node
                            # Else: claim failed, try next potential_node
                    if chosen_node_to_gather:
                        break # Found and claimed a node for this priority, move on

                if chosen_node_to_gather:
                    self.target_resource_node = chosen_node_to_gather
                    self.target_position = pygame.math.Vector2(self.target_resource_node.position)
                    self.state = AgentState.MOVING_TO_RESOURCE
                    print(f"DEBUG: Agent.update (IDLE -> MOVING_TO_RESOURCE): AgentGridPos={self.position}, Claimed TargetNodePos={self.target_resource_node.position} (Dropoff exists for {self.target_resource_node.resource_type.name})")
                else:
                    # No raw resources found that meet all criteria (available, not targeted, has dropoff, claimable)
                    # Fallback to existing logic for collecting processed goods (which also needs dropoff check)
                    self.target_processing_station = self._find_best_station_with_output(resource_manager, ResourceType.FLOUR_POWDER)
                    if self.target_processing_station:
                        if self._can_find_dropoff_for_resource(ResourceType.FLOUR_POWDER, 1, resource_manager): # Check dropoff for flour
                             # Note: Processing stations do not have a claim mechanism in this example.
                             # If multiple agents target the same station output, it's first-come, first-served.
                            self.target_position = pygame.math.Vector2(self.target_processing_station.position)
                            self.state = AgentState.MOVING_TO_PROCESSOR 
                            print(f"DEBUG: Agent.update (IDLE -> MOVING_TO_PROCESSOR to collect FLOUR_POWDER): TargetStationPos={self.target_processing_station.position}")
                        else:
                            self.state = AgentState.MOVING_RANDOMLY
                            print(f"Agent {self.position} IDLE -> MOVING_RANDOMLY (found flour but no dropoff)")
                    else:
                        self.state = AgentState.MOVING_RANDOMLY
                        print(f"Agent {self.position} IDLE -> MOVING_RANDOMLY (no suitable tasks)")

This refined IDLE state logic is more complex but integrates both checks: ensuring a drop-off exists AND successfully claiming an un-targeted resource node. You might consider further refactoring _find_best_resource_target to better fit into this flow or to encapsulate more of this combined logic. For instance, _find_best_resource_target could take resource_manager and the resource_type as arguments and return the best claimable node of that type, or None. The IDLE state would then loop priorities, call this refined finder, and then do the drop-off check.

This detailed guide should provide a solid foundation for implementing these improvements. Remember to test thoroughly after each set of changes.
</file>

<file path="SLICE_1.1_PLAN.md">
# Refined Plan: Epic 1, Slice 1.1 - Functional Game Window

**Goal:** Create a functional Pygame window with a basic grid, fixed timestep loop, configuration management, basic input handling, and an FPS debug display.

**Project Structure:**

```mermaid
graph TD
    A[pastorial/] --> B(main.py);
    A --> C(src/);
    C --> D(core/);
    D --> D1(__init__.py);
    D --> D2(config.py);
    D --> D3(game_loop.py);
    C --> E(rendering/);
    E --> E1(__init__.py);
    E --> E2(grid.py);
    E --> E3(debug_display.py);
    C --> F(input/);
    F --> F1(__init__.py);
    F --> F2(handlers.py);
```

**Refined Implementation Steps:**

1.  **Create Project Structure:** Set up the directories (`src/core`, `src/rendering`, `src/input`) and files (`main.py`, `src/core/__init__.py`, `src/core/config.py`, `src/core/game_loop.py`, etc.) as shown in the diagram.
2.  **Initialize Pygame & Config:**
    *   In `src/core/config.py`, define initial constants like `SCREEN_WIDTH`, `SCREEN_HEIGHT`, `TARGET_FPS`, `GRID_CELL_SIZE`, `GRID_COLOR`.
    *   In `main.py`, initialize Pygame and create the display surface using values from `config.py`.
3.  **Implement Fixed Timestep Loop:**
    *   Create the game loop logic (handling input, updates, rendering, and time delta) in `src/core/game_loop.py`.
    *   Instantiate and run the loop from `main.py`.
4.  **Create Grid Visualization:**
    *   Implement a function in `src/rendering/grid.py` to draw a grid based on `config.py` settings (cell size, color).
    *   Call this drawing function during the render phase of the game loop in `main.py`.
5.  **Add Basic Input Handling:**
    *   Implement a function in `src/input/handlers.py` to check for the `pygame.QUIT` event.
    *   Call this function during the input handling phase of the game loop in `main.py` to allow closing the window.
6.  **Set Up Debug Information:**
    *   Implement functions in `src/rendering/debug_display.py` to calculate and render the current FPS.
    *   Call this during the render phase of the game loop in `main.py`.

**Testing Criteria (Confirm Success):**

*   Window opens at the resolution defined in `config.py`.
*   The grid is drawn correctly using the specified cell size and color.
*   The game loop runs, and the FPS counter displays a value close to `TARGET_FPS`.
*   The window closes cleanly when the close button is clicked.
</file>

<file path="SLICE_1.2_PLAN.md">
# Plan for Epic 1, Slice 1.2: Basic Resource Generation

**Goal:** Implement resource nodes (Berry Bushes) that generate resources over time and are visually represented on the grid.

**Technical Implementation Steps:**

1.  **Create `src/resources` Directory:** If it doesn't exist, create a new directory `src/resources` to hold resource-related code. Create `__init__.py` inside it.
2.  **Define `ResourceNode` Base Class (`src/resources/node.py`):**
    *   Create a base class `ResourceNode`.
    *   Attributes: `position` (tuple/Vector2), `capacity` (int), `current_resources` (int/float), `generation_rate` (float, resources per tick/second).
    *   Methods:
        *   `__init__(self, position, capacity, generation_rate)`: Initialize attributes.
        *   `update(self, dt)`: Abstract method or base implementation to increment `current_resources` based on `generation_rate` and `dt` (delta time from the game loop), capped by `capacity`.
        *   `draw(self, surface, font)`: Abstract method for drawing.
        *   `collect(self, amount)`: Method to decrease `current_resources` when collected (will be used in later slices).
3.  **Implement `BerryBush` Subclass (`src/resources/berry_bush.py`):**
    *   Create `BerryBush` class inheriting from `ResourceNode`.
    *   `__init__`: Call parent `__init__`, potentially set specific default capacity/rate for berries.
    *   `update`: Implement the resource accumulation logic if not fully done in the base class.
    *   `draw`: Implement drawing logic:
        *   Draw a green square at the node's `position`. Use `config.py` for color and potentially size.
        *   Render the `current_resources` count as text overlayed on the square. Requires a `pygame.font.Font` object passed in.
4.  **Create `ResourceManager` (`src/resources/manager.py`):**
    *   Create `ResourceManager` class.
    *   Attributes: `nodes` (list to store `ResourceNode` instances).
    *   Methods:
        *   `__init__(self)`: Initialize the empty `nodes` list.
        *   `add_node(self, node)`: Add a resource node instance to the list.
        *   `update_nodes(self, dt)`: Iterate through `self.nodes` and call each node's `update(dt)` method.
        *   `draw_nodes(self, surface, font)`: Iterate through `self.nodes` and call each node's `draw(surface, font)` method.
5.  **Integrate into Core Game (`main.py` / `src/core/game_loop.py`):**
    *   Import necessary classes (`ResourceManager`, `BerryBush`, `Config`, `random`, `pygame`).
    *   Initialize Pygame Font module (`pygame.font.init()`) and create a font object.
    *   Instantiate `ResourceManager`.
    *   In the setup phase (before the main loop):
        *   Determine grid boundaries from `Config`.
        *   Create a specified number (e.g., 5-10) of `BerryBush` instances.
        *   For each bush, generate a random `position` within the grid boundaries. Ensure positions align with the grid if necessary.
        *   Add each created `BerryBush` to the `ResourceManager` using `add_node`.
    *   In the game loop's `update` phase: Call `resource_manager.update_nodes(dt)`.
    *   In the game loop's `render` phase: Call `resource_manager.draw_nodes(surface, font)`.
6.  **Update Configuration (`src/core/config.py`):**
    *   Add configuration options like:
        *   `BERRY_BUSH_COLOR = (0, 128, 0)` (Green)
        *   `BERRY_BUSH_CAPACITY = 100`
        *   `BERRY_BUSH_GENERATION_RATE = 1` (e.g., 1 resource per second)
        *   `INITIAL_BERRY_BUSHES = 10`
        *   `RESOURCE_TEXT_COLOR = (255, 255, 255)`
        *   `RESOURCE_FONT_SIZE = 16`
        *   Potentially `NODE_SIZE = (grid_cell_width, grid_cell_height)` if nodes should fit grid cells.

**Mermaid Diagram of Class Interactions:**

```mermaid
graph TD
    subgraph Core
        GameLoop["GameLoop (main.py/game_loop.py)"]
        Config["Config (config.py)"]
        Pygame["Pygame (Surface, Font)"]
    end

    subgraph Resources ["src/resources"]
        ResourceManager["ResourceManager (manager.py)"]
        ResourceNode["ResourceNode (node.py)"]
        BerryBush["BerryBush (berry_bush.py)"]
    end

    GameLoop -- Creates & Uses --> ResourceManager
    GameLoop -- Reads --> Config
    GameLoop -- Uses --> Pygame

    ResourceManager -- Manages --> ResourceNode
    BerryBush -- Inherits from --> ResourceNode

    ResourceManager -- Calls update --> ResourceNode
    ResourceManager -- Calls draw --> ResourceNode

    ResourceNode -- Reads --> Config
    BerryBush -- Reads --> Config
    BerryBush -- Uses --> Pygame

    style Core fill:#lightblue
    style Resources fill:#lightgreen
```

**Testing Criteria (from `breakdown.md`, adapted):**

*   Berry bushes (green squares) appear on the grid at random locations.
*   Resource counts (text overlays) start at 0 or an initial value and increase over time.
*   Resources accumulate at a consistent rate based on `BERRY_BUSH_GENERATION_RATE` and simulation ticks/time.
*   Resource generation stops once `BERRY_BUSH_CAPACITY` is reached.
*   `ResourceManager` correctly tracks and updates all created berry bushes.
*   The simulation continues to run smoothly with the added resource logic.
</file>

<file path="SLICE_2.1_PLAN.md">
# Plan: Epic 2, Slice 2.1 - Agent Movement

This plan focuses on creating the basic `Agent` class, implementing simple movement behaviors, managing agents, and integrating them into the existing simulation loop.

**Goals:**

1.  Establish the core `Agent` class structure.
2.  Implement basic movement logic (direct to target, random).
3.  Create an `AgentManager` to handle multiple agents.
4.  Integrate agent updates and rendering into the main game loop.
5.  Provide simple visual representation and state indication.

**Technical Implementation Steps:**

1.  **Create Agent Module:**
    *   Create a new directory: `src/agents/`
    *   Create `src/agents/__init__.py` (empty file).
    *   Create `src/agents/agent.py`.

2.  **Define `Agent` Class (`src/agents/agent.py`):**
    *   Import necessary modules (e.g., `pygame.math.Vector2`).
    *   Define an `Enum` or constants for agent states: `IDLE`, `MOVING_RANDOMLY`, `MOVING_TO_TARGET`.
    *   Implement the `Agent` class:
        *   `__init__(self, position, speed)`: Initialize `position` (Vector2), `speed`, `state` (default to `IDLE`), `target_position` (None initially), `color` (yellow).
        *   `set_target(self, target_position)`: Sets `target_position` and changes `state` to `MOVING_TO_TARGET`.
        *   `_move_towards_target(self, dt)`: Calculates the direction vector to `target_position`. Normalizes the vector. Updates `self.position` based on `speed` and `dt`. If close enough to the target, set `state` to `IDLE` and `target_position` to None.
        *   `_move_randomly(self, dt)`: Implement simple random movement logic (e.g., pick a random nearby point periodically or maintain a random velocity vector for a duration).
        *   `update(self, dt)`:
            *   If `state` is `MOVING_TO_TARGET`, call `_move_towards_target(dt)`.
            *   If `state` is `MOVING_RANDOMLY`, call `_move_randomly(dt)`.
            *   If `state` is `IDLE`, do nothing.
        *   `draw(self, screen, grid)`: Calculate screen coordinates from grid position. Draw a yellow circle representing the agent. Modify color slightly based on `state` for basic visualization (e.g., slightly brighter yellow for moving states).

3.  **Create `AgentManager` Class (`src/agents/manager.py`):**
    *   Create `src/agents/manager.py`.
    *   Import `Agent`.
    *   Implement the `AgentManager` class:
        *   `__init__(self)`: Initialize an empty list `self.agents`.
        *   `add_agent(self, agent)`: Appends an `Agent` instance to `self.agents`.
        *   `create_agent(self, position, speed)`: Creates an `Agent` instance and adds it to the list. Returns the created agent.
        *   `update_agents(self, dt)`: Loop through `self.agents` and call each agent's `update(dt)` method.
        *   `render_agents(self, screen, grid)`: Loop through `self.agents` and call each agent's `draw(screen, grid)` method.

4.  **Integrate into Game Loop (e.g., `main.py` or `app.py`):**
    *   Import `AgentManager` and `Agent` (or just the manager if using `create_agent`).
    *   Before the main loop, instantiate `agent_manager = AgentManager()`.
    *   Create a few initial agents:
        ```python
        # Example: Create agents at specific grid positions
        agent1 = agent_manager.create_agent(position=Vector2(5, 5), speed=50) # Speed in pixels/sec
        agent2 = agent_manager.create_agent(position=Vector2(10, 10), speed=60)
        # Optionally set initial targets or states
        # agent1.set_target(Vector2(15, 15))
        # agent2.state = AgentState.MOVING_RANDOMLY
        ```
    *   Inside the game loop's **update phase**: Call `agent_manager.update_agents(dt)`.
    *   Inside the game loop's **render phase**: Call `agent_manager.render_agents(screen, grid)`.

5.  **Refinement & Configuration:**
    *   Adjust agent speed in the `Config` class if desired.
    *   Ensure grid coordinates are correctly translated to screen coordinates for drawing.
    *   Refine the state visualization colors/method as needed.

**Mermaid Diagram: Agent System Structure**

```mermaid
graph TD
    subgraph GameLoop [Main Game Loop (main.py/app.py)]
        direction LR
        A[Initialize] --> B(Update Cycle);
        B --> C(Render Cycle);
        C --> B;
    end

    subgraph AgentSystem [Agent System (src/agents/)]
        direction TB
        Manager[AgentManager] --> AgentList{Agents List};
        AgentList --> Agent1[Agent Instance 1];
        AgentList --> Agent2[Agent Instance 2];
        Agent1 --> StateMachine1[State Machine];
        Agent2 --> StateMachine2[State Machine];
        StateMachine1 -- controls --> Movement1[Movement Logic];
        StateMachine2 -- controls --> Movement2[Movement Logic];
        Movement1 --> Position1[Position Update];
        Movement2 --> Position2[Position Update];
    end

    A -- instantiates --> Manager;
    B -- calls --> Manager_Update[AgentManager.update_agents(dt)];
    Manager_Update -- calls --> Agent1_Update[Agent1.update(dt)];
    Manager_Update -- calls --> Agent2_Update[Agent2.update(dt)];
    C -- calls --> Manager_Render[AgentManager.render_agents(screen, grid)];
    Manager_Render -- calls --> Agent1_Draw[Agent1.draw(...)];
    Manager_Render -- calls --> Agent2_Draw[Agent2.draw(...)];

    Agent1_Update --> StateMachine1;
    Agent2_Update --> StateMachine2;

    classDef default fill:#f9f,stroke:#333,stroke-width:2px;
    classDef agent fill:#ccf,stroke:#333,stroke-width:2px;
    class Agent1,Agent2,AgentList,Manager,StateMachine1,StateMachine2,Movement1,Movement2,Position1,Position2 agent;
```

**Testing Criteria Checklist:**

*   [ ] Agents appear on grid (yellow circles) and move smoothly.
*   [ ] Agents move directly towards a set target.
*   [ ] Agents exhibit random movement when in that state.
*   [ ] Movement speed is consistent with simulation rate (`dt`).
*   [ ] Agent states (`IDLE`, `MOVING_RANDOMLY`, `MOVING_TO_TARGET`) are visually distinguishable (e.g., slight color change).
*   [ ] Multiple agents can operate simultaneously without interfering (collision ignored for now).
*   [ ] Agents stop appropriately when reaching their target.
</file>

<file path="SLICE_2.2_PLAN.md">
## Final Plan: Epic 2, Slice 2.2 - Resource Collection

**Goal:** Implement the agent's ability to detect, gather, carry, and deliver resources to designated storage points. Agents will prioritize resources based on a list provided at creation, attempt to gather up to their inventory capacity, and deliver to storage points with overall capacity limits. Visual feedback will include state-based color changes and a simple icon when carrying resources.

**Key Files to Modify/Create:**

*   `src/agents/agent.py`: Extend `AgentState` enum, update `Agent` class methods and attributes.
*   `src/agents/manager.py` (potentially): For managing agents or helping with resource/storage lookup (e.g., providing access to `ResourceManager`).
*   `src/resources/node.py`: Modify to allow resource collection.
*   `src/resources/storage_point.py` (New File): Define the `StoragePoint` class.
*   `src/core/config.py`: For new global constants like gathering/delivery times and default agent inventory capacity.
*   A new file for `ResourceTypeEnum` (e.g., `src/resources/resource_types.py`) if not already implicitly defined or handled by strings.

**Detailed Steps:**

1.  **Define `ResourceTypeEnum` (e.g., `src/resources/resource_types.py`):**
    *   If not already present, create an enum for resource types (e.g., `BERRY`, `WHEAT`). This will be used for agent priorities, storage acceptance, etc.
    ```python
    # src/resources/resource_types.py
    from enum import Enum, auto

    class ResourceType(Enum):
        BERRY = auto()
        WHEAT = auto()
        # ... other types
    ```

2.  **Refactor `Agent._move_towards_target()` (`src/agents/agent.py`):**
    *   Modify `_move_towards_target(self, dt: float) -> bool`:
        *   The method should return `True` if the target is reached within this update cycle, `False` otherwise.
        *   It should **not** directly set `self.state = AgentState.IDLE`. It will just update `self.position` and clear `self.target_position` upon arrival.

3.  **Expand `AgentState` Enum (`src/agents/agent.py`):**
    *   Add new states: `MOVING_TO_RESOURCE`, `GATHERING_RESOURCE`, `CARRYING_RESOURCE`, `MOVING_TO_STORAGE`, `DELIVERING_RESOURCE`.
    *   Update `self.state_colors` in `Agent.__init__` for these new states.

4.  **Implement Agent Inventory & Attributes (`src/agents/agent.py`):**
    *   In `Agent.__init__(self, position, speed, grid, resource_priorities: list[ResourceType], inventory_capacity: int)`:
        *   `self.resource_priorities: list[ResourceType]` (passed during creation).
        *   `self.inventory_capacity: int` (passed during creation, or from `config`).
        *   `self.current_inventory: dict` (e.g., `{'resource_type': ResourceType | None, 'quantity': 0}`).
        *   `self.gathering_timer: float = 0.0`
        *   `self.delivery_timer: float = 0.0`
        *   `self.target_resource_node: ResourceNode | None = None`
        *   `self.target_storage_point: StoragePoint | None = None`

5.  **Implement `StoragePoint` Class (`src/resources/storage_point.py`):**
    *   Define `class StoragePoint:`
        *   `__init__(self, position: pygame.math.Vector2, overall_capacity: int, accepted_resource_types: list[ResourceType] | None = None)`
        *   Attributes: `self.position`, `self.overall_capacity`, `self.accepted_resource_types` (if `None`, accepts all), `self.stored_resources: dict[ResourceType, int]` (e.g., `{ResourceType.BERRY: 10}`).
        *   Methods:
            *   `add_resource(self, resource_type: ResourceType, quantity: int) -> int`: Adds resources, respects `accepted_resource_types` and `overall_capacity`. Returns actual quantity added.
            *   `get_current_load(self) -> int`: Returns total quantity of all stored resources.
    *   `ResourceManager` (in `src/resources/manager.py`) should maintain a list of these: `self.storage_points: list[StoragePoint]`.

6.  **Implement Resource/Storage Detection Logic (`src/agents/agent.py`):**
    *   `_find_best_resource_target(self, resource_manager) -> ResourceNode | None`:
        *   Iterates `self.resource_priorities`.
        *   Queries `resource_manager.get_nodes_by_type(resource_type)` (method to be added to `ResourceManager`).
        *   Uses pathfinding to find the nearest available (non-empty) node.
        *   Returns the `ResourceNode` object or `None`.
    *   `_find_best_storage_target(self, resource_manager) -> StoragePoint | None`:
        *   Queries `resource_manager.storage_points`.
        *   Finds nearest `StoragePoint` that can accept `self.current_inventory['resource_type']` and is not full.
        *   Returns the `StoragePoint` object or `None`.

7.  **Implement Agent State Logic in `Agent.update()` (`src/agents/agent.py`):**
    *   (Pass `resource_manager` and `agent_manager` if needed for lookups)
    *   **`IDLE`:**
        *   `self.target_resource_node = self._find_best_resource_target(resource_manager)`
        *   If `self.target_resource_node`:
            *   `self.target_position = self.target_resource_node.position`
            *   `self.state = AgentState.MOVING_TO_RESOURCE`
    *   **`MOVING_TO_RESOURCE`:**
        *   If `self.target_position` is `None` (e.g., resource depleted while en route), go `IDLE`.
        *   `reached = self._move_towards_target(dt)`
        *   If `reached`:
            *   `self.state = AgentState.GATHERING_RESOURCE`
            *   `self.gathering_timer = config.DEFAULT_GATHERING_TIME`
    *   **`GATHERING_RESOURCE`:**
        *   If `self.target_resource_node` is `None` or empty, go `IDLE`.
        *   `self.gathering_timer -= dt`
        *   If `self.gathering_timer <= 0`:
            *   `amount_to_gather = self.inventory_capacity - self.current_inventory['quantity']`
            *   `gathered_amount = self.target_resource_node.collect_resource(amount_to_gather)`
            *   If `gathered_amount > 0`:
                *   `self.current_inventory['resource_type'] = self.target_resource_node.resource_type` (assuming node has a type)
                *   `self.current_inventory['quantity'] += gathered_amount`
            *   `self.target_resource_node = None`
            *   `self.state = AgentState.CARRYING_RESOURCE`
    *   **`CARRYING_RESOURCE`:**
        *   If `self.current_inventory['quantity'] == 0`, go `IDLE`.
        *   `self.target_storage_point = self._find_best_storage_target(resource_manager)`
        *   If `self.target_storage_point`:
            *   `self.target_position = self.target_storage_point.position`
            *   `self.state = AgentState.MOVING_TO_STORAGE`
        *   Else (no suitable storage), go `IDLE` (or a new "WAITING_FOR_STORAGE" state).
    *   **`MOVING_TO_STORAGE`:**
        *   If `self.target_position` is `None` (e.g., storage became full/invalid), go `CARRYING_RESOURCE` to re-evaluate.
        *   `reached = self._move_towards_target(dt)`
        *   If `reached`:
            *   `self.state = AgentState.DELIVERING_RESOURCE`
            *   `self.delivery_timer = config.DEFAULT_DELIVERY_TIME`
    *   **`DELIVERING_RESOURCE`:**
        *   If `self.target_storage_point` is `None`, go `CARRYING_RESOURCE`.
        *   `self.delivery_timer -= dt`
        *   If `self.delivery_timer <= 0`:
            *   `delivered_amount = self.target_storage_point.add_resource(self.current_inventory['resource_type'], self.current_inventory['quantity'])`
            *   `self.current_inventory['quantity'] -= delivered_amount`
            *   If `self.current_inventory['quantity'] <= 0`:
                *   `self.current_inventory['resource_type'] = None`
                *   `self.current_inventory['quantity'] = 0`
            *   `self.target_storage_point = None`
            *   `self.state = AgentState.IDLE` (or `CARRYING_RESOURCE` if still has items)

8.  **Modify `ResourceNode` (`src/resources/node.py`):**
    *   Ensure it has `self.resource_type: ResourceType`.
    *   Add `collect_resource(self, amount_to_collect: int) -> int`: Reduces internal resource count by `amount_to_collect` (or less if not enough available), returns actual amount collected.

9.  **Update `ResourceManager` (`src/resources/manager.py`):**
    *   Add `self.storage_points: list[StoragePoint] = []`.
    *   Add `add_storage_point(self, storage_point: StoragePoint)`.
    *   Add `get_nodes_by_type(self, resource_type: ResourceType) -> list[ResourceNode]`.

10. **Implement Visual Feedback (`src/agents/agent.py`):**
    *   In `Agent.draw()`:
        *   Use `self.state_colors` as before.
        *   If `self.current_inventory['quantity'] > 0`:
            *   Draw a small colored circle (e.g., using `config.RESOURCE_VISUAL_COLORS[self.current_inventory['resource_type']]`) above the agent.

11. **Configuration (`src/core/config.py`):**
    *   Add:
        *   `DEFAULT_GATHERING_TIME = 2.0` (seconds)
        *   `DEFAULT_DELIVERY_TIME = 1.0` (seconds)
        *   `DEFAULT_AGENT_INVENTORY_CAPACITY = 5`
        *   `RESOURCE_VISUAL_COLORS = {ResourceType.BERRY: (255,0,0), ResourceType.WHEAT: (200,200,0)}`

**Mermaid Diagram for Agent State Transitions:**
```mermaid
graph TD
    IDLE -->|Found Resource Target| MOVING_TO_RESOURCE;
    MOVING_TO_RESOURCE -- Reached Resource --> GATHERING_RESOURCE;
    MOVING_TO_RESOURCE -- Target Invalid --> IDLE;
    GATHERING_RESOURCE -- Gathering Complete & Has Resource --> CARRYING_RESOURCE;
    GATHERING_RESOURCE -- Resource Empty/Problem --> IDLE;
    CARRYING_RESOURCE -->|Found Storage Target| MOVING_TO_STORAGE;
    CARRYING_RESOURCE -- No Resource to Carry --> IDLE;
    CARRYING_RESOURCE -- No Storage Target --> IDLE; %% Or a new WAITING_FOR_STORAGE state
    MOVING_TO_STORAGE -- Reached Storage --> DELIVERING_RESOURCE;
    MOVING_TO_STORAGE -- Target Invalid --> CARRYING_RESOURCE;
    DELIVERING_RESOURCE -- Delivery Complete --> IDLE;
    DELIVERING_RESOURCE -- Still Carrying Items --> CARRYING_RESOURCE;
    DELIVERING_RESOURCE -- Target Invalid --> CARRYING_RESOURCE;

    subgraph Agent States
        IDLE
        MOVING_TO_RESOURCE
        GATHERING_RESOURCE
        CARRYING_RESOURCE
        MOVING_TO_STORAGE
        DELIVERING_RESOURCE
    end
</file>

<file path="SLICE_2.2_STORAGE_POINT_PLAN.md">
# Plan: Add Berry Storage Point to Game Loop (Slice 2.2)

**Goal:** Instantiate a `StoragePoint` that accepts `BERRY` resources with a capacity of 20, and place it in the middle of the game screen. This involves modifying `src/core/game_loop.py`.

**Affected File:** `src/core/game_loop.py`

**Detailed Steps for `src/core/game_loop.py` Modifications:**

1.  **Import necessary classes:**
    *   At the top of the file, ensure these imports are present:
        ```python
        import pygame # Should already be there
        from pygame.math import Vector2 # Should already be there
        from src.core import config # Should already be there
        from src.resources.storage_point import StoragePoint
        from src.resources.resource_types import ResourceType
        # ... other existing imports
        ```

2.  **Create a new method `_spawn_initial_storage_points(self)` within the `GameLoop` class:**
    *   This method will be responsible for creating and registering storage points.
    *   The content of the method will be:
        ```python
        def _spawn_initial_storage_points(self):
            """Creates and places the initial storage points."""
            # Calculate middle of the screen in grid coordinates
            middle_screen_x_pixels = config.SCREEN_WIDTH / 2
            middle_screen_y_pixels = config.SCREEN_HEIGHT / 2
            middle_screen_pixel_pos = pygame.math.Vector2(middle_screen_x_pixels, middle_screen_y_pixels)
            storage_position_grid = self.grid.screen_to_grid(middle_screen_pixel_pos)

            # Define storage point properties
            capacity = 20  # Confirmed capacity
            accepted_types = [ResourceType.BERRY]

            # Create and add the storage point
            berry_storage_point = StoragePoint(
                position=storage_position_grid,
                overall_capacity=capacity,
                accepted_resource_types=accepted_types
            )
            # Assumes add_storage_point method exists in ResourceManager as per SLICE_2.2_PLAN.md
            self.resource_manager.add_storage_point(berry_storage_point) 
            print(f"DEBUG: Spawned StoragePoint at grid_pos: {storage_position_grid} for BERRY with capacity {capacity}")
        ```

3.  **Call the new method in `GameLoop.__init__`:**
    *   Locate the `__init__` method of the `GameLoop` class.
    *   After the line `self._spawn_initial_resources()` and before `self.agent_manager = AgentManager(...)` (or a similar logical placement after resource manager initialization), add the call:
        ```python
        # Inside GameLoop.__init__
        # ...
        self._spawn_initial_resources()
        self._spawn_initial_storage_points() # <-- Add this line
        self.agent_manager = AgentManager(grid=self.grid)
        # ...
        ```

4.  **Ensure `ResourceManager` can draw storage points (Consideration for Implementation Phase):**
    *   The `SLICE_2.2_PLAN.md` indicates `StoragePoint` has a `draw` method and `ResourceManager` will maintain a list `self.storage_points`.
    *   During implementation, ensure that `ResourceManager.draw_nodes()` (or a new `ResourceManager.draw_storage_points()` method) is updated to iterate through `self.storage_points` and call their `draw` methods. This method is called from `GameLoop.render()`.
    *   Example (conceptual, actual implementation in `ResourceManager`):
        ```python
        # In ResourceManager.draw_nodes (or a new draw_storage_points method)
        # for storage_point in self.storage_points:
        #     storage_point.draw(screen, grid)
        ```

**Mermaid Diagram of Proposed Change in `GameLoop`:**

```mermaid
graph TD
    A[GameLoop.__init__] --> B{Initialize ResourceManager};
    B --> C{_spawn_initial_resources};
    C --> D{_spawn_initial_storage_points (New Method)};
    D --> E{Calculate Middle Screen Position};
    E --> F{Convert to Grid Coordinates};
    F --> G{Instantiate StoragePoint (BERRY, capacity=20)};
    G --> H{resource_manager.add_storage_point};
    A --> I{Initialize AgentManager};
    I --> J{_spawn_initial_agents};

    subgraph GameLoop.render
        K[Draw Grid]
        L[resource_manager.draw_nodes (includes bushes)]
        M[resource_manager.draw_storage_points (or integrated into draw_nodes)]
        N[agent_manager.render_agents]
    end
    A --> K;
    A --> L;
    A --> M;
    A --> N;
</file>

<file path="SLICE_3.1_PLAN.md">
# Implementation Plan: Slice 3.1 - Basic Processing (Wheat to Flour)

**Goal:** Implement the first step in the resource processing chain, enabling agents to gather wheat, deliver it to a mill, have the mill process it into flour, and then store the flour.

**Key Components & Changes:**

1.  **Resource Type Definitions (`src/resources/resource_types.py`):**
    *   Add new resource types:
        *   `WHEAT = "WHEAT"`
        *   `FLOUR_POWDER = "FLOUR_POWDER"`
    *   Ensure these are integrated into any relevant enum or list of resource types.

2.  **WheatField Resource Node (`src/resources/wheat_field.py` - New File):**
    *   Create class `WheatField(ResourceNode)`.
    *   **Attributes:**
        *   `resource_type = ResourceType.WHEAT`
        *   `generation_rate = 1` (units of wheat)
        *   `generation_interval = 5` (simulation ticks per unit generated)
        *   `capacity = 50` (max wheat it can hold)
        *   `position` (inherited)
        *   `current_quantity` (inherited)
    *   **Visuals:** Simple yellow square (details to be refined during rendering implementation).
    *   **Logic:** Inherit resource accumulation logic from `ResourceNode`.

3.  **ProcessingStation Base Class (`src/resources/processing.py` - New File):**
    *   Create class `ProcessingStation`:
        *   **Attributes:**
            *   `accepted_input_type: ResourceType` (e.g., WHEAT)
            *   `produced_output_type: ResourceType` (e.g., FLOUR_POWDER)
            *   `conversion_ratio: float` (e.g., 1.0 meaning 1 input unit -> 1 output unit)
            *   `processing_speed: int` (ticks per unit processed)
            *   `input_capacity: int` (max input resource it can hold)
            *   `output_capacity: int` (max processed resource it can hold before needing collection)
            *   `current_input_quantity: int`
            *   `current_output_quantity: int`
            *   `is_processing: bool`
            *   `processing_progress: int` (ticks accumulated towards current unit)
            *   `position` (x, y)
        *   **Methods:**
            *   `__init__(self, position, accepted_input_type, produced_output_type, conversion_ratio, processing_speed, input_capacity, output_capacity)`
            *   `receive(self, resource_type: ResourceType, quantity: int) -> bool`: Adds input resource. Returns true if successful.
            *   `tick(self)`: Handles processing logic per simulation tick.
                *   If `current_input_quantity > 0` and `current_output_quantity < output_capacity`:
                    *   Increment `processing_progress`.
                    *   If `processing_progress >= processing_speed`:
                        *   Decrement `current_input_quantity` by 1 (or based on `conversion_ratio`).
                        *   Increment `current_output_quantity` by 1 (or based on `conversion_ratio`).
                        *   Reset `processing_progress`.
                        *   Set `is_processing = True`.
                *   Else: `is_processing = False`.
            *   `dispense(self, quantity: int) -> int`: Allows an agent to collect processed output. Returns actual quantity dispensed.
            *   `can_accept_input(self, resource_type: ResourceType) -> bool`: Checks if it can accept the given resource type and has space.
            *   `has_output(self) -> bool`: Checks if there are processed goods to collect.
            *   `get_visual_state(self) -> str`: Returns "idle" or "processing".

4.  **Mill Subclass (`src/resources/mill.py` - New File):**
    *   Create class `Mill(ProcessingStation)`:
        *   **`__init__(self, position)`:**
            *   Call `super().__init__(position, ResourceType.WHEAT, ResourceType.FLOUR_POWDER, conversion_ratio=1.0, processing_speed=8, input_capacity=25, output_capacity=25)`.
    *   **Visuals:** Specific visual representation for a mill (details TBD), changing based on `get_visual_state()`.

5.  **ResourceManager (`src/resources/manager.py`):**
    *   Modify to register and manage `WheatField` and `Mill` instances.
    *   Add methods:
        *   `get_nearest_station_accepting(self, position, resource_type: ResourceType) -> Optional[ProcessingStation]`
        *   `get_stations_with_output(self, resource_type: ResourceType) -> List[ProcessingStation]`

6.  **StoragePoint (`src/resources/storage_point.py`):**
    *   Modify `StoragePoint` to be more generic:
        *   Change `accepted_resource_type` to `accepted_resource_types: List[ResourceType]` in `__init__`.
        *   Update `can_store()` and `store_resource()` to check against this list.
        *   When creating `StoragePoint` instances for flour, they will be initialized to accept `ResourceType.FLOUR_POWDER`.

7.  **Agent Logic (`src/agents/agent.py`):**
    *   **State Machine & Decision Making:**
        *   **Finding Wheat:** Existing logic for finding `ResourceNode`s can be adapted.
        *   **Delivering Wheat to Mill:**
            *   Agent finds `nearest_station_accepting(ResourceType.WHEAT)`.
            *   `DELIVERING` state logic adapted for `ProcessingStation` targets (call `target.receive()`).
        *   **Collecting Flour from Mill:**
            *   Agent finds `Mill` that `has_output()` of `FLOUR_POWDER`.
            *   `GATHERING`/`COLLECTING` state adapted for `ProcessingStation` targets (call `target.dispense()`).
        *   **Delivering Flour to Storage:**
            *   Agent finds `StoragePoint` accepting `FLOUR_POWDER`.
            *   `DELIVERING` state logic reused.
    *   **Agent Inventory:** Ensure it can handle different resource types.

8.  **Game Loop / Main Simulation (`main.py` or `src/core/game_loop.py`):**
    *   Instantiate `WheatField`s, `Mill`s, and `StoragePoint`s for flour.
    *   Ensure `ProcessingStation.tick()` is called for all mill instances.

9.  **Rendering (`src/rendering/` modules):**
    *   Add rendering logic for `WheatField`s.
    *   Add rendering logic for `Mill`s (idle/processing states).
    *   Ensure `FLOUR_POWDER` visualization if applicable.

## Mermaid Diagram (Conceptual Flow)

```mermaid
graph TD
    A[Agent Idle] -->|Needs Wheat| FW{Find WheatField}
    FW -->|Found| MW(Move to WheatField)
    MW -->|Arrived| CW(Collect Wheat)
    CW -->|Has Wheat| FM{Find Mill}
    FM -->|Found| MM(Move to Mill)
    MM -->|Arrived| DM(Deliver Wheat to Mill)
    DM -->|Delivered| A

    M[Mill] -->|Processes Wheat| P(Produces Flour_Powder)

    A -->|Needs to Collect Flour| FMP{Find Mill with Flour}
    FMP -->|Found| MMF(Move to Mill)
    MMF -->|Arrived| CF(Collect Flour_Powder from Mill)
    CF -->|Has Flour_Powder| FS{Find Storage for Flour}
    FS -->|Found| MSF(Move to Storage)
    MSF -->|Arrived| DSF(Deliver Flour_Powder to Storage)
    DSF -->|Delivered| A

    subgraph WheatField
        WF[WheatField Node]
    end

    subgraph MillStation
        M
    end

    subgraph FlourStorage
        S[StoragePoint for Flour]
    end

    WF -- generates --> WheatResource[Wheat]
    WheatResource -- collected by --> CW
    DM -- input --> M
    M -- output --> FlourResource[Flour_Powder]
    FlourResource -- collected by --> CF
    DSF -- stores --> S
```

## Testing Criteria (from `breakdown.md`)

*   Wheat fields generate wheat resources.
*   Agents gather wheat and deliver to mill.
*   Mill processes wheat into flour at specified rate (8 ticks/unit).
*   Flour is stored correctly (in adapted `StoragePoint`s).
*   Processing stations (Mills) show visual state (idle/processing).
</file>

<file path="TASK_STATUS_UI_PLAN.md">
# Plan: Task Status Display Panel UI Feature

**1. Objective:**
To provide a visual overview of tasks within the simulation, showing their current states (pending, in-progress, completed, failed), assigned agents, and other relevant details. This will help the user understand the ongoing activities managed by the `TaskManager`.

**2. New UI Component File:**
A new file will be created to house the UI component: `src/rendering/task_status_display.py`.

**3. Class Definition: `TaskStatusDisplay`**
This class will be responsible for rendering the task status information.

*   **File:** `src/rendering/task_status_display.py`
*   **Class Name:** `TaskStatusDisplay`

    *   **`__init__(self, task_manager: TaskManager, font: pygame.font.Font, panel_rect: pygame.Rect, screen_surface: pygame.Surface)`**
        *   `task_manager`: A reference to the global `TaskManager` instance to fetch task data.
        *   `font`: A `pygame.font.Font` object for rendering text.
        *   `panel_rect`: A `pygame.Rect` object defining the position and dimensions of the task display panel on the main screen.
        *   `screen_surface`: The main Pygame screen surface onto which this panel will be drawn.
        *   **Internal Attributes:**
            *   `self.panel_surface = pygame.Surface(panel_rect.size)`: A dedicated surface for drawing the panel's content.
            *   `self.background_color`: Color for the panel's background.
            *   `self.text_color`: Default color for text.
            *   `self.header_color`: Color for section headers.
            *   `self.padding`: Padding within the panel.
            *   `self.line_height`: Vertical spacing for text lines.
            *   `self.max_items_per_section`: To limit display.

    *   **`_draw_text(self, surface: pygame.Surface, text: str, position: tuple[int, int], color: pygame.Color, font: pygame.font.Font) -> None`**
        *   A helper method to render and blit a single line of text.

    *   **`_render_task_details(self, task: Task, y_pos: int, surface: pygame.Surface) -> int`**
        *   Renders the details of a single `Task` object.
        *   Information to display:
            *   Task ID (shortened).
            *   Task Type (`task.task_type.name`).
            *   Status (`task.status.name`).
            *   For `GatherAndDeliverTask`: Resource (`task.resource_type_to_gather.name`), Quantity (`task.quantity_gathered` / `task.quantity_to_gather`).
            *   If `task.agent_id` is set: "Agent: [agent_id]".
            *   For `IN_PROGRESS_*` tasks: Use `task.get_target_description()`.
            *   If `task.status` is `FAILED`: Display `task.error_message`.
        *   Returns the new `y_pos`.

    *   **`draw(self) -> None`**
        *   Main rendering method.
        *   Fill `self.panel_surface`.
        *   **Pending Tasks Section:** Header and list of pending tasks.
        *   **In-Progress Tasks Section:** Header and list of in-progress tasks.
        *   **Recently Completed Tasks Section (Optional):** Header and list of completed tasks.
        *   **Recently Failed Tasks Section (Optional):** Header and list of failed tasks.
        *   Blit `self.panel_surface` onto `self.screen_surface`.

**4. Integration into `GameLoop` (`src/core/game_loop.py`):**

*   **In `GameLoop.__init__`:**
    *   Import `TaskStatusDisplay`.
    *   Initialize `self.ui_font`.
    *   Define `task_panel_rect` (e.g., `panel_width = 300`, `panel_x = config.SCREEN_WIDTH - panel_width`).
    *   Instantiate `self.task_display = TaskStatusDisplay(self.task_manager, self.ui_font, task_panel_rect, self.screen)`.

*   **In `GameLoop.render`:**
    *   Call `self.task_display.draw()`.

**5. Data Flow:**
The `TaskStatusDisplay` directly accesses task lists from the `TaskManager`.

**Future Enhancements (Out of Scope for Initial Version):**
*   Clickable tasks for more details.
*   Scrolling.
*   Filtering options.
*   Visual indicators (color-coding).
</file>

<file path="WHEAT_COLLECTION_IMPLEMENTATION_PLAN.md">
# Plan to Implement Wheat Collection

This plan outlines the steps to implement wheat collection, following the pattern of existing berry collection, and ensuring berries and wheat can share the same primary storage points.

## 1. Update Configuration ([`core/config.py`](core/config.py))

Add the following new constants to define behavior for wheat collection tasks:

*   `MIN_WHEAT_STOCK_LEVEL = 40`
*   `WHEAT_GATHER_TASK_QUANTITY = 15`
*   `WHEAT_GATHER_TASK_PRIORITY = 4`
*   `MAX_ACTIVE_WHEAT_GATHER_TASKS = 2`

## 2. Modify Existing Storage Point in Game Loop ([`core/game_loop.py`](core/game_loop.py))

*   Navigate to the `_spawn_initial_storage_points` method (around line 558).
*   Locate the initialization of the `berry_storage_point`.
*   Modify its `accepted_resource_types`:
    *   Change from `[ResourceType.BERRY]` to `[ResourceType.BERRY, ResourceType.WHEAT]`.
*   Update its `overall_capacity`:
    *   Change the `capacity` variable used for this storage point from `20` to `25`.

## 3. Update Task Manager ([`tasks/task_manager.py`](tasks/task_manager.py))

*   In the `_generate_tasks_if_needed` method (around line 1775):
    *   After the existing berry task generation logic, add a new section to handle wheat task generation. This section will mirror the structure of the berry logic:
        1.  Retrieve the current global stock of wheat:
            `current_wheat_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.WHEAT)`
        2.  Check if `current_wheat_stock` is less than `config.MIN_WHEAT_STOCK_LEVEL`.
        3.  If the stock is low, count the number of currently active (pending or assigned) `GatherAndDeliverTask`s for `ResourceType.WHEAT`.
        4.  If this count is less than `config.MAX_ACTIVE_WHEAT_GATHER_TASKS`, then create a new `GatherAndDeliverTask`:
            ```python
            self.create_gather_task(
                resource_type=ResourceType.WHEAT,
                quantity=config.WHEAT_GATHER_TASK_QUANTITY,
                priority=config.WHEAT_GATHER_TASK_PRIORITY
            )
            ```

## Visual Plan (Mermaid Diagram)

```mermaid
graph TD
    A[Start: Implement Wheat Collection] --> B(1. Update Configuration in core/config.py);
    B --> B1(Add MIN_WHEAT_STOCK_LEVEL = 40);
    B --> B2(Add WHEAT_GATHER_TASK_QUANTITY = 15);
    B --> B3(Add WHEAT_GATHER_TASK_PRIORITY = 4);
    B --> B4(Add MAX_ACTIVE_WHEAT_GATHER_TASKS = 2);

    A --> C(2. Modify Storage Point in core/game_loop.py);
    C --> C1(In _spawn_initial_storage_points method);
    C1 --> C2(Find 'berry_storage_point' creation);
    C2 --> C3(Update accepted_resource_types to [BERRY, WHEAT]);
    C2 --> C4(Update overall_capacity to 25);

    A --> D(3. Update Task Manager in tasks/task_manager.py);
    D --> D1(In _generate_tasks_if_needed method);
    D1 --> D2(Add new section for Wheat task generation);
    D2 --> D3(Get current_wheat_stock);
    D2 --> D4(If stock < MIN_WHEAT_STOCK_LEVEL:);
    D4 --> D5(Count active WHEAT GatherAndDeliverTasks);
    D5 --> D6(If count < MAX_ACTIVE_WHEAT_GATHER_TASKS:);
    D6 --> D7(Create new GatherAndDeliverTask for WHEAT);

    B4 --> E{Plan Ready};
    C4 --> E;
    D7 --> E;
</file>

<file path="src/rendering/grid.py">
import pygame
from src.core import config
from pygame.math import Vector2

class Grid:
    """
    Represents the simulation grid, handling drawing and coordinate conversions.
    """
    def __init__(self):
        """Initializes the grid based on configuration."""
        self.screen_width = config.SCREEN_WIDTH
        self.screen_height = config.SCREEN_HEIGHT
        self.cell_size = config.GRID_CELL_SIZE # Assuming square cells for now
        self.cell_width = self.cell_size
        self.cell_height = self.cell_size
        self.grid_color = config.GRID_COLOR

        if self.cell_width <= 0 or self.cell_height <= 0:
            raise ValueError("GRID_CELL_SIZE must be positive.")

        self.width_in_cells = self.screen_width // self.cell_width
        self.height_in_cells = self.screen_height // self.cell_height

        print(f"Grid initialized: {self.width_in_cells}x{self.height_in_cells} cells of size {self.cell_size}x{self.cell_size}") # Debug

    def draw(self, surface: pygame.Surface):
        """Draws the grid lines on the given surface."""
        # Draw vertical lines
        for x in range(0, self.screen_width, self.cell_width):
            pygame.draw.line(surface, self.grid_color, (x, 0), (x, self.screen_height))

        # Draw horizontal lines
        for y in range(0, self.screen_height, self.cell_height):
            pygame.draw.line(surface, self.grid_color, (0, y), (self.screen_width, y))

    def grid_to_screen(self, grid_pos: Vector2) -> tuple[int, int]:
        """
        Converts grid coordinates (e.g., Vector2(5, 3)) to screen pixel coordinates
        (center of the cell).
        """
        screen_x = int(grid_pos.x * self.cell_width + self.cell_width / 2)
        screen_y = int(grid_pos.y * self.cell_height + self.cell_height / 2)
        return screen_x, screen_y

    def screen_to_grid(self, screen_pos: tuple[int, int]) -> Vector2:
        """
        Converts screen pixel coordinates to grid coordinates.
        """
        grid_x = screen_pos[0] // self.cell_width
        grid_y = screen_pos[1] // self.cell_height
        return Vector2(grid_x, grid_y)

    def is_within_bounds(self, grid_pos: Vector2) -> bool:
        """Checks if a grid position is within the valid grid cell range."""
        return 0 <= grid_pos.x < self.width_in_cells and 0 <= grid_pos.y < self.height_in_cells
</file>

<file path="src/resources/resource_types.py">
from enum import Enum, auto

class ResourceType(Enum):
    """Defines the types of resources available in the simulation."""
    BERRY = auto()
    WHEAT = auto()
    FLOUR_POWDER = auto()
    # Future resource types can be added here
</file>

<file path="src/resources/wheat_field.py">
import pygame
from .node import ResourceNode
from ..resources.resource_types import ResourceType
from ..core import config

class WheatField(ResourceNode):
    """
    A resource node that generates Wheat.
    """

    def __init__(self, position: pygame.Vector2):
        """
        Initializes a WheatField.

        Args:
            position: The position of the field on the grid (pygame.Vector2).
        """

        super().__init__(
            position=position,
            capacity=config.WHEAT_FIELD_CAPACITY, 
            generation_interval=config.WHEAT_GENERATION_INTERVAL,
            resource_type=ResourceType.WHEAT
        )
        self.color = config.RESOURCE_VISUAL_COLORS.get(self.resource_type, (255, 255, 0)) # Default yellow if not in config

    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Added grid parameter
        """
        Draws the wheat field on the given surface.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object (unused in this implementation but part of the required signature).
        """
        # The 'grid' parameter is not used here as drawing is based on
        # self.position and config.GRID_CELL_SIZE.
        rect_x = self.position.x * config.GRID_CELL_SIZE
        rect_y = self.position.y * config.GRID_CELL_SIZE
        node_rect = pygame.Rect(rect_x, rect_y, config.GRID_CELL_SIZE, config.GRID_CELL_SIZE)

        pygame.draw.rect(surface, self.color, node_rect)

        # Draw resource count
        resource_text = f"{int(self.current_quantity)}"
        text_surface = font.render(resource_text, True, config.RESOURCE_TEXT_COLOR)
        text_rect = text_surface.get_rect(center=node_rect.center)
        surface.blit(text_surface, text_rect)

    def __str__(self):
        return f"WheatField at {self.position} ({self.current_quantity:.1f}/{self.capacity} {self.resource_type.name})"

    def __repr__(self):
        return f"WheatField(position={self.position})"
</file>

<file path="main.py">
import pygame
import sys
from src.core import config
from src.core.game_loop import GameLoop
from src.rendering import debug_display

def main():
    """Initializes Pygame, creates the game window and runs the game loop."""
    try:
        pygame.init()
    except Exception as e:
        sys.exit(1)

    # Initialize font module for debug display
    # It's better to initialize it once here than potentially multiple times
    # or checking every frame in the display function.
    try:
        pygame.font.init()
        # debug_display.init_debug_font() is called within display_fps if needed now
    except Exception as e:
        print(f"ERROR: pygame.font.init() failed: {e}") # DEBUG
        # Continue without font if it fails, but log it.

    try:
        screen = pygame.display.set_mode((config.SCREEN_WIDTH, config.SCREEN_HEIGHT))

    except Exception as e:
        pygame.quit()
        sys.exit(1)

    pygame.display.set_caption("Pastorial - Resource Chain Simulator")

    # Create and run the game loop
    try:
        game = GameLoop(screen)
    except Exception as e:
        print(f"FATAL: Error during game.run(): {e}")  # DEBUG
        raise  # Re-raise the exception to see the full traceback
        pygame.quit()
        sys.exit(1)

    try:
        game.run()
    except Exception as e:
        print(f"FATAL: Error during game.run(): {e}") # DEBUG
        raise

    # Quit Pygame and exit the program
    pygame.quit()
    sys.exit()

if __name__ == '__main__':
    main()
</file>

<file path="TASK_SYSTEM_IMPLEMENTATION_PLAN.md">
# Plan for Implementing a Task System

This plan outlines the introduction of a task-based system to manage agent behavior, resource claiming, and coordination.

**1. Goals of the Task System:**
    *   **Encapsulate Complexity:** Move multi-step behavior logic out of the `Agent` class and into `Task` objects.
    *   **Improve State Management:** Centralize task-related state (targets, quantities, reservations) within `Task` objects.
    *   **Enhance Scalability:** Make it easier to add new complex agent behaviors by defining new `Task` types.
    *   **Enable Centralized Coordination:** Allow a `TaskManager` to oversee task generation, prioritization, and assignment.
    *   **Improve Robustness:** Provide clearer mechanisms for failure handling and resource reservation.
    *   **Solve Specific Issues:** Address storage race conditions and resource over-collection.

**2. New Core Components & File Structure:**

*   **`src/tasks/task_types.py`**:
    *   `TaskType(Enum)`: e.g., `GATHER_AND_DELIVER`, `PROCESS_RESOURCE`, `COLLECT_PROCESSED_AND_DELIVER`.
    *   `TaskStatus(Enum)`: e.g., `PENDING`, `ASSIGNED`, `PREPARING` (for claims/reservations), `IN_PROGRESS_MOVE_TO_RESOURCE`, `IN_PROGRESS_GATHERING`, `IN_PROGRESS_MOVE_TO_DROPOFF`, `IN_PROGRESS_DELIVERING`, `COMPLETED`, `FAILED`, `CANCELLED`.

*   **`src/tasks/task.py`**:
    *   `Task(ABC)`: Base class for all tasks.
        *   **Attributes:**
            *   `task_id: uuid.UUID` (for unique identification)
            *   `task_type: TaskType`
            *   `status: TaskStatus`
            *   `priority: int`
            *   `agent_id: Optional[uuid.UUID]` (or agent object reference)
            *   `creation_time: float`
            *   `last_update_time: float`
            *   `error_message: Optional[str]`
        *   **Abstract Methods:**
            *   `prepare(self, agent: 'Agent', resource_manager: 'ResourceManager') -> bool`: Handles initial claims and reservations. Returns `True` if successful.
            *   `execute_step(self, agent: 'Agent', dt: float, resource_manager: 'ResourceManager') -> TaskStatus`: Advances the task logic. Returns the new status of the task.
            *   `cleanup(self, agent: 'Agent', resource_manager: 'ResourceManager', success: bool)`: Releases claims/reservations, notifies `TaskManager`.
            *   `get_target_description(self) -> str`: For debugging/UI.
    *   `GatherAndDeliverTask(Task)`: A concrete implementation.
        *   **Additional Attributes:**
            *   `target_resource_node_id: Optional[uuid.UUID]` (or node object reference)
            *   `target_dropoff_id: Optional[uuid.UUID]` (or storage/processor object reference)
            *   `resource_type_to_gather: ResourceType`
            *   `quantity_to_gather: int`
            *   `quantity_gathered: int`
            *   `quantity_to_deliver: int`
            *   `quantity_delivered: int`
            *   `reserved_at_node: bool` (or reference to claim)
            *   `reserved_at_dropoff_quantity: int`
            *   `_current_step_index: int` (internal step management for multi-stage tasks)

*   **`src/tasks/task_manager.py`**:
    *   `TaskManager`:
        *   **Attributes:**
            *   `pending_tasks: List[Task]` (sorted by priority)
            *   `assigned_tasks: Dict[uuid.UUID, Task]` (agent_id -> Task)
            *   `completed_tasks: List[Task]` (for history/metrics)
            *   `failed_tasks: List[Task]` (for analysis/retry)
            *   `resource_manager_ref: 'ResourceManager'`
            *   `agent_manager_ref: 'AgentManager'`
        *   **Methods:**
            *   `create_gather_task(resource_type: ResourceType, quantity: int, priority: int, target_dropoff_category: Optional[str] = None) -> Optional[Task]`: Generates a new `GatherAndDeliverTask`.
            *   `add_task(task: Task)`
            *   `assign_task_to_agent(agent: 'Agent') -> bool`: Finds a suitable pending task and assigns it.
            *   `request_task_for_agent(agent: 'Agent') -> Optional[Task]`: Agent calls this when idle.
            *   `report_task_outcome(task: Task, final_status: TaskStatus, agent: 'Agent')`: Called by `Agent` or `Task` upon completion/failure.
            *   `update()`: Periodic updates, e.g., re-prioritizing, generating recurring tasks.
            *   `get_task_by_id(task_id: uuid.UUID) -> Optional[Task]`

**3. Modifications to Existing Classes:**

*   **`src/agents/agent.py` (`Agent` class):**
    *   **Remove:** `target_resource_node`, `target_storage_point`, `target_processing_station`, `gathering_timer`, `delivery_timer`, complex decision logic in `update()` related to finding targets and managing collection/delivery sequences.
    *   **Add:**
        *   `id: uuid.UUID` (assign in `__init__`)
        *   `current_task: Optional[Task] = None`
        *   `task_manager_ref: Optional['TaskManager'] = None` (passed during init or set later)
    *   **Modify `__init__`:** Accept `id` and `task_manager_ref`.
    *   **Modify `update(dt: float, resource_manager)`:**
        1.  If `current_task` is `None` and `state` is `IDLE`:
            *   Call `self.task_manager_ref.request_task_for_agent(self)`.
            *   If a task is assigned:
                *   Set `self.current_task = assigned_task`.
                *   Set `self.current_task.agent_id = self.id`.
                *   Call `self.current_task.prepare(self, resource_manager)`.
                *   If `prepare` fails, report failure to `TaskManager`, set `current_task` to `None`, remain `IDLE`.
                *   Else, the task's `prepare` or first `execute_step` should set the agent's initial state (e.g., `MOVING_TO_RESOURCE`).
        2.  If `current_task` is not `None`:
            *   `new_task_status = self.current_task.execute_step(self, dt, resource_manager)`.
            *   The `execute_step` method within the task will now be responsible for changing `agent.state` as needed (e.g., `agent.state = AgentState.MOVING_TO_RESOURCE`).
            *   If `new_task_status` is `COMPLETED` or `FAILED` (or `CANCELLED`):
                *   `self.current_task.cleanup(self, resource_manager, success=(new_task_status == TaskStatus.COMPLETED))`.
                *   `self.task_manager_ref.report_task_outcome(self.current_task, new_task_status, self)`.
                *   `self.current_task = None`.
                *   `self.state = AgentState.IDLE`.
    *   Agent's `_move_towards_target` will still be used, but the `target_position` will be set by the `Task` object.
    *   The `AgentState` enum might need fewer specific states if tasks manage sub-steps internally, or tasks can map their internal steps to existing agent states. For now, assume tasks will set existing `AgentState`s.

*   **`src/agents/manager.py` (`AgentManager` class):**
    *   Modify `__init__`: Optionally accept a `TaskManager` reference or create one.
    *   Modify `create_agent`: Ensure new agents get an `id` and a reference to the `TaskManager`.
    *   The `update_agents` method remains largely the same, as it just calls `agent.update()`.

*   **`src/resources/node.py` (`ResourceNode` class):**
    *   Modify `claim()`:
        *   `claim(self, agent_id: uuid.UUID, task_id: uuid.UUID) -> bool`
        *   Change `is_targeted: bool` to `claimed_by_task_id: Optional[uuid.UUID] = None` and `claimed_by_agent_id: Optional[uuid.UUID] = None`.
        *   Claiming succeeds if `claimed_by_task_id` is `None`.
    *   Modify `release()`:
        *   `release(self, agent_id: uuid.UUID, task_id: uuid.UUID)`: Only release if `task_id` matches `claimed_by_task_id`.
        *   Set `claimed_by_task_id = None` and `claimed_by_agent_id = None`.
    *   The `collect_resource` method will be called by the `Task` object.

*   **`src/resources/storage_point.py` (`StoragePoint` class):**
    *   **Add Attributes:**
        *   `reservations: Dict[uuid.UUID, int] = {}` (task_id -> reserved_quantity)
    *   **Add Methods:**
        *   `get_available_capacity_for_reservation() -> int`: `overall_capacity - get_current_load() - sum(reservations.values())`.
        *   `reserve_space(self, task_id: uuid.UUID, resource_type: ResourceType, quantity: int) -> int`:
            *   Checks `accepted_resource_types`.
            *   Checks `get_available_capacity_for_reservation()`.
            *   If successful, adds `task_id: quantity_reserved` to `self.reservations`.
            *   Returns actual quantity reserved.
        *   `release_reservation(self, task_id: uuid.UUID, quantity: int) -> bool`: Removes or reduces reservation for `task_id`.
        *   `commit_reservation_to_storage(self, task_id: uuid.UUID, resource_type: ResourceType, quantity_to_add: int) -> int`:
            *   Checks if `task_id` has a reservation for at least `quantity_to_add`.
            *   Calls `add_resource(resource_type, quantity_to_add)`.
            *   Decrements/removes the reservation from `self.reservations`.
            *   Returns actual quantity added.
    *   Modify `can_accept()`: To also consider `self.reservations` when checking available space for new, non-reserved additions.
    *   Modify `add_resource()`: This method will now primarily be used by `commit_reservation_to_storage` or for direct, non-task-related additions if any.

*   **`src/resources/manager.py` (`ResourceManager` class):**
    *   Likely no major changes needed immediately, as `TaskManager` will use its existing methods (`get_nodes_by_type`, `get_storage_points`, etc.) to find potential targets for tasks.
    *   May need methods to get nodes/storage by ID if tasks store IDs instead of direct references.

**4. Workflow Example (GatherAndDeliverTask):**

1.  **Task Creation:** `TaskManager` creates a `GatherAndDeliverTask` (e.g., "Gather 10 Berries, deliver to Storage X").
2.  **Task Assignment:** An `Agent` becomes `IDLE`, requests a task. `TaskManager` assigns this task.
3.  **Task Preparation (`task.prepare()`):**
    *   The task identifies a suitable `ResourceNode` (e.g., nearest Berry Bush with >0 berries, not fully claimed).
    *   Calls `node.claim(agent.id, self.task_id)`.
    *   The task identifies a suitable `StoragePoint`.
    *   Calls `storage.reserve_space(self.task_id, ResourceType.BERRY, 10)`. Stores `quantity_reserved_at_dropoff`.
    *   If claims/reservations succeed, `prepare` returns `True`. Task status might become `IN_PROGRESS_MOVE_TO_RESOURCE`. Agent state set by task.
4.  **Task Execution (`task.execute_step()` called by `agent.update()`):**
    *   **Step 1: Move to Resource:** Task sets `agent.target_position` to node. Agent moves.
    *   **Step 2: Gather Resource:** Once at node, task initiates gathering (e.g., sets `agent.state = GATHERING_RESOURCE`, manages a timer internally or via agent).
        *   Agent calls `node.collect_resource(min(agent.inventory_capacity, self.quantity_to_gather, node.current_quantity))`.
        *   Task updates `self.quantity_gathered`.
    *   **Step 3: Move to Dropoff:** Task sets `agent.target_position` to storage. Agent moves.
    *   **Step 4: Deliver Resource:** Once at storage, task initiates delivery.
        *   Agent calls `storage.commit_reservation_to_storage(self.task_id, self.resource_type, self.quantity_gathered)`.
        *   Task updates `self.quantity_delivered`.
5.  **Task Completion/Failure:**
    *   If all steps successful, `execute_step` returns `TaskStatus.COMPLETED`.
    *   If any step fails (e.g., node depleted before gathering, storage full despite reservation due to an error), `execute_step` returns `TaskStatus.FAILED`.
    *   Agent calls `task.cleanup()` (releases claims/reservations).
    *   Agent notifies `TaskManager.report_task_outcome()`.
    *   Agent becomes `IDLE`.

**5. Addressing Current Problems:**

*   **Storage Race Condition:** Solved by `StoragePoint.reserve_space()`. A task reserves space *before* the agent gathers the resource. The agent only gathers up to the amount that can be delivered to the reserved space.
*   **Over-Collection:** Solved because the `Task` specifies `quantity_to_gather`, which can be `min(node_has, agent_capacity, task.quantity_reserved_at_dropoff)`.

**6. Transitioning Strategy:**

1.  Implement `TaskType`, `TaskStatus` enums.
2.  Implement the base `Task` class and a simple `GatherAndDeliverTask`.
3.  Implement `StoragePoint` reservation methods.
4.  Implement `ResourceNode` enhanced claim methods.
5.  Implement the `TaskManager` with basic task creation (`create_gather_task`) and assignment logic (`request_task_for_agent`, `report_task_outcome`).
6.  Modify `Agent` class: Add `current_task`, `id`, `task_manager_ref`. Simplify `update()` to delegate to `current_task.execute_step()` and request tasks when idle.
7.  Integrate `TaskManager` into `AgentManager` or main simulation loop.
8.  Start by having `TaskManager` generate one type of task (e.g., `GatherAndDeliverTask` for Berries).
9.  Gradually replace old agent logic for other resources/actions with new task types.

**7. Mermaid Diagram of Key Interactions:**

```mermaid
sequenceDiagram
    participant Agent
    participant TaskManager
    participant Task
    participant ResourceNode
    participant StoragePoint

    Agent->>TaskManager: request_task_for_agent(self)
    TaskManager-->>Agent: assigned_task
    Note over Agent,Task: Agent sets current_task, calls task.prepare()

    Task->>ResourceNode: claim(agent.id, task.id)
    ResourceNode-->>Task: claim_successful
    Task->>StoragePoint: reserve_space(task.id, type, qty)
    StoragePoint-->>Task: qty_reserved
    Task-->>Agent: prepare_successful (sets agent state)

    loop Task Execution (Agent calls task.execute_step())
        Note over Agent,Task: Task.execute_step() manages agent state & actions
        alt Moving to Resource
            Task->>Agent: set_target_position(node.position)
        else Gathering
            Task->>ResourceNode: collect_resource(qty)
            ResourceNode-->>Task: actual_qty_gathered
        else Moving to Dropoff
            Task->>Agent: set_target_position(storage.position)
        else Delivering
            Task->>StoragePoint: commit_reservation_to_storage(task.id, type, qty)
            StoragePoint-->>Task: actual_qty_delivered
        end
    end

    Note over Agent,Task: Task completes or fails
    Task->>Agent: return TaskStatus.COMPLETED / FAILED
    Agent->>Task: task.cleanup()
    Task->>ResourceNode: release(agent.id, task.id)
    Task->>StoragePoint: release_reservation(task.id, qty)
    Agent->>TaskManager: report_task_outcome(task, status, self)
    Note over Agent: Agent becomes IDLE

```
</file>

<file path="src/agents/manager.py">
import pygame
import uuid # For generating agent IDs
from typing import List, TYPE_CHECKING
from .agent import Agent # Relative import from the same package
from ..resources.resource_types import ResourceType

if TYPE_CHECKING:
    from ..tasks.task_manager import TaskManager
    # from ..core.grid import Grid # Assuming Grid class type hint

class AgentManager:
    """Manages all agents in the simulation."""

    def __init__(self, grid, task_manager: 'TaskManager'): # Added task_manager
        """
        Initializes the AgentManager.

        Args:
            grid (Grid): The simulation grid object.
            task_manager (TaskManager): Reference to the task manager.
        """
        self.agents: List[Agent] = []
        self.grid = grid # Store the grid object
        self.task_manager_ref: 'TaskManager' = task_manager # Store task_manager reference

    def add_agent(self, agent: Agent):
        """Adds an existing Agent instance to the manager."""
        self.agents.append(agent)

    def create_agent(self,
                     position: pygame.math.Vector2,
                     speed: float,
                     inventory_capacity: int = 5, # Default value from plan/previous code
                     resource_priorities: List[ResourceType] = None # Default to None or sensible default
                     ) -> Agent:
        """
        Creates a new Agent, adds it to the manager, and returns it.

        Args:
            position (pygame.math.Vector2): The starting position of the agent.
            speed (float): The movement speed of the agent.
            inventory_capacity (int): Agent's inventory capacity.
            resource_priorities (List[ResourceType]): Agent's resource priorities.

        Returns:
            Agent: The newly created agent instance.
        """
        agent_id = uuid.uuid4()
        if resource_priorities is None:
            # Provide a default if not specified, e.g. based on global config or common resources
            resource_priorities = [ResourceType.BERRY, ResourceType.WHEAT]

        new_agent = Agent(
            agent_id=agent_id,
            position=position,
            speed=speed,
            grid=self.grid,
            task_manager=self.task_manager_ref, # Pass the TaskManager reference
            inventory_capacity=inventory_capacity,
            resource_priorities=resource_priorities
        )
        self.add_agent(new_agent)
        print(f"Created agent {agent_id} at {position}") # Debug
        return new_agent

    def update_agents(self, dt: float, resource_manager): # resource_manager type hint can be added
        """Updates all managed agents."""
        for agent in self.agents:
            agent.update(dt, resource_manager)

    def render_agents(self, screen: pygame.Surface, grid):
        """Renders all managed agents."""
        # Render agents after other elements like the grid, but potentially before UI
        for agent in self.agents:
            agent.draw(screen, grid)
</file>

<file path="src/resources/berry_bush.py">
import pygame
from .node import ResourceNode
from src.core import config # Assuming config will have the necessary variables
from ..resources.resource_types import ResourceType # Import ResourceType

class BerryBush(ResourceNode):
    """
    Represents a Berry Bush resource node in the simulation.
    """
    def __init__(self, grid_position: pygame.Vector2): # Position is now grid_position
        """
        Initializes a BerryBush node.

        Args:
            grid_position: The grid coordinates of the bush (pygame.Vector2).
        """
        # Use configuration values for capacity and generation rate
        super().__init__(
            position=grid_position, # Store grid_position
            capacity=config.BERRY_BUSH_CAPACITY,
            generation_interval=config.BERRY_BUSH_GENERATION_INTERVAL,
            resource_type=ResourceType.BERRY
        )
        # Size of the bush representation (visual size on screen)
        self.display_size = config.GRID_CELL_SIZE # This is a pixel size for drawing
        # self.rect is now calculated in draw() as it depends on screen coordinates


    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Add grid parameter
        """
        Draws the berry bush (a square) and its current resource count.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering the resource count.
            grid: The game grid object for coordinate conversions.
        """
        # Convert grid position to screen position for drawing
        screen_pos = grid.grid_to_screen(self.position)

        # Calculate the rect for drawing based on screen position
        # self.position is grid coords, screen_pos is pixel coords (center of cell)
        draw_rect = pygame.Rect(
            screen_pos[0] - self.display_size / 2,
            screen_pos[1] - self.display_size / 2,
            self.display_size,
            self.display_size
        )

        # Draw the bush square
        pygame.draw.rect(surface, config.BERRY_BUSH_COLOR, draw_rect)

        # Draw the resource count text
        resource_text = f"{int(self.current_quantity)}"
        text_surface = font.render(resource_text, True, config.RESOURCE_TEXT_COLOR)
        # Center text on the screen position of the bush
        text_rect = text_surface.get_rect(center=screen_pos)
        surface.blit(text_surface, text_rect)

    # update method is inherited from ResourceNode
    # collect method is inherited from ResourceNode
</file>

<file path="src/resources/storage_point.py">
import pygame
import uuid # Added for task_id in reservations
from typing import List, Dict, Optional

# Assuming ResourceType is defined in resource_types.py
from .resource_types import ResourceType

class StoragePoint:
    """Represents a location where agents can drop off collected resources, with reservation capabilities."""

    def __init__(self,
                 position: pygame.math.Vector2,
                 overall_capacity: int,
                 accepted_resource_types: Optional[List[ResourceType]] = None):
        """
        Initializes a StoragePoint.

        Args:
            position (pygame.math.Vector2): The grid coordinates of the storage point.
            overall_capacity (int): The maximum total quantity of all resources this point can hold.
            accepted_resource_types (Optional[List[ResourceType]]): A list of resource types
                                     this storage point accepts. If None, accepts all types.
        """
        self.position = position
        self.overall_capacity = overall_capacity
        self.accepted_resource_types = accepted_resource_types
        self.stored_resources: Dict[ResourceType, int] = {}
        self.reservations: Dict[uuid.UUID, int] = {} # task_id -> reserved_quantity

    def get_current_load(self) -> int:
        """Returns the total quantity of all resources currently physically stored."""
        return sum(self.stored_resources.values())

    def get_total_reserved_quantity(self) -> int:
        """Returns the total quantity of all resources currently reserved."""
        return sum(self.reservations.values())

    def get_available_capacity_for_reservation(self) -> int:
        """Calculates space available for new reservations."""
        return self.overall_capacity - self.get_current_load() - self.get_total_reserved_quantity()

    def can_accept(self, resource_type: ResourceType, quantity: int, for_reservation: bool = False) -> bool:
        """
        Checks if the storage point can accept a given quantity of a resource type.
        If for_reservation is True, checks against capacity available for new reservations.
        Otherwise, checks against overall capacity minus existing reservations (for direct non-task additions).
        """
        if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
            return False
        
        if for_reservation:
            if quantity > self.get_available_capacity_for_reservation():
                return False
        else: # Checking for a direct, non-reserved addition
            # A direct addition must fit into space not physically filled and not already reserved by others.
            if self.get_current_load() + quantity > self.overall_capacity - self.get_total_reserved_quantity():
                return False
        return True

    def reserve_space(self, task_id: uuid.UUID, resource_type: ResourceType, quantity: int) -> int:
        """
        Attempts to reserve space for a given task.

        Args:
            task_id (uuid.UUID): The ID of the task making the reservation.
            resource_type (ResourceType): The type of resource to reserve space for.
            quantity (int): The amount of space to reserve.

        Returns:
            int: The actual quantity of space reserved. Can be less than requested if
                 not enough space is available or 0 if type not accepted or no space.
        """
        if task_id in self.reservations: # Task already has a reservation, should modify or release first
            print(f"Warning: Task {task_id} attempting to reserve space again. Current reservation: {self.reservations[task_id]}")
            # Potentially allow modification, but for now, let's assume new reservation means prior one should be handled.
            # Or, this could be an addition to an existing reservation. For simplicity, let's make it overwrite/add.
            # self.reservations[task_id] += quantity_to_reserve ... (this needs careful thought)
            # For now, let's assume a task makes one reservation request that should be sufficient.
            # If a task needs to change its reservation, it should release and re-reserve.
            # This simplifies logic. If this call happens, it's likely an error in task logic or a new reservation.
            # Let's assume it's a new reservation attempt.
            pass # Allow re-evaluation if needed.

        if not self.can_accept(resource_type, quantity, for_reservation=True):
            # Try to reserve as much as possible
            available_for_res = self.get_available_capacity_for_reservation()
            if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
                 return 0 # Cannot accept this type at all
            
            quantity_to_reserve = min(quantity, available_for_res)
            if quantity_to_reserve <= 0:
                return 0
        else:
            quantity_to_reserve = quantity
        
        # Add to existing reservation for the task or create a new one
        self.reservations[task_id] = self.reservations.get(task_id, 0) + quantity_to_reserve
        print(f"Storage at {self.position} reserved {quantity_to_reserve} for task {task_id}. Total reserved: {self.get_total_reserved_quantity()}")
        return quantity_to_reserve

    def release_reservation(self, task_id: uuid.UUID, quantity_to_release: Optional[int] = None) -> bool:
        """
        Releases a reservation made by a task.

        Args:
            task_id (uuid.UUID): The ID of the task whose reservation is to be released.
            quantity_to_release (Optional[int]): The amount of reservation to release.
                                                 If None, releases the entire reservation for the task.

        Returns:
            bool: True if the reservation was found and released/reduced, False otherwise.
        """
        if task_id not in self.reservations:
            return False
        
        if quantity_to_release is None or quantity_to_release >= self.reservations[task_id]:
            released_amount = self.reservations.pop(task_id)
            print(f"Storage at {self.position} fully released reservation of {released_amount} for task {task_id}.")
        else:
            self.reservations[task_id] -= quantity_to_release
            print(f"Storage at {self.position} reduced reservation by {quantity_to_release} for task {task_id}. Remaining: {self.reservations[task_id]}")
        return True

    def commit_reservation_to_storage(self, task_id: uuid.UUID, resource_type: ResourceType, quantity_to_add: int) -> int:
        """
        Commits a previously reserved quantity of a resource to actual storage.
        This will decrease the reservation and increase stored_resources.

        Args:
            task_id (uuid.UUID): The task ID that holds the reservation.
            resource_type (ResourceType): The type of resource being added.
            quantity_to_add (int): The quantity to add from the reservation.

        Returns:
            int: The actual quantity added to storage.
        """
        if task_id not in self.reservations:
            print(f"Error: Task {task_id} has no reservation at {self.position} to commit.")
            return 0 # No reservation for this task

        reserved_for_task = self.reservations[task_id]
        if quantity_to_add > reserved_for_task:
            print(f"Warning: Task {task_id} trying to commit {quantity_to_add} but only {reserved_for_task} reserved. Committing max reserved.")
            quantity_to_add = reserved_for_task # Cannot add more than reserved by this task

        # Actual addition to storage - this uses the existing add_resource logic but bypasses some checks
        # as the space was already accounted for by the reservation.
        # However, add_resource itself checks overall_capacity.
        # We need a way to ensure this addition is "safe" because it was reserved.

        # Simplified: directly add to stored_resources and adjust reservation
        # Check if type is accepted (should have been checked at reservation time too)
        if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
            print(f"Error: Task {task_id} trying to commit unaccepted type {resource_type.name} at {self.position}.")
            return 0 # Should not happen if reservation was done correctly

        # Check if physical space is available (current_load + quantity_to_add <= overall_capacity)
        # This check is vital because reservations are conceptual; physical space is paramount.
        if self.get_current_load() + quantity_to_add > self.overall_capacity:
            # This indicates a problem: reservation allowed more than physical capacity.
            # Or, other non-reserved items filled up space.
            # For now, only add what physically fits.
            can_physically_add = self.overall_capacity - self.get_current_load()
            if quantity_to_add > can_physically_add:
                 print(f"Critical Warning: Task {task_id} at {self.position}: Physical space ({can_physically_add}) less than committed quantity ({quantity_to_add}) from reservation. Data integrity issue or race condition?")
                 quantity_to_add = can_physically_add
            
            if quantity_to_add <= 0:
                return 0


        if quantity_to_add > 0:
            current_amount = self.stored_resources.get(resource_type, 0)
            self.stored_resources[resource_type] = current_amount + quantity_to_add
            
            # Reduce or remove reservation
            if quantity_to_add >= reserved_for_task:
                self.reservations.pop(task_id)
            else:
                self.reservations[task_id] -= quantity_to_add
            
            print(f"Storage at {self.position} committed {quantity_to_add} of {resource_type.name} from task {task_id}. Stored: {self.stored_resources.get(resource_type, 0)}, Remaining Res for task: {self.reservations.get(task_id, 0)}")
            return quantity_to_add
        return 0


    def add_resource(self, resource_type: ResourceType, quantity: int) -> int:
        """
        Adds a quantity of a specific resource type to the storage.
        This is for direct additions, not via reservations.
        It must respect space not already reserved by other tasks.

        Args:
            resource_type (ResourceType): The type of resource to add.
            quantity (int): The amount of resource to add.

        Returns:
            int: The actual quantity of the resource added (might be less than requested
                 if capacity is exceeded or type not accepted).
        """
        # Use the modified can_accept for non-reservation additions
        if not self.can_accept(resource_type, quantity, for_reservation=False):
            if self.accepted_resource_types is not None and resource_type not in self.accepted_resource_types:
                return 0

            # Calculate available capacity considering other reservations
            available_for_direct_add = self.overall_capacity - self.get_current_load() - self.get_total_reserved_quantity()
            quantity_to_add = min(quantity, available_for_direct_add)

            if quantity_to_add <= 0:
                return 0
        else:
            quantity_to_add = quantity
        
        if quantity_to_add > 0:
            current_amount = self.stored_resources.get(resource_type, 0)
            self.stored_resources[resource_type] = current_amount + quantity_to_add
            print(f"Storage at {self.position} (direct add) received {quantity_to_add} of {resource_type.name}. Total stored: {self.stored_resources.get(resource_type, 0)}")
        return quantity_to_add

    def draw(self, screen: pygame.Surface, grid):
        """Draws the storage point on the screen."""
        screen_pos = grid.grid_to_screen(self.position)
        color = (128, 128, 128) # Grey for storage
        radius = grid.cell_width // 2
        pygame.draw.rect(screen, color, (screen_pos[0] - radius, screen_pos[1] - radius, grid.cell_width, grid.cell_height))
        # Optionally, draw stored resource counts or indicators
</file>

<file path="src/tasks/task_manager.py">
import uuid
import time
from typing import List, Dict, Optional, TYPE_CHECKING

from .task import Task, GatherAndDeliverTask # Assuming task.py is in the same directory
from .task_types import TaskType, TaskStatus
from ..resources.resource_types import ResourceType # Assuming this path
from ..core import config # For task generation settings

# Forward references to avoid circular imports
if TYPE_CHECKING:
    from ..agents.agent import Agent
    from ..agents.manager import AgentManager
    from ..resources.manager import ResourceManager

class TaskManager:
    """Manages the creation, assignment, and tracking of tasks for agents."""

    def __init__(self, resource_manager: 'ResourceManager', agent_manager: 'AgentManager'):
        self.pending_tasks: List[Task] = []
        self.assigned_tasks: Dict[uuid.UUID, Task] = {} # agent_id -> Task
        self.completed_tasks: List[Task] = [] # For history/metrics
        self.failed_tasks: List[Task] = []     # For analysis/retry
        
        self.resource_manager_ref: 'ResourceManager' = resource_manager
        self.agent_manager_ref: 'AgentManager' = agent_manager
        
        self._next_task_check_time: float = time.time()
        self._task_generation_interval: float = 5.0 # How often to check for new task generation

    def add_task(self, task: Task):
        """Adds a pre-created task to the pending list, sorted by priority."""
        # Higher priority number means more important
        self.pending_tasks.append(task)
        self.pending_tasks.sort(key=lambda t: t.priority, reverse=True)
        print(f"DEBUG: TaskManager: Added new task {task.task_id} ({task.task_type.name}) P:{task.priority} to job board. Board size: {len(self.pending_tasks)}")

    def create_gather_task(self,
                           resource_type: ResourceType,
                           quantity: int,
                           priority: int,
                           target_dropoff_id: Optional[uuid.UUID] = None, # Optional: specific dropoff
                           target_resource_node_id: Optional[uuid.UUID] = None # Optional: specific node
                           ) -> Optional[Task]:
        """
        Creates a new GatherAndDeliverTask and adds it to the pending list.
        The actual finding of suitable nodes/dropoffs if not specified will occur in Task.prepare().
        """
        # Basic validation: Ensure resource manager can find nodes/dropoffs for this type
        # This is a pre-check; Task.prepare() does the actual claiming/reservation.
        # For now, we assume the task can be created and prepare() will validate further.
        
        task = GatherAndDeliverTask(
            priority=priority,
            resource_type_to_gather=resource_type,
            quantity_to_gather=quantity,
            target_resource_node_id=target_resource_node_id,
            target_dropoff_id=target_dropoff_id
        )
        self.add_task(task)
        return task

    # def request_task_for_agent(self, agent: 'Agent') -> Optional[Task]:
    #     """
    #     DEPRECATED: Agents will now pull tasks from the job board.
    #     Assigns the highest priority available task to the given agent if one exists.
    #     Called by an agent when it becomes IDLE.
    #     """
    #     if not self.pending_tasks:
    #         return None
    #
    #     # Get the highest priority task
    #     # TODO: Add more sophisticated matching (e.g., agent skills, proximity, current inventory)
    #     task_to_assign = self.pending_tasks.pop(0) # Highest priority due to sort
    #
    #     task_to_assign.agent_id = agent.id
    #     task_to_assign.status = TaskStatus.ASSIGNED # Mark as assigned before prepare
    #     self.assigned_tasks[agent.id] = task_to_assign
    #
    #     print(f"TaskManager: Assigning task {task_to_assign.task_id} ({task_to_assign.task_type.name}) to agent {agent.id}. Assigned: {len(self.assigned_tasks)}")
    #     return task_to_assign

    def get_available_tasks(self) -> List[Task]:
        """Returns the current list of tasks on the job board (pending_tasks)."""
        return self.pending_tasks

    def attempt_claim_task(self, task_id: uuid.UUID, agent: 'Agent') -> Optional[Task]:
        """
        Allows an agent to attempt to claim a task from the job board.
        Returns the task if successfully claimed, None otherwise.
        """
        task_to_claim = None
        for i, task in enumerate(self.pending_tasks):
            if task.task_id == task_id:
                task_to_claim = self.pending_tasks.pop(i)
                break
        
        if task_to_claim:
            task_to_claim.agent_id = agent.id
            task_to_claim.status = TaskStatus.ASSIGNED # Or PREPARING if prepare is called immediately
            self.assigned_tasks[agent.id] = task_to_claim
            print(f"TaskManager: Task {task_to_claim.task_id} ({task_to_claim.task_type.name}) CLAIMED by agent {agent.id}. Pending: {len(self.pending_tasks)}, Assigned: {len(self.assigned_tasks)}")
            return task_to_claim
        else:
            print(f"TaskManager: Agent {agent.id} FAILED to claim task {task_id}. Task not found or already claimed.")
            return None

    def report_task_outcome(self, task: Task, final_status: TaskStatus, agent: 'Agent'):
        """
        Called by an Agent when its current task is finished (completed, failed, or cancelled).
        """
        task.status = final_status # Ensure final status is set on the task object
        task.last_update_time = time.time()

        if agent.id in self.assigned_tasks and self.assigned_tasks[agent.id].task_id == task.task_id:
            del self.assigned_tasks[agent.id]
        else:
            print(f"Warning: TaskManager received outcome for task {task.task_id} from agent {agent.id}, but it was not in assigned_tasks or mismatch.")

        if final_status == TaskStatus.COMPLETED:
            self.completed_tasks.append(task)
            print(f"TaskManager: Task {task.task_id} COMPLETED by agent {agent.id}. Completed: {len(self.completed_tasks)}")
        elif final_status == TaskStatus.FAILED:
            self.failed_tasks.append(task) # Keep a record of failed tasks
            print(f"TaskManager: Task {task.task_id} FAILED for agent {agent.id}. Reason: {task.error_message}. Failed list size: {len(self.failed_tasks)}")
            
            # Re-post task to job board (simple re-posting for now)
            # TODO: Add more sophisticated logic for re-posting (e.g., delay, modification, max retries)
            print(f"DEBUG: TaskManager: Re-posting task {task.task_id} ({task.task_type.name}) to job board due to FAILED status.")
            task.status = TaskStatus.PENDING # Reset status
            task.agent_id = None # Unassign agent
            # task.error_message = None # Optionally clear error message or append to a list of errors
            self.add_task(task) # add_task handles sorting by priority

        elif final_status == TaskStatus.CANCELLED:
            # If cancelled, it might just be removed or put in a separate list
            # For now, treat like failed for tracking, or add a cancelled_tasks list.
            # Depending on policy, cancelled tasks might also be re-posted or archived.
            self.failed_tasks.append(task) # Or a self.cancelled_tasks list
            print(f"TaskManager: Task {task.task_id} CANCELLED for agent {agent.id}. Added to failed/cancelled list.")


    def update(self, dt: float):
        """
        Periodic update for the TaskManager.
        - Can generate new tasks based on simulation state (e.g., low resources).
        - Can re-prioritize tasks.
        - Can check for timed-out tasks.
        """
        current_time = time.time()
        if current_time >= self._next_task_check_time:
            print(f"DEBUG: TaskManager: Update - time to check for task generation. Current time: {current_time:.2f}, Next check: {self._next_task_check_time:.2f}")
            self._generate_tasks_if_needed()
            self._next_task_check_time = current_time + self._task_generation_interval
        # else:
            # print(f"DEBUG: TaskManager: Update - NOT time to check for task generation. Current time: {current_time:.2f}, Next check: {self._next_task_check_time:.2f}")


        # TODO: Check for tasks that are assigned but stuck (e.g., agent died, task timed out)
        # This would involve iterating self.assigned_tasks and checking task.last_update_time

    def _generate_tasks_if_needed(self):
        """
        Generates tasks based on simulation state, e.g., low resource stock.
        Currently implements logic for Berry stock.
        """
        # --- Berry Task Generation ---
        current_berry_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.BERRY)
        
        # print(f"DEBUG TaskManager: Current global berry stock: {current_berry_stock}, Min Level: {config.MIN_BERRY_STOCK_LEVEL}") # Debug

        if current_berry_stock < config.MIN_BERRY_STOCK_LEVEL:
            # Count existing GATHER_AND_DELIVER tasks for BERRY (pending or assigned)
            active_berry_gather_tasks = sum(
                1 for task in self.pending_tasks
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.BERRY
            )
            active_berry_gather_tasks += sum(
                1 for task in self.assigned_tasks.values()
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.BERRY
            )

            # print(f"DEBUG TaskManager: Active berry gather tasks: {active_berry_gather_tasks}, Max Allowed: {config.MAX_ACTIVE_BERRY_GATHER_TASKS}") # Debug

            if active_berry_gather_tasks < config.MAX_ACTIVE_BERRY_GATHER_TASKS:
                print(f"DEBUG: TaskManager: Low Berry Stock ({current_berry_stock} < {config.MIN_BERRY_STOCK_LEVEL}). Generating new GatherAndDeliverTask for BERRY.")
                self.create_gather_task(
                    resource_type=ResourceType.BERRY,
                    quantity=config.BERRY_GATHER_TASK_QUANTITY,
                    priority=config.BERRY_GATHER_TASK_PRIORITY
                )
            else:
                print(f"DEBUG: TaskManager: Berry stock low ({current_berry_stock}), but max active berry tasks ({active_berry_gather_tasks}/{config.MAX_ACTIVE_BERRY_GATHER_TASKS}) reached. No new BERRY task.")
        # else:
            # print(f"DEBUG TaskManager: Berry stock ({current_berry_stock}) is sufficient. No new berry task needed.") # Debug

# --- Wheat Task Generation ---
        current_wheat_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.WHEAT)
        
        # print(f"DEBUG TaskManager: Current global wheat stock: {current_wheat_stock}, Min Level: {config.MIN_WHEAT_STOCK_LEVEL}") # Debug

        if current_wheat_stock < config.MIN_WHEAT_STOCK_LEVEL:
            active_wheat_gather_tasks = sum(
                1 for task in self.pending_tasks
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.WHEAT
            )
            active_wheat_gather_tasks += sum(
                1 for task in self.assigned_tasks.values()
                if isinstance(task, GatherAndDeliverTask) and task.resource_type_to_gather == ResourceType.WHEAT
            )

            # print(f"DEBUG TaskManager: Active wheat gather tasks: {active_wheat_gather_tasks}, Max Allowed: {config.MAX_ACTIVE_WHEAT_GATHER_TASKS}") # Debug

            if active_wheat_gather_tasks < config.MAX_ACTIVE_WHEAT_GATHER_TASKS:
                print(f"DEBUG: TaskManager: Low Wheat Stock ({current_wheat_stock} < {config.MIN_WHEAT_STOCK_LEVEL}). Generating new GatherAndDeliverTask for WHEAT.")
                self.create_gather_task(
                    resource_type=ResourceType.WHEAT,
                    quantity=config.WHEAT_GATHER_TASK_QUANTITY,
                    priority=config.WHEAT_GATHER_TASK_PRIORITY
                )
            else:
                print(f"DEBUG: TaskManager: Wheat stock low ({current_wheat_stock}), but max active wheat tasks ({active_wheat_gather_tasks}/{config.MAX_ACTIVE_WHEAT_GATHER_TASKS}) reached. No new WHEAT task.")
        # else:
            # print(f"DEBUG TaskManager: Wheat stock ({current_wheat_stock}) is sufficient. No new wheat task needed.") # Debug
        # TODO: Future: Add logic for other resource types here, following a similar pattern.
        # Example: Check Wheat storage and create tasks if low (conceptual)
        # current_wheat_stock = self.resource_manager_ref.get_global_resource_quantity(ResourceType.WHEAT)
        # if current_wheat_stock < getattr(config, 'MIN_WHEAT_STOCK_LEVEL', 0): # Assuming MIN_WHEAT_STOCK_LEVEL in config
        #     # ... similar logic to create wheat gathering tasks ...
        #     pass


    def get_task_by_id(self, task_id: uuid.UUID) -> Optional[Task]:
        """Retrieves a task by its ID from any of the lists."""
        for task_list in [self.pending_tasks, list(self.assigned_tasks.values()), self.completed_tasks, self.failed_tasks]:
            for task in task_list:
                if task.task_id == task_id:
                    return task
        return None

    def get_all_tasks_count(self) -> Dict[str, int]:
        return {
            "pending": len(self.pending_tasks),
            "assigned": len(self.assigned_tasks),
            "completed": len(self.completed_tasks),
            "failed": len(self.failed_tasks)
        }
</file>

<file path="src/resources/node.py">
import pygame
import uuid # For task and agent IDs
from typing import Optional # For Optional type hints
from abc import ABC, abstractmethod
from ..resources.resource_types import ResourceType # Import ResourceType

class ResourceNode(ABC):
    """
    Base class for resource nodes in the simulation.
    """
    def __init__(self, position: pygame.Vector2, capacity: int, generation_interval: float, resource_type: ResourceType):
        """
        Initializes a ResourceNode.

        Args:
            position: The position of the node on the grid (pygame.Vector2).
            capacity: The maximum amount of resources the node can hold (integer units).
            generation_interval: The interval at which resources are generated (in seconds).
            resource_type: The type of resource this node provides.
        """
        if not isinstance(position, pygame.Vector2):
            raise TypeError("Position must be a pygame.Vector2")
        self.position = position
        self.capacity = int(capacity) # Ensure capacity is integer
        self.generation_interval = generation_interval
        self.resource_type = resource_type # Added
        self.current_quantity = 0
        self._generation_timer = 0.0 
        
        # --- Attributes for task-based claiming ---
        self.claimed_by_task_id: Optional[uuid.UUID] = None
        self.claimed_by_agent_id: Optional[uuid.UUID] = None

    def update(self, dt: float):
        """
        Updates the resource node's state, generating resources over time.

        Args:
            dt: The time elapsed since the last update in seconds.
        """
        if self.current_quantity < self.capacity:
            self._generation_timer += dt
            resources_to_add = int(self._generation_timer / self.generation_interval)
            if resources_to_add > 0:
                self._generation_timer -= resources_to_add * self.generation_interval
                # Don't overfill
                resources_needed = self.capacity - self.current_quantity
                actual_to_add = min(resources_to_add, resources_needed)
                self.current_quantity += actual_to_add

    # --- Methods for task-based claiming ---
    def claim(self, agent_id: uuid.UUID, task_id: uuid.UUID) -> bool:
        """
        Attempts to claim this resource node for a specific task and agent.
        Returns True if successful (node was not already claimed), False otherwise.
        """
        if self.claimed_by_task_id is None:
            self.claimed_by_task_id = task_id
            self.claimed_by_agent_id = agent_id
            # print(f"DEBUG: Node {self.position} claimed by task {task_id} for agent {agent_id}.")
            return True
        # print(f"DEBUG: Node {self.position} FAILED to claim by task {task_id} (already claimed by task {self.claimed_by_task_id}).")
        return False

    def release(self, agent_id: uuid.UUID, task_id: uuid.UUID):
        """
        Releases the claim on this resource node if the provided task_id matches the current claim.
        """
        if self.claimed_by_task_id == task_id:
            # Optional: could also check agent_id for stricter release conditions
            # if self.claimed_by_agent_id == agent_id:
            self.claimed_by_task_id = None
            self.claimed_by_agent_id = None
            # print(f"DEBUG: Node {self.position} released by task {task_id} from agent {agent_id}.")
        # else:
            # print(f"DEBUG: Node {self.position} release called by task {task_id} but was claimed by {self.claimed_by_task_id} (or not claimed).")

    @abstractmethod
    def draw(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Added grid
        """
        Draws the resource node on the given surface.
        This method must be implemented by subclasses.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object, potentially for coordinate transformations or cell information.
        """
        pass

    def collect_resource(self, amount_to_collect: int) -> int:
        """
        Attempts to collect a specified integer amount of resources from the node.

        Args:
            amount_to_collect: The integer amount of resources to attempt to collect.

        Returns:
            The actual integer amount of resources collected (can be less than requested).
        """
        
        collectable_amount = min(amount_to_collect, self.current_quantity)
        
        if collectable_amount > 0:
            self.current_quantity -= collectable_amount
            # Ensure resources don't go below zero (shouldn't happen with min logic)
            self.current_quantity = max(0.0, self.current_quantity)
            print(f"Node at {self.position} ({self.resource_type.name}) collected {collectable_amount}, remaining: {self.current_quantity:.2f}") # Debug
        return collectable_amount
</file>

<file path="src/resources/manager.py">
import pygame
from typing import List, TYPE_CHECKING, Optional
from .node import ResourceNode # Use relative import within the package
from .resource_types import ResourceType # For get_nodes_by_type
from .processing import ProcessingStation # For managing processing stations

# Forward reference for StoragePoint to avoid circular import if StoragePoint imports ResourceManager
if TYPE_CHECKING:
    from .storage_point import StoragePoint
    # ProcessingStation does not import ResourceManager, so forward ref not strictly needed here
    # but can be kept for consistency if desired.
    # from .processing import ProcessingStation

class ResourceManager:
    """
    Manages all resource nodes, storage points, and processing stations in the simulation.
    """
    def __init__(self):
        """
        Initializes the ResourceManager with empty lists for managed objects.
        """
        self.nodes: List[ResourceNode] = []
        self.storage_points: List['StoragePoint'] = []
        self.processing_stations: List[ProcessingStation] = []

    def add_node(self, node: ResourceNode):
        """
        Adds a resource node to the manager.

        Args:
            node: The ResourceNode instance to add.
        """
        if isinstance(node, ResourceNode):
            self.nodes.append(node)
        else:
            # Simple error handling, could be more robust (e.g., logging)
            print(f"Error: Attempted to add non-ResourceNode object to ResourceManager: {node}")

    def add_storage_point(self, storage_point: 'StoragePoint'):
        """
        Adds a storage point to the manager.

        Args:
            storage_point: The StoragePoint instance to add.
        """
        # Can add type checking if StoragePoint is directly imported
        # from .storage_point import StoragePoint
        # if isinstance(storage_point, StoragePoint):
        self.storage_points.append(storage_point)
        # else:
        #     print(f"Error: Attempted to add non-StoragePoint object to ResourceManager: {storage_point}")

    def add_processing_station(self, station: ProcessingStation):
        """
        Adds a processing station to the manager.

        Args:
            station: The ProcessingStation instance to add.
        """
        if isinstance(station, ProcessingStation):
            self.processing_stations.append(station)
        else:
            print(f"Error: Attempted to add non-ProcessingStation object to ResourceManager: {station}")

    def get_nodes_by_type(self, resource_type: ResourceType) -> List[ResourceNode]:
        """
        Returns a list of resource nodes of a specific type.
        """
        return [node for node in self.nodes if hasattr(node, 'resource_type') and node.resource_type == resource_type]

    def update_nodes(self, dt: float):
        """
        Updates all managed resource nodes and processing stations.

        Args:
            dt: The time elapsed since the last update in seconds (for ResourceNodes).
        """
        for node in self.nodes:
            node.update(dt)
        
        for station in self.processing_stations:
            station.tick() # Processing stations are updated per tick

    def draw_nodes(self, surface: pygame.Surface, font: pygame.font.Font, grid): # Add grid parameter
        """
        Draws all managed resource nodes, storage points, and processing stations.

        Args:
            surface: The pygame surface to draw on.
            font: The pygame font to use for rendering text.
            grid: The game grid object for coordinate conversions (used by some draw methods).
        """
        for node in self.nodes:
            if hasattr(node, 'draw'):
                # All ResourceNode subclasses (including WheatField and BerryBush)
                # are now expected to have a draw(self, surface, font, grid) method.
                node.draw(surface, font, grid)

        for sp in self.storage_points:
            if hasattr(sp, 'draw'):
                # StoragePoint.draw is expected to take (surface, grid)
                sp.draw(surface, grid)
        
        for station in self.processing_stations:
            if hasattr(station, 'draw'):
                # ProcessingStation.draw takes (surface, font)
                station.draw(surface, font)

    def get_nearest_station_accepting(self, current_position: pygame.Vector2, resource_type: ResourceType) -> Optional[ProcessingStation]:
        """
        Finds the nearest processing station that accepts a given resource type and has input capacity.
        """
        available_stations = [
            s for s in self.processing_stations
            if s.can_accept_input(resource_type)
        ]

        if not available_stations:
            return None

        nearest_station = min(
            available_stations,
            key=lambda s: current_position.distance_squared_to(s.position)
        )
        return nearest_station

    def get_stations_with_output(self, resource_type: ResourceType) -> List[ProcessingStation]:
        """
        Returns a list of processing stations that have the specified processed resource type available.
        """
        return [
            s for s in self.processing_stations
            if s.produced_output_type == resource_type and s.has_output()
        ]
    def get_global_resource_quantity(self, resource_type: ResourceType) -> int:
        """
        Calculates the total quantity of a specific resource type across all storage points.

        Args:
            resource_type: The ResourceType to query.

        Returns:
            The total integer quantity of the specified resource.
        """
        total_quantity = 0
        for sp in self.storage_points:
            # The 'stored_resources' attribute in StoragePoint is a Dict[ResourceType, int]
            total_quantity += sp.stored_resources.get(resource_type, 0)
        return total_quantity

    def has_available_sources(self, resource_type: ResourceType, min_quantity: int = 1) -> bool:
        """
        Checks if there are any available (unclaimed and with sufficient quantity)
        resource nodes for a given resource type.
        """
        for node in self.nodes:
            if node.resource_type == resource_type and \
               node.current_quantity >= min_quantity and \
               node.claimed_by_task_id is None:
                return True
        return False

    def has_available_dropoffs(self, resource_type: ResourceType, min_capacity: int = 1) -> bool:
        """
        Checks if there are any storage points that accept the given resource type
        and have available capacity for reservation/dropoff.
        """
        # Import StoragePoint here if not already available due to TYPE_CHECKING
        # from .storage_point import StoragePoint # Not strictly needed if using 'StoragePoint' string hint

        for sp in self.storage_points:
            # Ensure sp is an instance of StoragePoint if type hints are loose
            # For now, we assume self.storage_points only contains StoragePoint instances
            if sp.can_accept(resource_type, quantity=min_capacity, for_reservation=True): # Checks accepted types and available capacity
                return True
        
        # Future: Could extend to check ProcessingStation input buffers if tasks involve delivering to them
        # for station in self.processing_stations:
        #     if station.accepted_input_type == resource_type and station.can_accept_input(resource_type, min_capacity):
        #         return True
        return False
</file>

<file path="src/agents/agent.py">
import pygame
import uuid # For agent ID
from enum import Enum, auto
import random
from typing import List, Dict, Optional, TYPE_CHECKING
import math # For math.inf

from ..resources.resource_types import ResourceType
from ..core import config # Agent still uses config for timers, capacity if not overridden by task

# Forward references for type hinting
if TYPE_CHECKING:
    from ..tasks.task import Task
    from ..tasks.task_manager import TaskManager
    from ..resources.manager import ResourceManager # For passing to tasks
    # from ..core.grid import Grid # Assuming Grid class type hint


class AgentState(Enum):
    """Defines the possible states an agent can be in. Tasks will set these."""
    IDLE = auto()
    MOVING_RANDOMLY = auto()
    MOVING_TO_RESOURCE = auto()
    GATHERING_RESOURCE = auto()
    MOVING_TO_STORAGE = auto()
    DELIVERING_RESOURCE = auto()
    MOVING_TO_PROCESSOR = auto()
    DELIVERING_TO_PROCESSOR = auto()
    COLLECTING_FROM_PROCESSOR = auto()
    EVALUATING_TASKS = auto() # New state for job board interaction

class Agent:
    """Represents an autonomous agent in the simulation, executing tasks."""

    def __init__(self,
                 agent_id: uuid.UUID, 
                 position: pygame.math.Vector2,
                 speed: float,
                 grid, # 'Grid' type hint
                 task_manager: 'TaskManager', 
                 inventory_capacity: int,
                 resource_priorities: Optional[List[ResourceType]] = None):
        """
        Initializes an Agent.
        Args:
            agent_id (uuid.UUID): Unique identifier for this agent.
            position (pygame.math.Vector2): The starting grid coordinates of the agent.
            speed (float): The movement speed of the agent (grid units per second).
            grid (Grid): The simulation grid object.
            task_manager (TaskManager): Reference to the global task manager.
            inventory_capacity (int): Maximum number of resource units the agent can carry.
            resource_priorities (Optional[List[ResourceType]]): Ordered list of resource types the agent prefers.
                                                               Might be used by TaskManager.
        """
        self.id: uuid.UUID = agent_id
        self.position = position
        self.speed = speed
        self.grid = grid # type: ignore
        self.task_manager_ref: 'TaskManager' = task_manager
        self.config = config 

        self.state = AgentState.IDLE
        self.target_position: Optional[pygame.math.Vector2] = None # Set by tasks
        self.color = (255, 255, 0)

        self.state_colors = {
            AgentState.IDLE: (255, 255, 0),
            AgentState.MOVING_RANDOMLY: (255, 165, 0),
            AgentState.MOVING_TO_RESOURCE: (0, 200, 50),
            AgentState.GATHERING_RESOURCE: (50, 150, 255),
            AgentState.MOVING_TO_STORAGE: (0, 200, 200),
            AgentState.DELIVERING_RESOURCE: (100, 100, 255),
            AgentState.MOVING_TO_PROCESSOR: (255, 140, 0),
            AgentState.DELIVERING_TO_PROCESSOR: (138, 43, 226),
            AgentState.COLLECTING_FROM_PROCESSOR: (0, 128, 128),
            AgentState.EVALUATING_TASKS: (200, 200, 200), # Light grey for evaluating
        }
        self.target_tolerance = 0.1
        self.task_evaluation_cooldown = 1.0 # Seconds before trying to evaluate tasks again if none found
        self._last_task_evaluation_time = 0.0


        self.inventory_capacity: int = inventory_capacity
        self.current_inventory: Dict[str, Optional[ResourceType] | int] = {
            'resource_type': None,
            'quantity': 0
        }
        
        self.current_task: Optional['Task'] = None
        self.resource_priorities: Optional[List[ResourceType]] = resource_priorities

        self.gathering_timer: float = 0.0
        self.delivery_timer: float = 0.0

    def set_target(self, target_position: pygame.math.Vector2):
        """Sets the agent's target position. Primarily called by tasks."""
        self.target_position = target_position
        # The agent's state (e.g., MOVING_TO_RESOURCE) should be set by the task itself.
        # print(f"DEBUG: Agent {self.id} set_target: NewTargetGridPos={self.target_position}")

    def _move_towards_target(self, dt: float) -> bool:
        """
        Moves the agent towards its target position.
        Args: dt (float): Delta time.
        Returns: bool: True if the target was reached this frame, False otherwise.
        """
        if self.target_position is None:
            return False

        direction = self.target_position - self.position
        distance = direction.length()

        if distance < self.target_tolerance:
            self.position = pygame.math.Vector2(self.target_position) 
            self.target_position = None 
            return True
        elif distance > 0:
            normalized_direction = direction.normalize()
            movement = normalized_direction * self.speed * dt
            if movement.length() >= distance:
                self.position = pygame.math.Vector2(self.target_position)
                self.target_position = None
                return True
            else:
                self.position += movement
        return False

    def _move_randomly(self, dt: float):
        """Moves the agent randomly within the grid bounds."""
        if self.target_position is None: 
            if self.grid.width_in_cells > 0 and self.grid.height_in_cells > 0: # type: ignore
                self.target_position = pygame.math.Vector2(
                    random.uniform(0, self.grid.width_in_cells - 1), # type: ignore
                    random.uniform(0, self.grid.height_in_cells - 1) # type: ignore
                )
                self.target_position.x = max(0, min(self.target_position.x, self.grid.width_in_cells - 1)) # type: ignore
                self.target_position.y = max(0, min(self.target_position.y, self.grid.height_in_cells - 1)) # type: ignore
            else: 
                self.state = AgentState.IDLE 
                return

        if self._move_towards_target(dt):
            self.state = AgentState.IDLE

    def _evaluate_and_select_task(self, available_tasks: List['Task'], resource_manager: 'ResourceManager') -> Optional['Task']:
        """
        Evaluates available tasks and selects one based on agent's logic,
        checking for resource availability, dropoff space, and inventory compatibility.
        """
        from ..tasks.task import GatherAndDeliverTask # Local import for type checking

        candidate_tasks: List[Task] = []

        for task in available_tasks:
            if not isinstance(task, GatherAndDeliverTask): # For now, only evaluate GatherAndDeliverTasks
                print(f"DEBUG: Agent {self.id} skipping non-GatherAndDeliverTask {task.task_id} ({task.task_type.name}).")
                continue

            task_resource_type = task.resource_type_to_gather
            print(f"DEBUG: Agent {self.id} evaluating task {task.task_id} ({task.task_type.name}) for resource {task_resource_type.name}.")

            # 1. Check Agent's Resource Priorities
            if self.resource_priorities and task_resource_type not in self.resource_priorities:
                print(f"DEBUG: Agent {self.id}: Task {task.task_id} resource {task_resource_type.name} not in priorities {self.resource_priorities}. Skipping.")
                continue
            
            # 2. Check Source Availability (using ResourceManager)
            if not resource_manager.has_available_sources(task_resource_type, min_quantity=1):
                print(f"DEBUG: Agent {self.id}: Task {task.task_id} - No available sources for {task_resource_type.name}. Skipping.")
                continue
            
            # 3. Check Dropoff Availability (using ResourceManager)
            # Consider quantity agent might carry - for now, just check if *any* space.
            # A more advanced check would be: min_capacity = min(self.inventory_capacity, task.quantity_to_gather)
            if not resource_manager.has_available_dropoffs(task_resource_type, min_capacity=1):
                print(f"DEBUG: Agent {self.id}: Task {task.task_id} - No available dropoffs for {task_resource_type.name}. Skipping.")
                continue

            # 4. Check Agent Inventory Compatibility & Capacity
            current_inv_qty = self.current_inventory.get('quantity', 0)
            current_inv_type = self.current_inventory.get('resource_type')

            if current_inv_qty > 0 and current_inv_type != task_resource_type:
                remaining_capacity = self.inventory_capacity - current_inv_qty
                # Define a 'meaningful amount' - e.g., at least 1 unit or a percentage of capacity
                # For simplicity, let's say if it's carrying something else, it needs full capacity for the new task type
                # or at least capacity for 1 unit of the new type.
                # This logic can be refined. For now, if carrying something else, and not enough space for at least 1 new unit, skip.
                if remaining_capacity < 1 : # Needs to be able to carry at least 1 of the new type
                    print(f"DEBUG: Agent {self.id}: Task {task.task_id} - Inventory has {current_inv_qty} of {current_inv_type}, not enough space for {task_resource_type.name}. Skipping.")
                    continue
            
            if current_inv_qty == self.inventory_capacity and current_inv_type != task_resource_type:
                print(f"DEBUG: Agent {self.id}: Task {task.task_id} - Inventory full with {current_inv_type}, cannot take task for {task_resource_type.name}. Skipping.")
                continue
            
            print(f"DEBUG: Agent {self.id}: Task {task.task_id} ({task_resource_type.name}) PASSED all preliminary checks.")
            candidate_tasks.append(task)

        if not candidate_tasks:
            print(f"DEBUG: Agent {self.id} found NO suitable tasks after full evaluation of {len(available_tasks)} initial tasks.")
            return None

        # If multiple candidates, sort by task.priority (higher is better)
        # Then could add proximity or other heuristics. For now, highest priority.
        candidate_tasks.sort(key=lambda t: t.priority, reverse=True)
        selected_task = candidate_tasks[0]
        print(f"DEBUG: Agent {self.id} selected task {selected_task.task_id} ({selected_task.task_type.name}) P:{selected_task.priority} from {len(candidate_tasks)} candidates.")
        return selected_task


    def update(self, dt: float, resource_manager: 'ResourceManager'):
        """Updates the agent's state and behavior based on its current task or idleness."""
        from ..tasks.task_types import TaskStatus
        current_time = pygame.time.get_ticks() / 1000.0 # Get time in seconds

        if self.current_task:
            new_task_status = self.current_task.execute_step(self, dt, resource_manager)
            
            if new_task_status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]:
                # Task's cleanup should handle releasing resources/reservations
                self.current_task.cleanup(self, resource_manager, success=(new_task_status == TaskStatus.COMPLETED))
                # TaskManager handles archiving/re-posting
                self.task_manager_ref.report_task_outcome(self.current_task, new_task_status, self)
                
                self.current_task = None
                self.state = AgentState.IDLE # Become idle to look for new tasks
                self.target_position = None

                if new_task_status == TaskStatus.COMPLETED and self.current_inventory['quantity'] == 0:
                    self.current_inventory['resource_type'] = None
        
        # Agent is not busy with a task
        else:
            if self.state == AgentState.IDLE:
                # Transition to evaluating tasks
                print(f"DEBUG: Agent {self.id}: State IDLE, transitioning to EVALUATING_TASKS.")
                self.state = AgentState.EVALUATING_TASKS
                self._last_task_evaluation_time = current_time # Reset cooldown timer
            
            elif self.state == AgentState.EVALUATING_TASKS:
                if current_time - self._last_task_evaluation_time >= self.task_evaluation_cooldown:
                    print(f"DEBUG: Agent {self.id}: State EVALUATING_TASKS. Cooldown passed. Fetching tasks.")
                    self._last_task_evaluation_time = current_time
                    available_tasks = self.task_manager_ref.get_available_tasks()
                    print(f"DEBUG: Agent {self.id}: Found {len(available_tasks)} tasks on job board.")
                    
                    if available_tasks:
                        chosen_task_obj = self._evaluate_and_select_task(available_tasks, resource_manager)
                        
                        if chosen_task_obj:
                            print(f"DEBUG: Agent {self.id}: Evaluated and chose task {chosen_task_obj.task_id}. Attempting to claim.")
                            claimed_task = self.task_manager_ref.attempt_claim_task(chosen_task_obj.task_id, self)
                            if claimed_task:
                                print(f"DEBUG: Agent {self.id}: Successfully CLAIMED task {claimed_task.task_id}. Preparing task.")
                                self.current_task = claimed_task
                                # Agent's state will be set by task.prepare()
                                if not self.current_task.prepare(self, resource_manager):
                                    # Preparation failed, task will be reported as FAILED by prepare's cleanup
                                    # Agent becomes IDLE again to re-evaluate
                                    print(f"DEBUG: Agent {self.id}: Task {self.current_task.task_id} PREPARATION FAILED. Reporting outcome and returning to IDLE.")
                                    # TaskManager's report_task_outcome will handle re-posting if applicable
                                    self.task_manager_ref.report_task_outcome(self.current_task, TaskStatus.FAILED, self)
                                    # Ensure task cleanup is called if prepare fails and doesn't reach agent's main loop for cleanup
                                    if hasattr(self.current_task, 'cleanup') and callable(getattr(self.current_task, 'cleanup')):
                                         self.current_task.cleanup(self, resource_manager, success=False)
                                    self.current_task = None
                                    self.state = AgentState.IDLE
                                else:
                                    print(f"DEBUG: Agent {self.id}: Task {claimed_task.task_id} PREPARATION SUCCESSFUL. Agent state: {self.state}")

                            else:
                                # Failed to claim (e.g., another agent took it)
                                print(f"DEBUG: Agent {self.id}: Failed to claim task {chosen_task_obj.task_id}. Re-evaluating (will become IDLE).")
                                self.state = AgentState.IDLE # Re-evaluate on next suitable tick
                        else:
                            # No suitable task found by evaluation logic
                            print(f"DEBUG: Agent {self.id}: No suitable tasks found after evaluation. Moving randomly.")
                            self.state = AgentState.MOVING_RANDOMLY
                    else:
                        # No tasks on the job board
                        print(f"DEBUG: Agent {self.id}: No tasks available on job board. Moving randomly.")
                        self.state = AgentState.MOVING_RANDOMLY
                # else:
                    # print(f"DEBUG: Agent {self.id}: State EVALUATING_TASKS. Cooldown NOT passed. Waiting. Current: {current_time:.2f}, LastEval: {self._last_task_evaluation_time:.2f}, Cooldown: {self.task_evaluation_cooldown:.2f}")

            
            elif self.state == AgentState.MOVING_RANDOMLY:
                self._move_randomly(dt)
                # If _move_randomly sets state to IDLE, it will then transition to EVALUATING_TASKS
            
            # Ensure agent doesn't get stuck in a non-IDLE, non-MOVING_RANDOMLY state without a task
            elif self.state not in [AgentState.IDLE, AgentState.EVALUATING_TASKS, AgentState.MOVING_RANDOMLY]:
                 self.state = AgentState.IDLE
                 self.target_position = None


    def draw(self, screen: pygame.Surface, grid):
        """Draws the agent on the screen."""
        screen_pos = self.grid.grid_to_screen(self.position) # type: ignore
        agent_radius = self.grid.cell_width // 2 # type: ignore

        current_agent_color = self.state_colors.get(self.state, self.color)
        pygame.draw.circle(screen, current_agent_color, screen_pos, agent_radius)

        if self.current_inventory['quantity'] > 0 and self.current_inventory['resource_type'] is not None:
            carried_resource_type = self.current_inventory['resource_type']
            resource_color = self.config.RESOURCE_VISUAL_COLORS.get(carried_resource_type, (128, 128, 128)) 

            icon_radius = agent_radius // 2
            icon_offset_y = -agent_radius - icon_radius // 2 
            icon_center_x = screen_pos[0]
            icon_center_y = screen_pos[1] + icon_offset_y
            
            pygame.draw.circle(screen, resource_color, (icon_center_x, icon_center_y), icon_radius)
</file>

<file path="src/core/config.py">
# Game and Simulation Configuration

from ..resources.resource_types import ResourceType # Import for RESOURCE_VISUAL_COLORS

# Screen dimensions
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
SCREEN_SPAWN_MARGIN = 50  # Margin around the screen for spawning

# Frame rate and timing
TARGET_FPS = 60

# Grid settings
GRID_CELL_SIZE = 32
GRID_COLOR = (50, 50, 50)  # Dark grey

# Colors
COLOR_BLACK = (0, 0, 0)
COLOR_WHITE = (255, 255, 255)
DEBUG_TEXT_COLOR = COLOR_WHITE

# Resource Node Settings
BERRY_BUSH_COLOR = (0, 128, 0)  # Green
BERRY_BUSH_CAPACITY = 23
BERRY_BUSH_GENERATION_INTERVAL = 6 # Resources per second
INITIAL_BERRY_BUSHES = 15
INITIAL_WHEAT_FIELD = 15

WHEAT_GENERATION_INTERVAL = 12 # How many simulation ticks to generate 1 unit of wheat
WHEAT_FIELD_CAPACITY = 11 # Max wheat in a field

# Resource Display Settings
RESOURCE_TEXT_COLOR = COLOR_WHITE
RESOURCE_FONT_SIZE = 16
# NODE_SIZE = GRID_CELL_SIZE # Optional: Use if node size differs from grid cell
# Agent Settings
INITIAL_AGENTS = 6
AGENT_SPEED = 5.0 # Grid units per second
DEFAULT_AGENT_INVENTORY_CAPACITY = 5 # Max items an agent can carry

# Agent Action Timings
DEFAULT_GATHERING_TIME = 2.0 # Seconds to gather a resource
DEFAULT_DELIVERY_TIME = 1.0  # Seconds to deliver a resource

# Resource Visuals (used by agent draw for carried items)
RESOURCE_VISUAL_COLORS = {
    ResourceType.BERRY: (220, 20, 60),   # Crimson for BERRY
    ResourceType.WHEAT: (218, 165, 32),  # Goldenrod for WHEAT
    ResourceType.FLOUR_POWDER: (211, 211, 211), # LightGrey for FLOUR_POWDER
    # Add other resource type colors here as they are defined
    # Example: ResourceType.WATER: (0, 191, 255) # Deep Sky Blue
}
# Task Generation Settings
MIN_BERRY_STOCK_LEVEL = 50
BERRY_GATHER_TASK_QUANTITY = 20
BERRY_GATHER_TASK_PRIORITY = 5
MAX_ACTIVE_BERRY_GATHER_TASKS = 3
# Wheat Task Generation Settings
MIN_WHEAT_STOCK_LEVEL = 40
WHEAT_GATHER_TASK_QUANTITY = 15
WHEAT_GATHER_TASK_PRIORITY = 4
MAX_ACTIVE_WHEAT_GATHER_TASKS = 2
</file>

<file path="src/core/game_loop.py">
import pygame
import time
import random
from pygame.math import Vector2 # Added for agent positions
from src.core import config
from src.input import handlers as input_handlers
from src.rendering.grid import Grid # Changed from grid_renderer function to Grid class
from src.rendering import debug_display as debug_renderer
from src.resources.manager import ResourceManager
from src.resources.berry_bush import BerryBush
from src.resources.wheat_field import WheatField # Added WheatField
from src.resources.mill import Mill # Added Mill
from src.agents.manager import AgentManager # Added AgentManager
from src.tasks.task_manager import TaskManager # Added TaskManager
from src.resources.storage_point import StoragePoint
from src.resources.resource_types import ResourceType
from src.rendering.task_status_display import TaskStatusDisplay # Added for Task UI

class GameLoop:
    """
    Manages the main game loop with a fixed timestep for updates
    and variable rendering based on available time.
    """
    def __init__(self, screen):
        self.screen = screen
        self.clock = pygame.time.Clock()
        self.is_running = False
        self.last_time = time.perf_counter()
        self.accumulator = 0.0
        self.dt = 1.0 / config.TARGET_FPS # Timestep duration

        # Initialize Grid
        try:
            self.grid = Grid()
        except ValueError as e:
            print(f"FATAL: Grid initialization failed: {e}")
            # Consider how to handle this - maybe raise exception or exit?
            # For now, let's assume config is valid.
            raise # Re-raise the exception to stop execution if grid fails

        # Initialize font for resource display (ensure pygame.font.init() was called in main)
        try:
            self.resource_font = pygame.font.Font(None, config.RESOURCE_FONT_SIZE)
        except Exception as e:
            print(f"Warning: Could not load default font. Resource text might not display. Error: {e}")
            # Create a fallback font object that might work or fail gracefully in draw
            self.resource_font = pygame.font.Font(pygame.font.get_default_font(), config.RESOURCE_FONT_SIZE)


        # Initialize Resource Manager and spawn initial resources
        self.resource_manager = ResourceManager()
        self._spawn_initial_resources() # Will also spawn Mills here
        self._spawn_initial_storage_points()

        # Initialize Task Manager
        # AgentManager needs a TaskManager, and TaskManager needs an AgentManager.
        # Initialize TaskManager first, potentially with a placeholder for agent_manager_ref if needed,
        # or ensure TaskManager can function/be updated before agent_manager_ref is fully set.
        # Based on current TaskManager constructor, it needs resource_manager and agent_manager.
        # Let's initialize AgentManager first, then TaskManager, then link them.

        # Initialize Agent Manager (will need TaskManager soon)
        # For now, AgentManager's __init__ takes task_manager. So TaskManager must be first.
        self.task_manager = TaskManager(resource_manager=self.resource_manager, agent_manager=None) # type: ignore
        
        # Initialize Agent Manager and pass the TaskManager
        self.agent_manager = AgentManager(grid=self.grid, task_manager=self.task_manager)
        
        # Now, set the agent_manager_ref in TaskManager
        self.task_manager.agent_manager_ref = self.agent_manager

        self._spawn_initial_agents() # Uses grid coords

        # Initialize UI Font and Task Display Panel
        try:
            self.ui_font = pygame.font.Font(None, 24) # General UI font, size can be from config
        except Exception as e:
            print(f"Warning: Could not load default font for UI. Error: {e}")
            self.ui_font = pygame.font.Font(pygame.font.get_default_font(), 24)

        panel_width = 350  # Width of the task panel
        panel_height = config.SCREEN_HEIGHT
        panel_x = config.SCREEN_WIDTH - panel_width
        panel_y = 0
        task_panel_rect = pygame.Rect(panel_x, panel_y, panel_width, panel_height)
        
        self.task_display = TaskStatusDisplay(
            task_manager=self.task_manager,
            font=self.ui_font, # Use a dedicated UI font
            panel_rect=task_panel_rect,
            screen_surface=self.screen,
            config_module=config # Pass the config module
        )

    def _spawn_initial_agents(self):
        """Creates and places the initial agents."""
        # Example: Spawn agents at specific grid coordinates
        # Ensure these coordinates are valid for the grid size
        for _ in range(config.INITIAL_AGENTS):
            screen_pos_x = random.uniform(config.SCREEN_SPAWN_MARGIN, config.SCREEN_WIDTH - config.SCREEN_SPAWN_MARGIN)
            screen_pos_y = random.uniform(config.SCREEN_SPAWN_MARGIN, config.SCREEN_HEIGHT - config.SCREEN_SPAWN_MARGIN)
            screen_position = pygame.Vector2(screen_pos_x, screen_pos_y)
            grid_position = self.grid.screen_to_grid(screen_position) # Convert to grid coordinates
            agent = self.agent_manager.create_agent(position=grid_position, speed=config.AGENT_SPEED) # Pass grid position
            print(f"  Spawned Agent at grid position {grid_position}") # DEBUG

    def handle_input(self):
        """Handles user input using the input handler module."""
        if input_handlers.process_events():
            self.is_running = False

    def _spawn_initial_resources(self):
        """Creates and places the initial resource nodes."""
        print(f"Spawning {config.INITIAL_BERRY_BUSHES} berry bushes...") # DEBUG
        spawn_margin = config.SCREEN_SPAWN_MARGIN # Avoid spawning too close to screen edges
        for _ in range(config.INITIAL_BERRY_BUSHES):
            # Ensure bushes are placed within screen bounds, respecting margin
            screen_pos_x = random.uniform(spawn_margin, config.SCREEN_WIDTH - spawn_margin)
            screen_pos_y = random.uniform(spawn_margin, config.SCREEN_HEIGHT - spawn_margin)
            screen_position = pygame.Vector2(screen_pos_x, screen_pos_y)
            grid_position = self.grid.screen_to_grid(screen_position) # Convert to grid coordinates
            
            bush = BerryBush(grid_position) # Pass grid coordinates
            self.resource_manager.add_node(bush)
            print(f"DEBUG: Spawned BerryBush at screen_pos: {screen_position}, which is grid_pos: {grid_position}. Bush stores: {bush.position}")

        # Spawn WheatFields
        num_wheat_fields = config.INITIAL_WHEAT_FIELD # Example number
        print(f"Spawning {num_wheat_fields} wheat fields...")
        for _ in range(num_wheat_fields):
            screen_pos_x = random.uniform(spawn_margin, config.SCREEN_WIDTH - spawn_margin)
            screen_pos_y = random.uniform(spawn_margin, config.SCREEN_HEIGHT - spawn_margin)
            grid_position = self.grid.screen_to_grid(pygame.Vector2(screen_pos_x, screen_pos_y))
            
            wheat_field = WheatField(grid_position)
            self.resource_manager.add_node(wheat_field)
            print(f"DEBUG: Spawned WheatField at grid_pos: {grid_position}")

        # Spawn Mills
        mill_positions_grid = [Vector2(3, 3), Vector2(self.grid.width_in_cells - 4, self.grid.height_in_cells - 4)]
        print(f"Spawning {len(mill_positions_grid)} mills...")
        for pos in mill_positions_grid:
            if self.grid.is_within_bounds(pos):
                mill = Mill(pos)
                self.resource_manager.add_processing_station(mill) # Use the correct method
                print(f"DEBUG: Spawned Mill at grid_pos: {pos}")
            else:
                print(f"Warning: Initial mill position {pos} is outside grid bounds. Skipping.")


    def _spawn_initial_storage_points(self):
        """Creates and places the initial storage points."""
        # Calculate middle of the screen in grid coordinates
        middle_screen_x_pixels = config.SCREEN_WIDTH / 2
        middle_screen_y_pixels = config.SCREEN_HEIGHT / 2
        middle_screen_pixel_pos = pygame.math.Vector2(middle_screen_x_pixels, middle_screen_y_pixels)
        storage_position_grid = self.grid.screen_to_grid(middle_screen_pixel_pos)

        # Define storage point properties
        capacity = 25  # Updated capacity for shared storage
        accepted_types = [ResourceType.BERRY, ResourceType.WHEAT]

        # Create and add the storage point
        berry_storage_point = StoragePoint(
            position=storage_position_grid,
            overall_capacity=capacity,
            accepted_resource_types=accepted_types
        )
        # Assumes add_storage_point method exists in ResourceManager as per SLICE_2.2_PLAN.md
        self.resource_manager.add_storage_point(berry_storage_point)
        print(f"DEBUG: Spawned StoragePoint at grid_pos: {storage_position_grid} for BERRY and WHEAT with capacity {capacity}")

        # Spawn StoragePoint for Flour Powder
        flour_storage_position_grid = Vector2(self.grid.width_in_cells / 2 + 5, self.grid.height_in_cells / 2) # Example position
        if not self.grid.is_within_bounds(flour_storage_position_grid): # Ensure it's on grid
            flour_storage_position_grid = Vector2(max(0, min(flour_storage_position_grid.x, self.grid.width_in_cells -1)),
                                                  max(0, min(flour_storage_position_grid.y, self.grid.height_in_cells -1)))


        flour_storage_capacity = 30
        flour_accepted_types = [ResourceType.FLOUR_POWDER]
        flour_storage_point = StoragePoint(
            position=flour_storage_position_grid,
            overall_capacity=flour_storage_capacity,
            accepted_resource_types=flour_accepted_types
        )
        self.resource_manager.add_storage_point(flour_storage_point)
        print(f"DEBUG: Spawned StoragePoint at grid_pos: {flour_storage_position_grid} for FLOUR_POWDER with capacity {flour_storage_capacity}")


    def update(self, dt):
        """Updates game state, including resource nodes."""
        # Update resource nodes
        self.resource_manager.update_nodes(dt)

        # Update Task Manager (e.g., for task generation, timeouts)
        self.task_manager.update(dt)

        # Update agents (agents will interact with TaskManager)
        self.agent_manager.update_agents(dt, self.resource_manager)

        # Placeholder for other game entity updates

    def render(self):
        """Renders the current game state."""
        self.screen.fill(config.COLOR_BLACK) # Clear screen

        # Draw the grid using the Grid object
        self.grid.draw(self.screen)

        # Draw resource nodes
        self.resource_manager.draw_nodes(self.screen, self.resource_font, self.grid) # Pass grid object

        # Draw agents
        self.agent_manager.render_agents(self.screen, self.grid)

        # Draw debug info (FPS)
        # Use clock attribute directly for FPS calculation
        debug_renderer.display_fps(self.screen, self.clock)

        # Draw the Task Status Display Panel
        if hasattr(self, 'task_display'): # Ensure it's initialized
            self.task_display.draw()

        pygame.display.flip() # Update the full display Surface to the screen

    def run(self):
        """Executes the main game loop."""
        self.is_running = True
        self.last_time = time.perf_counter() # Reset timer before loop starts

        while self.is_running:
            current_time = time.perf_counter()
            frame_time = current_time - self.last_time
            self.last_time = current_time

            # Cap frame time to avoid spiral of death
            if frame_time > 0.25:
                frame_time = 0.25

            self.accumulator += frame_time

            # Input handling happens once per frame
            self.handle_input()

            # Fixed timestep updates
            while self.accumulator >= self.dt:
                self.update(self.dt)
                self.accumulator -= self.dt

            # Rendering happens based on available time
            # Optional: Could add interpolation factor here: alpha = self.accumulator / self.dt
            self.render()

            # Yield control, helps manage CPU usage slightly
            # We can use clock.tick here to limit the *rendering* frame rate
            # if needed, but the update logic is decoupled by the fixed step.
            self.clock.tick() # Tick without arg just measures time for get_fps()

        # Pygame quit is handled in main.py after the loop exits
</file>

</files>
